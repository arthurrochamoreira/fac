{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#fac","title":"FAC","text":"<p>Documenta\u00e7\u00e3o pessoal sobre Fundamentos de Arquitetura de Computadores, desenvolvida como apoio aos estudos da disciplina cursada na gradua\u00e7\u00e3o em Engenharia de Software.</p>"},{"location":"mod1/","title":"Modulo 1 - Introdu\u00e7\u00e3o","text":""},{"location":"mod1/#1-o-que-e-risc-v","title":"1. O que \u00e9 RISC-V?","text":"<p>RISC-V \u00e9 uma arquitetura de conjunto de instru\u00e7\u00f5es (ISA \u2014 Instruction Set Architecture). Uma ISA \u00e9 o \u201cvocabul\u00e1rio\u201d que o processador entende: as opera\u00e7\u00f5es b\u00e1sicas que ele sabe executar.</p> <ul> <li>RISC (Reduced Instruction Set Computer) = arquitetura com poucas instru\u00e7\u00f5es, simples e r\u00e1pidas.</li> <li>V = quinta gera\u00e7\u00e3o dessa fam\u00edlia RISC.</li> <li>RV32I = vers\u00e3o de 32 bits (32 = largura dos registradores) com o conjunto b\u00e1sico de instru\u00e7\u00f5es inteiras (I = Integer).</li> </ul> <p>Um processador RISC-V s\u00f3 entende opera\u00e7\u00f5es fundamentais, como:</p> <ul> <li>mover valores entre registradores (pequenas mem\u00f3rias internas do processador)</li> <li>ler/escrever na mem\u00f3ria</li> <li>fazer opera\u00e7\u00f5es aritm\u00e9ticas</li> <li>saltar para outro ponto do c\u00f3digo</li> </ul>"},{"location":"mod1/#observacao-importante","title":"Observa\u00e7\u00e3o importante","text":"<p>Os registradores possuem apelidos educativos (<code>a0</code>, <code>t0</code>, <code>s0</code> etc.), mas internamente eles continuam sendo <code>x0</code>, <code>x1</code>, \u2026, <code>x31</code>. Por exemplo:</p> <ul> <li><code>a0</code> = <code>x10</code></li> <li><code>a7</code> = <code>x17</code></li> <li><code>t0</code> = <code>x5</code></li> </ul> <p>Isso aparece no painel \u201cRegisters\u201d do RARS.</p>"},{"location":"mod1/#2-o-que-e-o-rars","title":"2. O que \u00e9 o RARS?","text":"<p>O RARS (RISC-V Assembler and Runtime Simulator) \u00e9 um simulador, ou seja:</p> <p>Um programa que imita um processador RISC-V para permitir que voc\u00ea execute c\u00f3digo sem ter o hardware real.</p> <p>Ele funciona assim:</p> <ol> <li>Voc\u00ea escreve um arquivo <code>.asm</code>    (arquivo contendo c\u00f3digo em assembly, a linguagem textual da ISA).</li> <li>O RARS monta o c\u00f3digo    (assembler = traduz para instru\u00e7\u00f5es bin\u00e1rias reais).</li> <li>O RARS executa e mostra o que acontece nos registradores e na mem\u00f3ria.</li> </ol> <p>Al\u00e9m disso, o RARS oferece syscalls (system calls): servi\u00e7os prontos como imprimir texto ou ler n\u00fameros do usu\u00e1rio.</p>"},{"location":"mod1/#3-registradores-sua-caixa-de-ferramentas","title":"3. Registradores: sua caixa de ferramentas","text":"<p>Um registrador \u00e9 uma pequena \u00e1rea de armazenamento dentro do processador. \u00c9 muito mais r\u00e1pido acessar registradores do que acessar mem\u00f3ria.</p> <p>O RISC-V possui 32 registradores inteiros, de <code>x0</code> a <code>x31</code>, cada um com um apelido:</p> Nome Uso <code>x0</code> sempre cont\u00e9m o valor 0 <code>a0\u2013a7</code> argumentos de fun\u00e7\u00f5es e syscalls (argument registers) <code>t0\u2013t6</code> tempor\u00e1rios (temporary registers) <code>s0\u2013s11</code> vari\u00e1veis preservadas (saved registers) <code>sp</code> ponteiro da pilha (stack pointer) <code>ra</code> endere\u00e7o de retorno (return address) <p>Para o Hello World utilizamos principalmente:</p> <ul> <li><code>a0</code> \u2014 registrador que cont\u00e9m o argumento da syscall</li> <li><code>a7</code> \u2014 registrador que cont\u00e9m o c\u00f3digo da syscall</li> </ul>"},{"location":"mod1/#4-formato-basico-das-instrucoes","title":"4. Formato b\u00e1sico das instru\u00e7\u00f5es","text":"<p>Uma instru\u00e7\u00e3o \u00e9 um comando da ISA. No RV32I, muitos comandos seguem o formato:</p> <pre><code>instru\u00e7\u00e3o destino, fonte1, fonte2\n</code></pre> <p>Exemplos:</p> <pre><code>add t0, t1, t2   # add = soma: t0 recebe t1 + t2\nli a0, 5         # li = load immediate: coloca 5 dentro de a0\nla a0, msg       # la = load address: carrega o endere\u00e7o do r\u00f3tulo msg\nlw t1, 0(t0)     # lw = load word: l\u00ea 4 bytes da mem\u00f3ria no endere\u00e7o t0\n</code></pre>"},{"location":"mod1/#nota-tecnica","title":"Nota t\u00e9cnica","text":"<p>No RISC-V, todos os endere\u00e7os se referem a 1 byte (mem\u00f3ria byte-addressable). Um <code>lw</code> l\u00ea 4 bytes a partir daquele endere\u00e7o.</p>"},{"location":"mod1/#5-pseudo-instrucoes","title":"5. Pseudo-instru\u00e7\u00f5es","text":"<p>O montador do RARS fornece pseudo-instru\u00e7\u00f5es, que n\u00e3o existem no hardware real, mas tornam o c\u00f3digo mais f\u00e1cil de escrever:</p> <ul> <li><code>li</code> \u2014 load immediate: carrega um valor imediato</li> <li><code>la</code> \u2014 load address: carrega o endere\u00e7o de um r\u00f3tulo</li> <li><code>mv</code> \u2014 move: copia o valor de um registrador para outro</li> </ul> <p>O montador converte essas pseudo-instru\u00e7\u00f5es em instru\u00e7\u00f5es reais RV32I durante a montagem.</p>"},{"location":"mod1/#6-sessoes-do-programa","title":"6. Sess\u00f5es do programa","text":"<p>Um arquivo <code>.asm</code> \u00e9 dividido em sess\u00f5es:</p>"},{"location":"mod1/#data-dados-estaticos-na-memoria","title":"<code>.data</code> \u2014 dados est\u00e1ticos na mem\u00f3ria","text":"<pre><code>.data\nmsg: .asciz \"Hello, World!\\n\"\n</code></pre> <p><code>.asciz</code> define uma string terminada em byte zero (<code>\\0</code>). Isso \u00e9 importante porque a syscall 4 (print_string) espera exatamente esse formato.</p>"},{"location":"mod1/#text-codigo-executavel","title":"<code>.text</code> \u2014 c\u00f3digo execut\u00e1vel","text":"<pre><code>.text\n.globl main     # .globl = global: torna 'main' o ponto de entrada\n</code></pre> <p>A execu\u00e7\u00e3o come\u00e7a no r\u00f3tulo <code>main:</code>.</p>"},{"location":"mod1/#7-como-o-rars-imprime-syscalls","title":"7. Como o RARS imprime (syscalls)","text":"<p>Uma syscall (system call) \u00e9 uma chamada ao sistema operacional do simulador para executar a\u00e7\u00f5es prontas, como imprimir ou ler entradas.</p>"},{"location":"mod1/#para-chamar-uma-syscall","title":"Para chamar uma syscall:","text":"<ol> <li>Coloque o c\u00f3digo da syscall em <code>a7</code></li> <li>Coloque o argumento em <code>a0</code></li> <li>Execute <code>ecall</code> (environment call)</li> </ol> <p>Resumo perfeito:</p> <p><code>a7</code> escolhe o servi\u00e7o, <code>a0</code> fornece o dado, <code>ecall</code> executa.</p>"},{"location":"mod1/#syscalls-usadas-no-hello-world","title":"Syscalls usadas no Hello World:","text":"C\u00f3digo Fun\u00e7\u00e3o <code>4</code> imprimir string (print_string) <code>10</code> encerrar o programa (exit2) <p>Exemplo:</p> <pre><code>la a0, msg     # a0 = endere\u00e7o da string\nli a7, 4       # a7 = c\u00f3digo de print_string\necall          # dispara a syscall\n</code></pre>"},{"location":"mod1/#8-montando-tudo-hello-world","title":"8. Montando tudo: Hello World","text":"<pre><code>    .data                           # sess\u00e3o de dados\nmsg: .asciz \"Hello, World!\\n\"       # string terminada em zero\n\n    .text                           # sess\u00e3o de c\u00f3digo\n    .globl main                     # torna 'main' vis\u00edvel\n\nmain:\n    la a0, msg                      # carrega o endere\u00e7o da string msg em a0\n    li a7, 4                        # syscall 4 = print_string\n    ecall                           # imprime\n\n    li a0, 0                        # c\u00f3digo de sa\u00edda (0 = sucesso)\n    li a7, 10                       # syscall 93 = exit2\n    ecall                           # encerra\n</code></pre>"},{"location":"mod2/","title":"M\u00f3dulo 2 \u2014 Carregar um valor da mem\u00f3ria para um registrador","text":"<p>Este m\u00f3dulo ensina exatamente o que voc\u00ea precisa para pegar um valor gravado na mem\u00f3ria (na se\u00e7\u00e3o <code>.data</code>) e coloc\u00e1-lo dentro de um registrador \u2014 uma pequena \u00e1rea de armazenamento interno do processador RISC-V.</p>"},{"location":"mod2/#1-como-a-memoria-funciona-no-risc-v","title":"1. Como a mem\u00f3ria funciona no RISC-V","text":"<p>A mem\u00f3ria \u00e9 uma sequ\u00eancia linear de endere\u00e7os, e cada endere\u00e7o armazena 1 byte (8 bits). Isso significa que a mem\u00f3ria do RISC-V \u00e9 byte-addressable \u2014 cada endere\u00e7o aponta para um byte individual.</p> <p>Quando voc\u00ea declara uma vari\u00e1vel com <code>.word</code>, est\u00e1 reservando 4 bytes (32 bits), e o montador garante que esses 4 bytes estar\u00e3o alinhados em um endere\u00e7o m\u00faltiplo de 4.</p> <p>Exemplo:</p> <pre><code>.data\nvalor: .word 10\n</code></pre> <p>Aqui:</p> <ul> <li><code>valor</code> \u00e9 um r\u00f3tulo \u2014 um nome simb\u00f3lico para um endere\u00e7o de mem\u00f3ria.</li> <li>No endere\u00e7o representado por <code>valor</code>, est\u00e3o gravados os 4 bytes que representam o n\u00famero 10.</li> </ul>"},{"location":"mod2/#2-as-duas-etapas-obrigatorias-para-ler-valores-da-memoria","title":"2. As duas etapas obrigat\u00f3rias para ler valores da mem\u00f3ria","text":"<p>Para carregar um valor da mem\u00f3ria para um registrador, sempre siga estes dois passos:</p> <ol> <li>Carregue o endere\u00e7o da vari\u00e1vel para um registrador (usando <code>la</code>, uma pseudo-instru\u00e7\u00e3o).</li> <li>Carregue o conte\u00fado desse endere\u00e7o para outro registrador (usando <code>lw</code>, load word).</li> </ol> <p>Importante:</p> <p>N\u00e3o existe instru\u00e7\u00e3o que leia o valor diretamente de um label. Labels s\u00e3o nomes de endere\u00e7os, n\u00e3o valores.</p> <p>Erro comum (n\u00e3o funciona):</p> <pre><code>lw t0, valor     # ERRADO! 'valor' n\u00e3o \u00e9 um valor, \u00e9 um endere\u00e7o.\n</code></pre>"},{"location":"mod2/#3-as-instrucoes-necessarias","title":"3. As instru\u00e7\u00f5es necess\u00e1rias","text":""},{"location":"mod2/#31-la-rd-label-load-address","title":"3.1 <code>la rd, label</code> \u2014 load address","text":"<p>Carrega o endere\u00e7o do r\u00f3tulo <code>label</code> no registrador <code>rd</code>. \u00c9 uma pseudo-instru\u00e7\u00e3o (n\u00e3o existe no hardware real), mas o montador converte automaticamente para instru\u00e7\u00f5es v\u00e1lidas RV32I.</p>"},{"location":"mod2/#32-lw-rd-offsetrs-load-word","title":"3.2 <code>lw rd, offset(rs)</code> \u2014 load word","text":"<p>L\u00ea 4 bytes a partir do endere\u00e7o <code>rs + offset</code> e coloca o conte\u00fado em <code>rd</code>.</p> <p>Como cada endere\u00e7o aponta para 1 byte, o pr\u00f3ximo elemento <code>.word</code> fica a +4.</p> <p>Exemplo:</p> <pre><code>lw t0, 0(t1)\n</code></pre> <p>Significa:</p> <p>\u201ccarregar em <code>t0</code> a word armazenada no endere\u00e7o contido em <code>t1</code>\u201d.</p>"},{"location":"mod2/#4-primeiro-exemplo-completo","title":"4. Primeiro exemplo completo","text":""},{"location":"mod2/#41-objetivo-em-linguagem-simples","title":"4.1 Objetivo em linguagem simples","text":"<p>Queremos:</p> <ul> <li>Criar uma vari\u00e1vel com valor 10</li> <li>Obter seu endere\u00e7o</li> <li>Ler o valor de volta para um registrador</li> </ul>"},{"location":"mod2/#42-codigo","title":"4.2 C\u00f3digo","text":"<pre><code>.data\nnumero: .word 10                  # vari\u00e1vel 'numero'\n\n.text\n.globl main\n\nmain:\n    la t1, numero                 # t1 = endere\u00e7o da vari\u00e1vel 'numero'\n    lw t0, 0(t1)                  # t0 = conte\u00fado armazenado no endere\u00e7o t1 (10)\n\n    li a7, 93                     # syscall exit2\n    ecall\n</code></pre> <p>Ap\u00f3s executar no RARS:</p> <ul> <li><code>t1</code> conter\u00e1 um endere\u00e7o como <code>0x10010000</code></li> <li><code>t0</code> conter\u00e1 o valor <code>10</code></li> </ul>"},{"location":"mod2/#5-segundo-exemplo-duas-variaveis-na-memoria","title":"5. Segundo exemplo \u2014 duas vari\u00e1veis na mem\u00f3ria","text":"<pre><code>.data\na: .word 5\nb: .word 7\n\n.text\n.globl main\n\nmain:\n    la t0, a\n    lw t1, 0(t0)                # t1 = 5\n\n    la t0, b\n    lw t2, 0(t0)                # t2 = 7\n\n    add t3, t1, t2              # t3 = 12\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"mod2/#6-terceiro-exemplo-array-de-word","title":"6. Terceiro exemplo \u2014 array de <code>.word</code>","text":"<p>Cada elemento de um array declarado com <code>.word</code> ocupa 4 bytes consecutivos:</p> <pre><code>.data\nvalores: .word 3, 6, 9, 12       # array cont\u00edguo na mem\u00f3ria\n\n.text\n.globl main\n\nmain:\n    la t0, valores               # t0 = endere\u00e7o do primeiro elemento\n\n    lw t1, 0(t0)                 # l\u00ea 3\n    lw t2, 4(t0)                 # l\u00ea 6\n    lw t3, 8(t0)                 # l\u00ea 9\n    lw t4, 12(t0)                # l\u00ea 12\n\n    li a7, 93\n    ecall\n</code></pre> <p>Como os endere\u00e7os s\u00e3o em bytes:</p> <ul> <li>\u00edndice 0 \u2192 offset 0</li> <li>\u00edndice 1 \u2192 offset 4</li> <li>\u00edndice 2 \u2192 offset 8</li> <li>\u00edndice 3 \u2192 offset 12</li> </ul>"},{"location":"mod2/#7-exercicio-para-voce","title":"7. Exerc\u00edcio para voc\u00ea","text":"<p>Crie um programa que:</p> <ol> <li>Declare duas vari\u00e1veis de mem\u00f3ria com os valores <code>20</code> e <code>15</code></li> <li>Carregue ambas com <code>la</code> + <code>lw</code></li> <li>Fa\u00e7a a subtra\u00e7\u00e3o <code>20 - 15</code></li> <li>Imprima o resultado com a syscall de inteiro (c\u00f3digo 1)</li> </ol>"},{"location":"mod3/","title":"M\u00f3dulo 3 \u2014 como armazenar valores na mem\u00f3ria (sw)","text":""},{"location":"mod3/#1-a-instrucao-necessaria-sw","title":"1. A instru\u00e7\u00e3o necess\u00e1ria: <code>sw</code>","text":"<p>A instru\u00e7\u00e3o:</p> <pre><code>sw rs2, offset(rs1)\n</code></pre> <p><code>sw</code> significa store word, isto \u00e9, armazenar uma word (4 bytes = 32 bits) na mem\u00f3ria.</p> <p>Ela funciona assim:</p> <ol> <li>pega o valor do registrador rs2</li> <li>pega o endere\u00e7o do registrador rs1</li> <li>soma o offset (deslocamento, em bytes)</li> <li>grava o conte\u00fado de <code>rs2</code> nos 4 bytes come\u00e7ando em <code>rs1 + offset</code></li> </ol> <p>Exemplo:</p> <pre><code>sw t0, 0(t1)\n</code></pre> <p>L\u00ea-se:</p> <p>\u201cGuardar o conte\u00fado de <code>t0</code> no endere\u00e7o apontado por <code>t1</code>.\u201d</p> <p>Importante: No RISC-V, cada endere\u00e7o representa 1 byte, por isso deslocamentos s\u00e3o m\u00faltiplos de 4 para <code>.word</code>.</p>"},{"location":"mod3/#2-declarando-espaco-para-armazenar-valores","title":"2. Declarando espa\u00e7o para armazenar valores","text":"<p>Antes de escrever na mem\u00f3ria, \u00e9 preciso reservar espa\u00e7o na se\u00e7\u00e3o <code>.data</code>.</p> <p>Existem tr\u00eas formas principais:</p>"},{"location":"mod3/#21-word-reserva-e-inicializa","title":"2.1 <code>.word</code> \u2014 reserva e inicializa","text":"<pre><code>x: .word 0\n</code></pre> <ul> <li>Aloca 4 bytes</li> <li>J\u00e1 inicializa com o valor indicado</li> <li>Garante alinhamento perfeito (m\u00faltiplo de 4)</li> </ul>"},{"location":"mod3/#22-varias-word-arrays","title":"2.2 V\u00e1rias <code>.word</code> \u2014 arrays","text":"<pre><code>buffer: .word 0, 0, 0, 0\n</code></pre> <ul> <li>Cria 4 palavras consecutivas na mem\u00f3ria</li> <li>Cada uma separada por 4 bytes</li> </ul>"},{"location":"mod3/#23-space-apenas-reserva-nao-inicializa","title":"2.3 <code>.space</code> \u2014 apenas reserva (n\u00e3o inicializa)","text":"<pre><code>area: .space 16     # 16 bytes = 4 words\n</code></pre> <ul> <li>Reserva espa\u00e7o bruto, sem inicializar</li> <li>Voc\u00ea precisa garantir alinhamento manualmente</li> </ul>"},{"location":"mod3/#3-primeiro-exercicio-guiado-guardar-e-ler-de-volta","title":"3. Primeiro exerc\u00edcio guiado: guardar e ler de volta","text":"<p>Vamos:</p> <ol> <li>Colocar o valor 25 em um registrador</li> <li>Armazenar o valor na mem\u00f3ria</li> <li>Ler novamente para confirmar</li> </ol>"},{"location":"mod3/#31-codigo-completo-e-comentado","title":"3.1 C\u00f3digo completo e comentado","text":"<pre><code>.data\nvalor: .word 0                   # reserva 4 bytes para armazenar um inteiro\n\n.text\n.globl main\n\nmain:\n    li t0, 25                    # t0 = 25\n    la t1, valor                 # t1 = endere\u00e7o de 'valor'\n    sw t0, 0(t1)                 # armazena 25 na mem\u00f3ria (posi\u00e7\u00e3o valor)\n\n    lw t2, 0(t1)                 # l\u00ea de volta: t2 deve = 25\n\n    li a7, 93                    # syscall exit2\n    ecall\n</code></pre> <p>Resultado no RARS:</p> <ul> <li><code>t2</code> conter\u00e1 <code>25</code></li> <li>A mem\u00f3ria mostrar\u00e1: <code>0x00000019</code> (19 hex = 25 decimal)</li> </ul>"},{"location":"mod3/#4-gravando-valores-em-um-array","title":"4. Gravando valores em um array","text":"<p>Como <code>.word</code> alinha automaticamente, cada elemento fica separado por 4 bytes.</p> <p>Vamos gravar 4 valores em um vetor:</p>"},{"location":"mod3/#41-codigo","title":"4.1 C\u00f3digo","text":"<pre><code>.data\nvetor: .word 0, 0, 0, 0          # 4 words consecutivas (16 bytes)\n\n.text\n.globl main\n\nmain:\n    la t0, vetor                 # t0 = endere\u00e7o do vetor[0]\n\n    li t1, 100\n    sw t1, 0(t0)                 # vetor[0] = 100\n\n    li t1, 200\n    sw t1, 4(t0)                 # vetor[1] = 200\n\n    li t1, 300\n    sw t1, 8(t0)                 # vetor[2] = 300\n\n    li t1, 400\n    sw t1, 12(t0)                # vetor[3] = 400\n\n    li a7, 93\n    ecall\n</code></pre> <p>Observa\u00e7\u00e3o: Offsets da forma <code>4 * \u00edndice</code>.</p>"},{"location":"mod3/#5-observacao-fundamental-alinhamento","title":"5. Observa\u00e7\u00e3o fundamental: alinhamento","text":"<p>Alinhamento \u00e9 a exig\u00eancia de que dados de tamanho N bytes estejam armazenados em endere\u00e7os m\u00faltiplos de N.</p> <p>No RISC-V:</p> <ul> <li>word (4 bytes) \u2192 endere\u00e7o m\u00faltiplo de 4</li> <li>halfword (2 bytes) \u2192 endere\u00e7o m\u00faltiplo de 2</li> </ul> <p><code>.word</code> cuida disso automaticamente.</p> <p><code>.space</code> n\u00e3o cuida, ent\u00e3o voc\u00ea deve garantir manualmente.</p> <p>Exemplo de armadilha:</p> <pre><code>.space 1\n.word 5    # pode ficar desalinhado se voc\u00ea n\u00e3o ajustar\n</code></pre>"},{"location":"mod3/#6-a-sequencia-geral-escrever-e-ler","title":"6. A sequ\u00eancia geral: escrever e ler","text":"<p>Sempre siga este padr\u00e3o:</p> <pre><code>la t0, variavel        # pegar endere\u00e7o\nsw t1, 0(t0)           # escrever valor na mem\u00f3ria\nlw t2, 0(t0)           # ler valor de volta\n</code></pre> <p>Isso resolve 95% das d\u00favidas com mem\u00f3ria no RISC-V.</p>"},{"location":"mod3/#7-exercicios-para-voce","title":"7. Exerc\u00edcios para voc\u00ea","text":""},{"location":"mod3/#exercicio-1","title":"Exerc\u00edcio 1","text":"<p>Guarde o valor 57 na mem\u00f3ria usando <code>sw</code> e depois imprima com a syscall de inteiro (<code>a7 = 1</code>).</p>"},{"location":"mod3/#exercicio-2","title":"Exerc\u00edcio 2","text":"<p>Crie um array de 5 posi\u00e7\u00f5es e grave: 10, 20, 30, 40, 50. Depois some tudo em um registrador.</p>"},{"location":"mod3/#exercicio-3","title":"Exerc\u00edcio 3","text":"<p>Crie uma \u00e1rea <code>.space 12</code> (12 bytes = 3 words) e escreva 3 valores nela usando <code>sw</code>.</p>"},{"location":"mod4/","title":"M\u00f3dulo 4 \u2014 Ler dois valores do usu\u00e1rio, somar e imprimir","text":"<p>Neste m\u00f3dulo voc\u00ea aprender\u00e1 a:</p> <ul> <li>ler valores digitados pelo usu\u00e1rio</li> <li>armazen\u00e1-los em registradores</li> <li>realizar opera\u00e7\u00f5es aritm\u00e9ticas</li> <li>imprimir um resultado na tela usando syscalls</li> </ul> <p>Esse \u00e9 um dos primeiros fluxos completos de entrada\u2013processamento\u2013sa\u00edda em RISC-V.</p>"},{"location":"mod4/#1-as-syscalls-utilizadas","title":"1. As syscalls utilizadas","text":"<p>O RARS (RISC-V Assembler and Runtime Simulator) \u00e9 um simulador que permite executar programas RISC-V e oferece servi\u00e7os chamados syscalls (system calls). Cada syscall \u00e9 identificada por um c\u00f3digo num\u00e9rico, colocado no registrador <code>a7</code>, e executada com a instru\u00e7\u00e3o <code>ecall</code> (environment call).</p> <p>A comunica\u00e7\u00e3o com syscalls usa principalmente:</p> <ul> <li><code>a7</code>: registrador que especifica qual syscall usar</li> <li><code>a0</code>: registrador que carrega argumentos ou recebe resultados</li> </ul> <p>Para este m\u00f3dulo, utilizaremos:</p>"},{"location":"mod4/#11-ler-inteiro-syscall-5","title":"1.1 Ler inteiro \u2014 syscall 5","text":"<pre><code>li a7, 5       # selecionar read_int\necall\n</code></pre> <p>Resultado ap\u00f3s <code>ecall</code>:</p> <ul> <li>o n\u00famero digitado pelo usu\u00e1rio vai para <code>a0</code></li> </ul>"},{"location":"mod4/#12-imprimir-inteiro-syscall-1","title":"1.2 Imprimir inteiro \u2014 syscall 1","text":"<pre><code>mv a0, valor   # argumento a imprimir\nli a7, 1       # selecionar print_int\necall\n</code></pre>"},{"location":"mod4/#13-encerrar-o-programa-syscall-93","title":"1.3 Encerrar o programa \u2014 syscall 93","text":"<pre><code>li a7, 93      # exit2\necall\n</code></pre> <p>Essa syscall finaliza a execu\u00e7\u00e3o corretamente.</p>"},{"location":"mod4/#2-passo-a-passo-da-logica-em-linguagem-natural","title":"2. Passo a passo da l\u00f3gica (em linguagem natural)","text":"<ol> <li>Mostrar uma mensagem pedindo o primeiro n\u00famero</li> <li>Ler o n\u00famero com a syscall read_int \u2192 valor cai em <code>a0</code></li> <li>Mover esse valor para <code>t0</code> (registrador tempor\u00e1rio)</li> <li>Repetir o processo para o segundo n\u00famero \u2192 guardar em <code>t1</code></li> <li>Somar <code>t0 + t1</code> e guardar o resultado em <code>t2</code></li> <li>Copiar <code>t2</code> para <code>a0</code> (argumento da syscall print_int)</li> <li>Chamar a syscall de imprimir inteiro</li> <li>Encerrar o programa com a syscall exit2</li> </ol> <p>Isso forma seu primeiro \u201cprograma interativo\u201d em RISC-V.</p>"},{"location":"mod4/#3-codigo-completo-e-comentado","title":"3. C\u00f3digo completo e comentado","text":"<pre><code>.data\nmsg1: .asciz \"Digite o primeiro numero: \"   # .asciz = string terminada em 0\nmsg2: .asciz \"Digite o segundo numero: \"\nmsgR: .asciz \"Resultado: \"\n\n.text\n.globl main\n\nmain:\n    # ---- Ler primeiro n\u00famero ----\n    la a0, msg1                # endere\u00e7o da string msg1\n    li a7, 4                   # syscall print_string\n    ecall\n\n    li a7, 5                   # syscall read_int\n    ecall                      # usu\u00e1rio digita \u2192 valor cai em a0\n    mv t0, a0                  # salva o valor lido em t0 (registrador tempor\u00e1rio)\n\n    # ---- Ler segundo n\u00famero ----\n    la a0, msg2\n    li a7, 4                   # print_string\n    ecall\n\n    li a7, 5                   # read_int\n    ecall\n    mv t1, a0                  # salva o valor lido em t1\n\n    # ---- Soma ----\n    add t2, t0, t1             # t2 = t0 + t1\n\n    # ---- Imprimir resultado ----\n    la a0, msgR                # imprime prefixo \"Resultado: \"\n    li a7, 4\n    ecall\n\n    mv a0, t2                  # coloca o resultado em a0\n    li a7, 1                   # print_int\n    ecall\n\n    # ---- Encerrar ----\n    li a7, 93                  # exit2\n    ecall\n</code></pre>"},{"location":"mod4/#4-como-testar-no-rars","title":"4. Como testar no RARS","text":"<ol> <li>Abra o arquivo <code>.asm</code> no RARS</li> <li>Clique em Assemble</li> <li>Clique em Run \u2192 Go</li> <li>O console solicitar\u00e1 os n\u00fameros</li> <li>Digite os dois valores desejados</li> </ol> <p>Sa\u00edda esperada:</p> <pre><code>Digite o primeiro numero: 7\nDigite o segundo numero: 4\nResultado: 11\n</code></pre>"},{"location":"mod5/","title":"M\u00f3dulo 5 \u2014 Loops e Desvios (<code>beq</code>, <code>bne</code>, <code>j</code>)","text":"<p>Em assembly RISC-V n\u00e3o existem palavras como <code>while</code>, <code>for</code> ou <code>loop</code>. O que existe \u00e9:</p> <ul> <li>r\u00f3tulos (labels) \u2192 marcam posi\u00e7\u00f5es no c\u00f3digo</li> <li>desvios (branches) \u2192 instru\u00e7\u00f5es que saltam para um r\u00f3tulo com base em uma condi\u00e7\u00e3o</li> </ul> <p>Qualquer loop de alto n\u00edvel se transforma em uma estrutura:</p> <ol> <li>inicializa\u00e7\u00e3o do contador</li> <li>defini\u00e7\u00e3o de um r\u00f3tulo para o in\u00edcio do loop</li> <li>corpo do loop</li> <li>atualiza\u00e7\u00e3o do estado (contador, ponteiro, etc.)</li> <li>desvio condicional para repetir</li> </ol> <p>Exemplo m\u00ednimo:</p> <pre><code>loop:\n    ... instru\u00e7\u00f5es ...\n    beq x0, x0, loop    # desvio incondicional (x0 == x0 sempre)\n</code></pre>"},{"location":"mod5/#1-instrucoes-essenciais-de-desvio","title":"1. Instru\u00e7\u00f5es essenciais de desvio","text":""},{"location":"mod5/#11-beq-rs1-rs2-label","title":"1.1 <code>beq rs1, rs2, label</code>","text":"<p>Desvia se <code>rs1 == rs2</code>.</p>"},{"location":"mod5/#12-bne-rs1-rs2-label","title":"1.2 <code>bne rs1, rs2, label</code>","text":"<p>Desvia se <code>rs1 != rs2</code>.</p>"},{"location":"mod5/#13-j-label","title":"1.3 <code>j label</code>","text":"<p>Pseudo-instru\u00e7\u00e3o de salto incondicional, montada como:</p> <pre><code>jal x0, label\n</code></pre> <p>Como <code>x0</code> descarta valores, o salto n\u00e3o registra endere\u00e7o de retorno.</p> <p>Ao dominar essas tr\u00eas, voc\u00ea j\u00e1 implementa loops equivalentes a <code>while</code> e <code>for</code>.</p>"},{"location":"mod5/#2-exemplo-1-contagem-regressiva-de-5-ate-1","title":"2. Exemplo 1 \u2014 Contagem regressiva de 5 at\u00e9 1","text":""},{"location":"mod5/#logica-em-portugues","title":"L\u00f3gica em portugu\u00eas","text":"<ol> <li><code>t0 = 5</code></li> <li>imprimir <code>t0</code></li> <li>diminuir <code>t0</code></li> <li>enquanto <code>t0 != 0</code>, repetir</li> <li>quando <code>t0 == 0</code>, encerrar</li> </ol> <p><code>t0</code> \u00e9 um registrador tempor\u00e1rio (grupo <code>t0\u2013t6</code>).</p>"},{"location":"mod5/#codigo-completo","title":"C\u00f3digo completo","text":"<pre><code>.data\nmsg: .asciz \"Valor: \"\n\n.text\n.globl main\n\nmain:\n    li t0, 5                 # contador inicial\n\nloop:\n    # imprime \"Valor: \"\n    la a0, msg               # endere\u00e7o da string\n    li a7, 4                 # print_string\n    ecall\n\n    # imprime o valor atual\n    mv a0, t0\n    li a7, 1                 # print_int\n    ecall\n\n    # quebra de linha\n    li a0, 10                # '\\n'\n    li a7, 11                # print_char\n    ecall\n\n    addi t0, t0, -1          # t0--\n\n    bne t0, x0, loop         # enquanto t0 != 0 \u2192 repete\n\n    li a7, 93                # exit2\n    ecall\n</code></pre>"},{"location":"mod5/#3-exemplo-2-contagem-crescente-de-1-a-10","title":"3. Exemplo 2 \u2014 Contagem crescente de 1 a 10","text":"<p>Aqui usamos uma instru\u00e7\u00e3o adicional:</p> <ul> <li><code>blt rs1, rs2, label</code> \u2192 desvia se <code>rs1 &lt; rs2</code>.</li> </ul>"},{"location":"mod5/#codigo","title":"C\u00f3digo","text":"<pre><code>.text\n.globl main\n\nmain:\n    li t0, 1          # contador = 1\n\nloop:\n    mv a0, t0\n    li a7, 1          # print_int\n    ecall\n\n    # quebra de linha\n    li a0, 10\n    li a7, 11\n    ecall\n\n    addi t0, t0, 1    # t0++\n\n    li t1, 11\n    blt t0, t1, loop  # enquanto t0 &lt; 11 \u2192 repete\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"mod5/#4-exemplo-3-soma-de-1-ate-n","title":"4. Exemplo 3 \u2014 Soma de 1 at\u00e9 N","text":"<p>Vers\u00e3o do cl\u00e1ssico:</p> <pre><code>soma = 0\ni = 1\nenquanto i &lt;= N:\n    soma += i\n    i++\n</code></pre> <p>Registradores usados:</p> <ul> <li><code>t0</code> = N</li> <li><code>t1</code> = i</li> <li><code>t2</code> = soma</li> </ul> <p>Aqui usamos <code>ble rs1, rs2, label</code> \u2192 desvia se <code>rs1 &lt;= rs2</code>.</p>"},{"location":"mod5/#codigo_1","title":"C\u00f3digo","text":"<pre><code>.data\nmsg: .asciz \"Soma final: \"\n\n.text\n.globl main\n\nmain:\n    li t0, 5              # N = 5\n    li t1, 1              # i = 1\n    li t2, 0              # soma = 0\n\nloop:\n    add t2, t2, t1        # soma += i\n    addi t1, t1, 1        # i++\n\n    ble t1, t0, loop      # enquanto i &lt;= N \u2192 repete\n\n    la a0, msg\n    li a7, 4              # print_string\n    ecall\n\n    mv a0, t2\n    li a7, 1              # print_int\n    ecall\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"mod5/#5-exemplo-4-somar-todos-os-elementos-de-um-array","title":"5. Exemplo 4 \u2014 Somar todos os elementos de um array","text":"<p>Cada elemento <code>.word</code> ocupa 4 bytes. Percorremos o vetor avan\u00e7ando o ponteiro em +4 a cada itera\u00e7\u00e3o.</p> <p>Registradores:</p> <ul> <li><code>t0</code> \u2192 ponteiro para elemento atual</li> <li><code>t1</code> \u2192 \u00edndice</li> <li><code>t2</code> \u2192 soma</li> <li><code>t3</code> \u2192 elemento atual</li> <li><code>t4</code> \u2192 tamanho do vetor</li> </ul>"},{"location":"mod5/#codigo_2","title":"C\u00f3digo","text":"<pre><code>.data\nvet: .word 3, 6, 9, 12\nmsg: .asciz \"Soma: \"\n\n.text\n.globl main\n\nmain:\n    la t0, vet         # ponteiro inicial\n    li t1, 0           # \u00edndice\n    li t2, 0           # soma\n\nloop:\n    lw t3, 0(t0)       # elemento atual\n    add t2, t2, t3     # soma += elemento\n\n    addi t0, t0, 4     # pr\u00f3ximo elemento\n    addi t1, t1, 1     # \u00edndice++\n\n    li t4, 4           # tamanho do vetor (4 elementos)\n    blt t1, t4, loop   # enquanto i &lt; 4 \u2192 repete\n\n    la a0, msg\n    li a7, 4\n    ecall\n\n    mv a0, t2\n    li a7, 1\n    ecall\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"mod5/#6-molde-geral-de-um-loop-no-risc-v","title":"6. Molde geral de um loop no RISC-V","text":"<p>Voc\u00ea pode usar este template para qualquer loop:</p> <pre><code>    # inicializa\u00e7\u00e3o\n\nloop:\n    # corpo do loop\n\n    # atualiza\u00e7\u00e3o do estado\n\n    # condi\u00e7\u00e3o de repeti\u00e7\u00e3o\n    beq / bne / blt / ble / bge / bgt ... loop\n</code></pre> <p>Esse formato mapeia diretamente para <code>while</code> e <code>for</code>.</p>"},{"location":"mod5/#7-exercicios-propostos","title":"7. Exerc\u00edcios propostos","text":"<ol> <li>Imprimir os n\u00fameros de 10 at\u00e9 1</li> <li>Imprimir apenas os pares de 2 at\u00e9 20</li> <li>Somar todos os 2 \u00d7 i, para <code>i</code> de 1 a 10</li> <li>Percorrer um vetor de 6 posi\u00e7\u00f5es e contar quantos s\u00e3o &gt; 50</li> <li>Ler um n\u00famero N do usu\u00e1rio e imprimir de 1 at\u00e9 N</li> </ol>"},{"location":"mod6/","title":"M\u00f3dulo 6 \u2014 Condi\u00e7\u00f5es e IF no RISC-V","text":"<p>Em assembly RISC-V n\u00e3o existe a instru\u00e7\u00e3o <code>if</code>. O processador apenas executa desvios condicionais (branches), que fazem:</p> <p>\u201cSe a condi\u00e7\u00e3o for verdadeira, pule para este ponto do c\u00f3digo.\u201d</p> <p>Um IF de alto n\u00edvel \u00e9 apenas uma combina\u00e7\u00e3o de:</p> <ol> <li>compara\u00e7\u00e3o entre registradores</li> <li>branch condicional</li> <li>r\u00f3tulos para marcar pontos de desvio</li> </ol>"},{"location":"mod6/#1-principais-instrucoes-de-desvio-rv32i","title":"1. Principais instru\u00e7\u00f5es de desvio (RV32I)","text":"<p>Todos os branches comparam registradores:</p> <ul> <li><code>rs1</code> e <code>rs2</code> \u2192 registradores-fonte</li> <li><code>label</code> \u2192 r\u00f3tulo que marca um endere\u00e7o no c\u00f3digo</li> </ul>"},{"location":"mod6/#beq-rs1-rs2-label","title":"<code>beq rs1, rs2, label</code>","text":"<p>Desvia se <code>rs1 == rs2</code>.</p>"},{"location":"mod6/#bne-rs1-rs2-label","title":"<code>bne rs1, rs2, label</code>","text":"<p>Desvia se <code>rs1 != rs2</code>.</p>"},{"location":"mod6/#blt-rs1-rs2-label","title":"<code>blt rs1, rs2, label</code>","text":"<p>Desvia se <code>rs1 &lt; rs2</code> (com sinal).</p>"},{"location":"mod6/#bge-rs1-rs2-label","title":"<code>bge rs1, rs2, label</code>","text":"<p>Desvia se <code>rs1 &gt;= rs2</code>.</p>"},{"location":"mod6/#bltu-bgeu","title":"<code>bltu</code> / <code>bgeu</code>","text":"<p>Vers\u00f5es unsigned.</p> <p>Com essas quatro (<code>beq</code>, <code>bne</code>, <code>blt</code>, <code>bge</code>) j\u00e1 \u00e9 poss\u00edvel implementar qualquer express\u00e3o condicional.</p>"},{"location":"mod6/#2-estrutura-geral-de-um-if-em-assembly","title":"2. Estrutura geral de um IF em assembly","text":""},{"location":"mod6/#if-simples","title":"IF simples","text":"<pre><code>    # condi\u00e7\u00e3o\n    beq rs1, rs2, bloco_verdadeiro\n\n    # falso\n    ...\n    j fim\n\nbloco_verdadeiro:\n    # verdadeiro\n    ...\n\nfim:\n</code></pre>"},{"location":"mod6/#ifelse","title":"IF\u2013ELSE","text":"<pre><code>    beq rs1, rs2, verdadeiro\n\n    # falso\n    ...\n    j fim\n\nverdadeiro:\n    ...\nfim:\n</code></pre> <p>A pseudo-instru\u00e7\u00e3o <code>j label</code> \u00e9 montada como <code>jal x0, label</code>.</p>"},{"location":"mod6/#3-exemplo-1-testar-se-um-numero-e-igual-a-10","title":"3. Exemplo 1 \u2014 Testar se um n\u00famero \u00e9 igual a 10","text":"<p>Queremos:</p> <ul> <li>imprimir \u201cigual\u201d se <code>t0 == 10</code></li> <li>sen\u00e3o imprimir \u201cdiferente\u201d</li> </ul> <pre><code>.data\nmsgIgual: .asciz \"O valor \u00e9 igual a 10\\n\"\nmsgDif:   .asciz \"O valor \u00e9 diferente de 10\\n\"\n\n.text\n.globl main\n\nmain:\n    li t0, 10              # n\u00famero para testar\n    li t1, 10              # compara\u00e7\u00e3o\n\n    beq t0, t1, eh_igual   # se t0 == 10 \u2192 vai para eh_igual\n\n    # falso\n    la a0, msgDif\n    li a7, 4               # print_string\n    ecall\n    j fim\n\neh_igual:\n    la a0, msgIgual\n    li a7, 4\n    ecall\n\nfim:\n    li a7, 93              # exit2\n    ecall\n</code></pre>"},{"location":"mod6/#4-exemplo-2-testar-se-um-numero-e-maior-que-outro","title":"4. Exemplo 2 \u2014 Testar se um n\u00famero \u00e9 maior que outro","text":"<p>Implementa\u00e7\u00e3o de:</p> <pre><code>if (t0 &gt; t1)\n   ...\nelse\n   ...\n</code></pre> <p>Usamos a l\u00f3gica:</p> <ul> <li>se <code>t0 &lt; t1</code> \u2192 n\u00e3o \u00e9 maior</li> <li>caso contr\u00e1rio \u2192 maior ou igual</li> </ul> <pre><code>.data\nmsgMaior: .asciz \"t0 \u00e9 maior que t1\\n\"\nmsgMenor: .asciz \"t0 \u00e9 menor ou igual a t1\\n\"\n\n.text\n.globl main\n\nmain:\n    li t0, 15\n    li t1, 7\n\n    blt t0, t1, menor_ou_igual   # se t0 &lt; t1 \u2192 v\u00e1 ao bloco falso\n\n    # verdadeiro\n    la a0, msgMaior\n    li a7, 4\n    ecall\n    j fim\n\nmenor_ou_igual:\n    la a0, msgMenor\n    li a7, 4\n    ecall\n\nfim:\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"mod6/#5-exemplo-3-if-com-entrada-do-usuario","title":"5. Exemplo 3 \u2014 IF com entrada do usu\u00e1rio","text":"<p>Syscall 5 l\u00ea um inteiro e o coloca em <code>a0</code>.</p> <p>Objetivo:</p> <ul> <li>se &lt; 0 \u2192 \u201cnegativo\u201d</li> <li>se == 0 \u2192 \u201czero\u201d</li> <li>sen\u00e3o \u2192 \u201cpositivo\u201d</li> </ul> <pre><code>.data\nmsgNeg:  .asciz \"Numero negativo\\n\"\nmsgZero: .asciz \"Numero zero\\n\"\nmsgPos:  .asciz \"Numero positivo\\n\"\n\n.text\n.globl main\n\nmain:\n    li a7, 5                # read_int\n    ecall\n    mv t0, a0               # guarda valor lido\n\n    blt t0, x0, negativo    # se &lt; 0\n    beq t0, x0, zero        # se == 0\n\n    # positivo\n    la a0, msgPos\n    li a7, 4\n    ecall\n    j fim\n\nnegativo:\n    la a0, msgNeg\n    li a7, 4\n    ecall\n    j fim\n\nzero:\n    la a0, msgZero\n    li a7, 4\n    ecall\n\nfim:\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"mod6/#6-exemplo-4-if-dentro-de-um-loop-testar-parimpar","title":"6. Exemplo 4 \u2014 IF dentro de um loop (testar par/\u00edmpar)","text":"<p>Testar paridade:</p> <ul> <li><code>n % 2 == 0</code></li> <li>equivalente a: bit menos significativo \u00e9 0</li> <li>AND bit a bit resolve isso: <code>t2 = t0 &amp; 1</code></li> </ul> <pre><code>.text\n.globl main\n\nmain:\n    li t0, 1               # contador\n\nloop:\n    andi t2, t0, 1         # t2 = t0 &amp; 1\n    bne t2, x0, nao_par    # se != 0 \u2192 \u00edmpar\n\neh_par:\n    mv a0, t0\n    li a7, 1               # print_int\n    ecall\n\nnao_par:\n    addi t0, t0, 1\n    li t1, 11\n    blt t0, t1, loop\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"mod7/","title":"M\u00f3dulo 7 \u2014 Fun\u00e7\u00f5es no RISC-V (RV32I)","text":"<p>Em assembly, uma \u201cfun\u00e7\u00e3o\u201d n\u00e3o \u00e9 um recurso m\u00e1gico da linguagem: \u00e9 apenas uma conven\u00e7\u00e3o constru\u00edda com r\u00f3tulos e instru\u00e7\u00f5es de desvio.</p> <p>Uma fun\u00e7\u00e3o, na pr\u00e1tica, \u00e9:</p> <ol> <li>Um r\u00f3tulo marcando o in\u00edcio da fun\u00e7\u00e3o</li> <li>Um bloco de c\u00f3digo execut\u00e1vel</li> <li>Um retorno para o ponto de chamada</li> </ol> <p>N\u00e3o existe palavra-chave <code>function</code>. N\u00f3s \u00e9 que organizamos o c\u00f3digo para se comportar como fun\u00e7\u00f5es.</p>"},{"location":"mod7/#1-a-instrucao-fundamental-jal-jump-and-link","title":"1. A instru\u00e7\u00e3o fundamental: <code>jal</code> (jump and link)","text":"<p>A instru\u00e7\u00e3o:</p> <pre><code>jal rd, label\n</code></pre> <p>faz duas coisas:</p> <ol> <li> <p>Salva o endere\u00e7o da pr\u00f3xima instru\u00e7\u00e3o em <code>rd</code></p> </li> <li> <p>normalmente usamos <code>ra</code> (return address), que \u00e9 o registrador x1</p> </li> <li>Desvia a execu\u00e7\u00e3o para o r\u00f3tulo <code>label</code></li> </ol> <p>Ou seja:</p> <pre><code>jal ra, funcao    # salva o endere\u00e7o de retorno em ra e salta para funcao\n</code></pre>"},{"location":"mod7/#como-retornar-da-funcao","title":"Como retornar da fun\u00e7\u00e3o","text":"<p>O retorno \u00e9 feito com a pseudo-instru\u00e7\u00e3o:</p> <pre><code>ret\n</code></pre> <p>que o montador traduz para uma forma de salto indireto usando o registrador <code>ra</code> (em RV32I real, via <code>jalr</code>).</p>"},{"location":"mod7/#2-esqueleto-de-uma-funcao-em-risc-v","title":"2. Esqueleto de uma fun\u00e7\u00e3o em RISC-V","text":"<pre><code>funcao:\n    # ... corpo da fun\u00e7\u00e3o ...\n    ret       # volta para o endere\u00e7o salvo em ra\n</code></pre> <p>E a chamada, no c\u00f3digo que invoca:</p> <pre><code>jal ra, funcao   # chama a fun\u00e7\u00e3o\n# quando a fun\u00e7\u00e3o der ret, a execu\u00e7\u00e3o continua aqui\n</code></pre>"},{"location":"mod7/#3-convencao-de-chamada-abi-versao-simplificada","title":"3. Conven\u00e7\u00e3o de chamada (ABI) \u2014 vers\u00e3o simplificada","text":"<p>A ABI (Application Binary Interface) define como fun\u00e7\u00f5es trocam dados.</p> <p>No RISC-V (RV32I), as regras b\u00e1sicas s\u00e3o:</p> <ol> <li> <p>Argumentos v\u00e3o em <code>a0\u2013a7</code></p> </li> <li> <p>\u201ca\u201d vem de argument registers</p> </li> <li> <p>Valor de retorno volta em <code>a0</code></p> </li> <li> <p>e em <code>a1</code> se precisar de dois registradores</p> </li> <li>Quem chama a fun\u00e7\u00e3o pode usar <code>t0\u2013t6</code> \u00e0 vontade (registradores tempor\u00e1rios)</li> <li> <p>Se a fun\u00e7\u00e3o modificar registradores \u201csalvos\u201d (<code>s0\u2013s11</code>), deve restaur\u00e1-los antes de retornar</p> </li> <li> <p>isso \u00e9 feito com pilha (stack), assunto do pr\u00f3ximo m\u00f3dulo</p> </li> </ol> <p>Para come\u00e7ar, basta pensar assim:</p> <ul> <li><code>a0</code> \u2192 argumento de entrada</li> <li><code>a0</code> \u2192 valor de retorno</li> <li><code>ra</code> \u2192 endere\u00e7o de retorno</li> </ul>"},{"location":"mod7/#4-exemplo-1-funcao-que-imprime-um-numero","title":"4. Exemplo 1 \u2014 Fun\u00e7\u00e3o que imprime um n\u00famero","text":"<p>Objetivo: criar uma fun\u00e7\u00e3o <code>imprime_numero</code> que:</p> <ul> <li>recebe em <code>a0</code> o n\u00famero a imprimir</li> <li>usa a syscall 1 (<code>print_int</code>)</li> <li>n\u00e3o altera o valor de <code>a0</code> al\u00e9m do necess\u00e1rio</li> </ul>"},{"location":"mod7/#funcao","title":"Fun\u00e7\u00e3o","text":"<pre><code>imprime_numero:\n    li a7, 1          # 1 = syscall print_int\n    ecall             # imprime o inteiro em a0\n    ret\n</code></pre>"},{"location":"mod7/#chamada","title":"Chamada","text":"<pre><code>li a0, 42             # valor a imprimir\njal ra, imprime_numero\n</code></pre> <p>Essa \u00e9 a forma correta segundo a ABI: o argumento vai em <code>a0</code>.</p>"},{"location":"mod7/#5-exemplo-2-funcao-que-soma-dois-numeros","title":"5. Exemplo 2 \u2014 Fun\u00e7\u00e3o que soma dois n\u00fameros","text":"<p>Conven\u00e7\u00e3o adotada:</p> <ul> <li><code>a0</code> = primeiro n\u00famero</li> <li><code>a1</code> = segundo n\u00famero</li> <li>retorno em <code>a0</code></li> </ul>"},{"location":"mod7/#funcao_1","title":"Fun\u00e7\u00e3o","text":"<pre><code>soma:\n    add a0, a0, a1    # a0 = a0 + a1\n    ret\n</code></pre>"},{"location":"mod7/#chamada_1","title":"Chamada","text":"<pre><code>li a0, 15\nli a1, 27\njal ra, soma          # ao voltar, a0 = 42\n</code></pre> <p>Depois da chamada, podemos usar <code>a0</code> normalmente com o resultado.</p>"},{"location":"mod7/#6-uso-de-registradores-temporarios","title":"6. Uso de registradores tempor\u00e1rios","text":"<ul> <li>Registradores tempor\u00e1rios (<code>t0\u2013t6</code>) n\u00e3o precisam ser preservados pela fun\u00e7\u00e3o</li> <li> <p>Registradores salvos (<code>s0\u2013s11</code>) devem ser preservados se a fun\u00e7\u00e3o os modificar</p> </li> <li> <p>isso \u00e9 feito empilhando valores na pilha (stack), que veremos no pr\u00f3ximo m\u00f3dulo</p> </li> </ul> <p>Por enquanto, vamos escrever fun\u00e7\u00f5es que s\u00f3 usam:</p> <ul> <li><code>a0\u2013a1</code> para argumentos/retorno</li> <li><code>t0\u2013t6</code> como auxiliares locais</li> </ul>"},{"location":"mod7/#7-exemplo-3-multiplicar-por-3-usando-funcao","title":"7. Exemplo 3 \u2014 Multiplicar por 3 usando fun\u00e7\u00e3o","text":"<p>Vamos fazer uma fun\u00e7\u00e3o <code>vezes3</code> que recebe um inteiro em <code>a0</code> e devolve <code>3 * a0</code> em <code>a0</code>.</p>"},{"location":"mod7/#codigo-completo","title":"C\u00f3digo completo","text":"<pre><code>.text\n.globl main\n\nmain:\n    li a0, 10             # valor de entrada\n    jal ra, vezes3        # chama a fun\u00e7\u00e3o\n\n    li a7, 1              # print_int\n    ecall\n\n    li a7, 93             # exit2\n    ecall\n\nvezes3:\n    mv t0, a0             # t0 = a0 (c\u00f3pia do argumento)\n    add a0, a0, t0        # a0 = a0 + t0  (2x)\n    add a0, a0, t0        # a0 = a0 + t0  (3x)\n    ret\n</code></pre> <p>Ap\u00f3s a fun\u00e7\u00e3o:</p> <ul> <li>se a entrada era 10, <code>a0</code> passa a ser 30.</li> </ul>"},{"location":"mod7/#8-exemplo-4-funcao-que-le-um-inteiro-e-retorna","title":"8. Exemplo 4 \u2014 Fun\u00e7\u00e3o que l\u00ea um inteiro e retorna","text":"<p>A syscall 5 (<code>read_int</code>) l\u00ea um inteiro do teclado e coloca o resultado em <code>a0</code>.</p>"},{"location":"mod7/#funcao_2","title":"Fun\u00e7\u00e3o","text":"<pre><code>ler_inteiro:\n    li a7, 5          # 5 = read_int\n    ecall             # a0 recebe o valor digitado\n    ret\n</code></pre>"},{"location":"mod7/#chamada_2","title":"Chamada","text":"<pre><code>jal ra, ler_inteiro   # ao voltar, a0 cont\u00e9m o n\u00famero lido\nmv t0, a0             # guarda o valor em t0, se quiser preservar\n</code></pre>"},{"location":"mod7/#9-exemplo-5-mini-programa-com-varias-funcoes","title":"9. Exemplo 5 \u2014 Mini-programa com v\u00e1rias fun\u00e7\u00f5es","text":"<p>Objetivo:</p> <ol> <li>Ler dois n\u00fameros do usu\u00e1rio</li> <li>Somar com uma fun\u00e7\u00e3o <code>soma</code></li> <li>Imprimir o resultado com <code>imprime_int</code></li> </ol>"},{"location":"mod7/#codigo-completo_1","title":"C\u00f3digo completo","text":"<pre><code>.data\nmsg1: .asciz \"Primeiro: \"\nmsg2: .asciz \"Segundo: \"\nmsgR: .asciz \"Resultado: \"\n\n.text\n.globl main\n\nmain:\n    # ---- Ler primeiro n\u00famero ----\n    la a0, msg1\n    li a7, 4              # print_string\n    ecall\n\n    jal ra, ler_int       # retorna em a0\n    mv t0, a0             # t0 = primeiro n\u00famero\n\n    # ---- Ler segundo n\u00famero ----\n    la a0, msg2\n    li a7, 4\n    ecall\n\n    jal ra, ler_int\n    mv t1, a0             # t1 = segundo n\u00famero\n\n    # ---- Somar usando fun\u00e7\u00e3o ----\n    mv a0, t0\n    mv a1, t1\n    jal ra, soma          # a0 = t0 + t1\n    mv t2, a0             # guarda resultado em t2\n\n    # ---- Imprimir resultado ----\n    la a0, msgR\n    li a7, 4              # print_string\n    ecall\n\n    mv a0, t2\n    jal ra, imprime_int   # imprime valor de t2\n\n    li a7, 93             # exit2\n    ecall\n\n\n# -------- Fun\u00e7\u00f5es --------\n\nler_int:\n    li a7, 5              # read_int\n    ecall                 # a0 = valor lido\n    ret\n\nsoma:\n    add a0, a0, a1        # a0 = a0 + a1\n    ret\n\nimprime_int:\n    li a7, 1              # print_int\n    ecall\n    ret\n</code></pre>"},{"location":"mod7/#10-checklist-o-que-voce-domina-agora","title":"10. Checklist: o que voc\u00ea domina agora","text":"<p>Voc\u00ea j\u00e1 sabe:</p> <ul> <li>que uma fun\u00e7\u00e3o \u00e9 um r\u00f3tulo + c\u00f3digo + retorno</li> <li>como <code>jal</code> chama fun\u00e7\u00f5es e grava o endere\u00e7o de retorno em <code>ra</code></li> <li>o papel de <code>ra</code> (return address)</li> <li>como passar argumentos em <code>a0\u2013a7</code></li> <li>como receber o resultado em <code>a0</code></li> <li> <p>como escrever fun\u00e7\u00f5es modulares para:</p> </li> <li> <p>ler inteiros</p> </li> <li>somar</li> <li>imprimir resultados</li> </ul>"},{"location":"mod8/","title":"M\u00f3dulo 8 \u2014 Pilha, Stack Frame e Fun\u00e7\u00f5es Aninhadas no RISC-V (RV32I)","text":"<p>A partir deste m\u00f3dulo, voc\u00ea passa a escrever fun\u00e7\u00f5es reais no estilo RISC-V profissional: com stack frame, preserva\u00e7\u00e3o de registradores e chamadas aninhadas \u2014 tudo dentro das regras da ABI.</p>"},{"location":"mod8/#1-o-que-e-a-pilha-stack","title":"1. O que \u00e9 a pilha (stack)?","text":"<p>A pilha \u00e9 uma regi\u00e3o de mem\u00f3ria usada pelo programa para armazenar:</p> <ul> <li>vari\u00e1veis locais</li> <li>valores tempor\u00e1rios</li> <li>registradores que precisam ser preservados</li> <li>endere\u00e7os de retorno</li> <li>frames de fun\u00e7\u00f5es aninhadas</li> </ul> <p>Ela funciona em estilo LIFO (Last In, First Out): o \u00faltimo valor armazenado \u00e9 o primeiro a ser retirado.</p> <p>Importante: no RISC-V, a pilha cresce para endere\u00e7os menores. Ou seja: empilhar diminui o valor de <code>sp</code>.</p>"},{"location":"mod8/#2-o-registrador-sp-stack-pointer","title":"2. O registrador <code>sp</code> (stack pointer)","text":"<p><code>sp</code> (stack pointer) \u00e9 o registrador que aponta para o topo da pilha.</p> <p>Para empilhar (push) algo:</p> <pre><code>addi sp, sp, -4      # reserva 4 bytes\nsw t0, 0(sp)         # coloca t0 no topo da pilha\n</code></pre> <p>Para desempilhar (pop):</p> <pre><code>lw t0, 0(sp)         # recupera valor\naddi sp, sp, 4       # libera espa\u00e7o\n</code></pre>"},{"location":"mod8/#3-por-que-a-pilha-e-necessaria","title":"3. Por que a pilha \u00e9 necess\u00e1ria?","text":"<ol> <li> <p>Para preservar registradores salvos (<code>s0\u2013s11</code>)    Se uma fun\u00e7\u00e3o mexer neles, precisa restaurar depois.</p> </li> <li> <p>Para guardar o endere\u00e7o de retorno (<code>ra</code>)    Toda fun\u00e7\u00e3o que chama outra precisa salvar <code>ra</code>.</p> </li> <li> <p>Para manter vari\u00e1veis locais</p> </li> <li> <p>Para chamadas aninhadas e recursivas    Cada chamada precisa de seu pr\u00f3prio contexto independente.</p> </li> </ol> <p>Tudo isso \u00e9 encapsulado em um stack frame.</p>"},{"location":"mod8/#4-o-que-e-um-stack-frame","title":"4. O que \u00e9 um Stack Frame?","text":"<p>\u00c9 o bloco de mem\u00f3ria reservado por cada fun\u00e7\u00e3o na pilha.</p> <p>Layout t\u00edpico:</p> <pre><code>+----------------------+\n| argumentos extras    |\n+----------------------+\n| valor antigo de s0   |  &lt;- salvo pela fun\u00e7\u00e3o\n+----------------------+\n| valor antigo de ra   |  &lt;- endere\u00e7o de retorno salvo\n+----------------------+\n| vari\u00e1veis locais     |\n+----------------------+\nsp -&gt; topo ap\u00f3s reserva\n</code></pre> <p>Cada fun\u00e7\u00e3o tem seu pr\u00f3prio frame, permitindo chamadas aninhadas.</p>"},{"location":"mod8/#5-regra-essencial-da-abi-do-risc-v","title":"5. Regra essencial da ABI do RISC-V","text":"<p>Primeira ocorr\u00eancia de \u201cABI\u201d: Application Binary Interface \u2014 padr\u00e3o que define como fun\u00e7\u00f5es devem se comportar.</p>"},{"location":"mod8/#toda-funcao-deve","title":"Toda fun\u00e7\u00e3o deve:","text":"<ol> <li> <p>Salvar na pilha:</p> </li> <li> <p><code>ra</code> se for chamar outra fun\u00e7\u00e3o</p> </li> <li> <p>todos os <code>sX</code> que pretende modificar</p> </li> <li> <p>Restaurar na ordem inversa antes do <code>ret</code>.</p> </li> </ol>"},{"location":"mod8/#6-exemplo-1-salvando-e-restaurando-ra","title":"6. Exemplo 1 \u2014 Salvando e restaurando <code>ra</code>","text":"<p>Qualquer fun\u00e7\u00e3o que chama outra deve salvar seu endere\u00e7o de retorno.</p> <pre><code>funcA:\n    addi sp, sp, -4       # reserva espa\u00e7o\n    sw ra, 0(sp)          # salva ra\n\n    jal ra, funcB         # chama B\n\n    lw ra, 0(sp)          # restaura endere\u00e7o de retorno\n    addi sp, sp, 4        # libera a pilha\n    ret\n\nfuncB:\n    ret\n</code></pre>"},{"location":"mod8/#7-exemplo-2-preservando-registradores-salvos-s0-s1","title":"7. Exemplo 2 \u2014 Preservando registradores salvos (<code>s0</code>, <code>s1</code>, \u2026)","text":"<p>Registradores <code>s0\u2013s11</code> s\u00e3o \u201csalvos\u201d: se uma fun\u00e7\u00e3o modificar, ela deve restaurar.</p> <pre><code>funcao:\n    addi sp, sp, -8       # espa\u00e7o para ra e s0\n    sw ra, 4(sp)          # salva ra\n    sw s0, 0(sp)          # salva s0\n\n    li s0, 123            # usa s0 como vari\u00e1vel local\n\n    lw s0, 0(sp)          # restaura s0\n    lw ra, 4(sp)          # restaura ra\n    addi sp, sp, 8\n    ret\n</code></pre>"},{"location":"mod8/#8-exemplo-3-variavel-local-na-pilha","title":"8. Exemplo 3 \u2014 Vari\u00e1vel local na pilha","text":"<p>Vamos criar uma fun\u00e7\u00e3o que calcula <code>n + 5</code> usando vari\u00e1vel local.</p> <pre><code>add5:\n    addi sp, sp, -4\n    sw s0, 0(sp)          # salva s0\n\n    mv s0, a0             # s0 = n\n    addi a0, s0, 5        # a0 = n + 5\n\n    lw s0, 0(sp)          # restaura s0\n    addi sp, sp, 4\n    ret\n</code></pre> <p>Chamada:</p> <pre><code>li a0, 20\njal ra, add5     # a0 = 25\n</code></pre>"},{"location":"mod8/#9-exemplo-4-funcoes-aninhadas-com-stack-frame-completo","title":"9. Exemplo 4 \u2014 Fun\u00e7\u00f5es aninhadas com stack frame completo","text":"<p>Fluxo:</p> <pre><code>main \u2192 funcA \u2192 funcB\n</code></pre> <p>Cada uma com seu frame.</p> <pre><code>.text\n.globl main\n\nmain:\n    jal ra, funcA\n    li a7, 93\n    ecall\n\nfuncA:\n    addi sp, sp, -8\n    sw ra, 4(sp)\n    sw s0, 0(sp)\n\n    li s0, 50\n    mv a0, s0\n    jal ra, funcB\n\n    lw s0, 0(sp)\n    lw ra, 4(sp)\n    addi sp, sp, 8\n    ret\n\nfuncB:\n    addi a0, a0, 10     # retorna n + 10\n    ret\n</code></pre>"},{"location":"mod8/#10-exemplo-5-funcao-recursiva-simples","title":"10. Exemplo 5 \u2014 Fun\u00e7\u00e3o recursiva simples","text":"<p>Vamos calcular:</p> <pre><code>f(n) = n + f(n \u2212 1)\nf(0) = 0\n</code></pre> <pre><code>soma_rec:\n    addi sp, sp, -8\n    sw ra, 4(sp)\n    sw s0, 0(sp)\n\n    mv s0, a0                # s0 = n\n    beq s0, x0, caso_base    # se n == 0\n\n    addi a0, s0, -1\n    jal ra, soma_rec         # chamada recursiva\n\n    add a0, a0, s0           # retorna f(n-1)+n\n    j fim\n\ncaso_base:\n    li a0, 0                 # f(0) = 0\n\nfim:\n    lw s0, 0(sp)\n    lw ra, 4(sp)\n    addi sp, sp, 8\n    ret\n</code></pre>"}]}