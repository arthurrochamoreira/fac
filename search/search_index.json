{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#fac","title":"FAC","text":"<p>Documenta\u00e7\u00e3o pessoal sobre Fundamentos de Arquitetura de Computadores, desenvolvida como apoio aos estudos da disciplina cursada na gradua\u00e7\u00e3o em Engenharia de Software.</p>"},{"location":"mod1/","title":"Modulo 1 - Introdu\u00e7\u00e3o","text":""},{"location":"mod1/#1-o-que-e-risc-v","title":"1. O que \u00e9 RISC-V?","text":"<p>RISC-V \u00e9 uma arquitetura de conjunto de instru\u00e7\u00f5es (ISA \u2014 Instruction Set Architecture). Uma ISA \u00e9 o \u201cvocabul\u00e1rio\u201d que o processador entende: as opera\u00e7\u00f5es b\u00e1sicas que ele sabe executar.</p> <ul> <li>RISC (Reduced Instruction Set Computer) = arquitetura com poucas instru\u00e7\u00f5es, simples e r\u00e1pidas.</li> <li>V = quinta gera\u00e7\u00e3o dessa fam\u00edlia RISC.</li> <li>RV32I = vers\u00e3o de 32 bits (32 = largura dos registradores) com o conjunto b\u00e1sico de instru\u00e7\u00f5es inteiras (I = Integer).</li> </ul> <p>Um processador RISC-V s\u00f3 entende opera\u00e7\u00f5es fundamentais, como:</p> <ul> <li>mover valores entre registradores (pequenas mem\u00f3rias internas do processador)</li> <li>ler/escrever na mem\u00f3ria</li> <li>fazer opera\u00e7\u00f5es aritm\u00e9ticas</li> <li>saltar para outro ponto do c\u00f3digo</li> </ul>"},{"location":"mod1/#observacao-importante","title":"Observa\u00e7\u00e3o importante","text":"<p>Os registradores possuem apelidos educativos (<code>a0</code>, <code>t0</code>, <code>s0</code> etc.), mas internamente eles continuam sendo <code>x0</code>, <code>x1</code>, \u2026, <code>x31</code>. Por exemplo:</p> <ul> <li><code>a0</code> = <code>x10</code></li> <li><code>a7</code> = <code>x17</code></li> <li><code>t0</code> = <code>x5</code></li> </ul> <p>Isso aparece no painel \u201cRegisters\u201d do RARS.</p>"},{"location":"mod1/#2-o-que-e-o-rars","title":"2. O que \u00e9 o RARS?","text":"<p>O RARS (RISC-V Assembler and Runtime Simulator) \u00e9 um simulador, ou seja:</p> <p>Um programa que imita um processador RISC-V para permitir que voc\u00ea execute c\u00f3digo sem ter o hardware real.</p> <p>Ele funciona assim:</p> <ol> <li>Voc\u00ea escreve um arquivo <code>.asm</code>    (arquivo contendo c\u00f3digo em assembly, a linguagem textual da ISA).</li> <li>O RARS monta o c\u00f3digo    (assembler = traduz para instru\u00e7\u00f5es bin\u00e1rias reais).</li> <li>O RARS executa e mostra o que acontece nos registradores e na mem\u00f3ria.</li> </ol> <p>Al\u00e9m disso, o RARS oferece syscalls (system calls): servi\u00e7os prontos como imprimir texto ou ler n\u00fameros do usu\u00e1rio.</p>"},{"location":"mod1/#3-registradores-sua-caixa-de-ferramentas","title":"3. Registradores: sua caixa de ferramentas","text":"<p>Um registrador \u00e9 uma pequena \u00e1rea de armazenamento dentro do processador. \u00c9 muito mais r\u00e1pido acessar registradores do que acessar mem\u00f3ria.</p> <p>O RISC-V possui 32 registradores inteiros, de <code>x0</code> a <code>x31</code>, cada um com um apelido:</p> Nome Uso <code>x0</code> sempre cont\u00e9m o valor 0 <code>a0\u2013a7</code> argumentos de fun\u00e7\u00f5es e syscalls (argument registers) <code>t0\u2013t6</code> tempor\u00e1rios (temporary registers) <code>s0\u2013s11</code> vari\u00e1veis preservadas (saved registers) <code>sp</code> ponteiro da pilha (stack pointer) <code>ra</code> endere\u00e7o de retorno (return address) <p>Para o Hello World utilizamos principalmente:</p> <ul> <li><code>a0</code> \u2014 registrador que cont\u00e9m o argumento da syscall</li> <li><code>a7</code> \u2014 registrador que cont\u00e9m o c\u00f3digo da syscall</li> </ul>"},{"location":"mod1/#4-formato-basico-das-instrucoes","title":"4. Formato b\u00e1sico das instru\u00e7\u00f5es","text":"<p>Uma instru\u00e7\u00e3o \u00e9 um comando da ISA. No RV32I, muitos comandos seguem o formato:</p> <pre><code>instru\u00e7\u00e3o destino, fonte1, fonte2\n</code></pre> <p>Exemplos:</p> <pre><code>add t0, t1, t2   # add = soma: t0 recebe t1 + t2\nli a0, 5         # li = load immediate: coloca 5 dentro de a0\nla a0, msg       # la = load address: carrega o endere\u00e7o do r\u00f3tulo msg\nlw t1, 0(t0)     # lw = load word: l\u00ea 4 bytes da mem\u00f3ria no endere\u00e7o t0\n</code></pre>"},{"location":"mod1/#nota-tecnica","title":"Nota t\u00e9cnica","text":"<p>No RISC-V, todos os endere\u00e7os se referem a 1 byte (mem\u00f3ria byte-addressable). Um <code>lw</code> l\u00ea 4 bytes a partir daquele endere\u00e7o.</p>"},{"location":"mod1/#5-pseudo-instrucoes","title":"5. Pseudo-instru\u00e7\u00f5es","text":"<p>O montador do RARS fornece pseudo-instru\u00e7\u00f5es, que n\u00e3o existem no hardware real, mas tornam o c\u00f3digo mais f\u00e1cil de escrever:</p> <ul> <li><code>li</code> \u2014 load immediate: carrega um valor imediato</li> <li><code>la</code> \u2014 load address: carrega o endere\u00e7o de um r\u00f3tulo</li> <li><code>mv</code> \u2014 move: copia o valor de um registrador para outro</li> </ul> <p>O montador converte essas pseudo-instru\u00e7\u00f5es em instru\u00e7\u00f5es reais RV32I durante a montagem.</p>"},{"location":"mod1/#6-sessoes-do-programa","title":"6. Sess\u00f5es do programa","text":"<p>Um arquivo <code>.asm</code> \u00e9 dividido em sess\u00f5es:</p>"},{"location":"mod1/#data-dados-estaticos-na-memoria","title":"<code>.data</code> \u2014 dados est\u00e1ticos na mem\u00f3ria","text":"<pre><code>.data\nmsg: .asciz \"Hello, World!\\n\"\n</code></pre> <p><code>.asciz</code> define uma string terminada em byte zero (<code>\\0</code>). Isso \u00e9 importante porque a syscall 4 (print_string) espera exatamente esse formato.</p>"},{"location":"mod1/#text-codigo-executavel","title":"<code>.text</code> \u2014 c\u00f3digo execut\u00e1vel","text":"<pre><code>.text\n.globl main     # .globl = global: torna 'main' o ponto de entrada\n</code></pre> <p>A execu\u00e7\u00e3o come\u00e7a no r\u00f3tulo <code>main:</code>.</p>"},{"location":"mod1/#7-como-o-rars-imprime-syscalls","title":"7. Como o RARS imprime (syscalls)","text":"<p>Uma syscall (system call) \u00e9 uma chamada ao sistema operacional do simulador para executar a\u00e7\u00f5es prontas, como imprimir ou ler entradas.</p>"},{"location":"mod1/#para-chamar-uma-syscall","title":"Para chamar uma syscall:","text":"<ol> <li>Coloque o c\u00f3digo da syscall em <code>a7</code></li> <li>Coloque o argumento em <code>a0</code></li> <li>Execute <code>ecall</code> (environment call)</li> </ol> <p>Resumo perfeito:</p> <p><code>a7</code> escolhe o servi\u00e7o, <code>a0</code> fornece o dado, <code>ecall</code> executa.</p>"},{"location":"mod1/#syscalls-usadas-no-hello-world","title":"Syscalls usadas no Hello World:","text":"C\u00f3digo Fun\u00e7\u00e3o <code>4</code> imprimir string (print_string) <code>10</code> encerrar o programa (exit2) <p>Exemplo:</p> <pre><code>la a0, msg     # a0 = endere\u00e7o da string\nli a7, 4       # a7 = c\u00f3digo de print_string\necall          # dispara a syscall\n</code></pre>"},{"location":"mod1/#8-montando-tudo-hello-world","title":"8. Montando tudo: Hello World","text":"<pre><code>    .data                           # sess\u00e3o de dados\nmsg: .asciz \"Hello, World!\\n\"       # string terminada em zero\n\n    .text                           # sess\u00e3o de c\u00f3digo\n    .globl main                     # torna 'main' vis\u00edvel\n\nmain:\n    la a0, msg                      # carrega o endere\u00e7o da string msg em a0\n    li a7, 4                        # syscall 4 = print_string\n    ecall                           # imprime\n\n    li a0, 0                        # c\u00f3digo de sa\u00edda (0 = sucesso)\n    li a7, 10                       # syscall 93 = exit2\n    ecall                           # encerra\n</code></pre>"},{"location":"modulos/modulo%201/mod1/","title":"M\u00f3dulo 1 \u2014 Introdu\u00e7\u00e3o ao RISC-V","text":"<p>Este m\u00f3dulo apresenta a base conceitual necess\u00e1ria para entender como funciona um programa em assembly RISC-V: o que \u00e9 uma ISA, por que come\u00e7amos pelo conjunto RV32I, como funciona o simulador RARS e como o processador enxerga mem\u00f3ria, dados e instru\u00e7\u00f5es.</p>"},{"location":"modulos/modulo%201/mod1/#1-o-que-e-risc-v","title":"1. O que \u00e9 RISC-V?","text":"<p>RISC-V \u00e9 uma arquitetura de conjunto de instru\u00e7\u00f5es (ISA \u2014 Instruction Set Architecture). Uma ISA \u00e9 o conjunto de comandos que o processador entende no n\u00edvel mais baixo, como:</p> <ul> <li>somar valores</li> <li>carregar dados da mem\u00f3ria</li> <li>desviar para outro ponto do c\u00f3digo</li> <li>comparar n\u00fameros</li> <li>executar opera\u00e7\u00f5es l\u00f3gicas</li> </ul> <p>O termo RISC significa Reduced Instruction Set Computer: uma filosofia de projeto que preza por instru\u00e7\u00f5es simples, diretas e r\u00e1pidas.</p> <p>O \u201cV\u201d indica que esta \u00e9 a quinta gera\u00e7\u00e3o da fam\u00edlia RISC dessa linha de pesquisa.</p>"},{"location":"modulos/modulo%201/mod1/#2-o-que-e-rv32i-e-por-que-comecamos-por-ele","title":"2. O que \u00e9 RV32I e por que come\u00e7amos por ele","text":"<p>A sigla RV32I significa:</p> <ul> <li>RV \u2014 RISC-V</li> <li>32 \u2014 registradores e endere\u00e7os possuem 32 bits</li> <li>I \u2014 conjunto b\u00e1sico de instru\u00e7\u00f5es inteiras (Integer)</li> </ul> <p>O RV32I \u00e9:</p> <ul> <li>o menor conjunto completo e funcional da ISA</li> <li>suficiente para aprender todos os fundamentos de assembly</li> <li>compat\u00edvel com praticamente qualquer simulador</li> <li>limpo, simples e ideal para iniciantes</li> </ul> <p>Tudo que voc\u00ea aprender aqui funciona em qualquer implementa\u00e7\u00e3o real de RISC-V, incluindo microcontroladores, processadores embarcados e sistemas operacionais reais.</p>"},{"location":"modulos/modulo%201/mod1/#3-o-que-e-um-simulador-rars","title":"3. O que \u00e9 um simulador (RARS)","text":"<p>Para programar em RISC-V sem comprar um chip f\u00edsico, usamos o RARS (RISC-V Assembler and Runtime Simulator).</p> <p>O RARS permite:</p>"},{"location":"modulos/modulo%201/mod1/#31-montar-o-codigo","title":"3.1 Montar o c\u00f3digo","text":"<p>O montador (assembler) converte o c\u00f3digo <code>.asm</code> em instru\u00e7\u00f5es bin\u00e1rias reais da ISA.</p>"},{"location":"modulos/modulo%201/mod1/#32-executar-o-programa","title":"3.2 Executar o programa","text":"<p>O simulador roda o bin\u00e1rio e mostra o fluxo do programa.</p>"},{"location":"modulos/modulo%201/mod1/#33-inspecionar-registradores-e-memoria","title":"3.3 Inspecionar registradores e mem\u00f3ria","text":"<p>\u00c9 poss\u00edvel acompanhar:</p> <ul> <li>valores nos registradores (<code>a0</code>, <code>t0</code>, <code>s0</code>\u2026)</li> <li>conte\u00fado da mem\u00f3ria em v\u00e1rias representa\u00e7\u00f5es</li> <li>execu\u00e7\u00e3o passo a passo (modo step)</li> </ul>"},{"location":"modulos/modulo%201/mod1/#4-estrutura-geral-de-um-programa-asm","title":"4. Estrutura geral de um programa <code>.asm</code>","text":"<p>Um programa t\u00edpico possui duas sess\u00f5es principais:</p>"},{"location":"modulos/modulo%201/mod1/#41-sessao-data-data-section","title":"4.1 Sess\u00e3o <code>.data</code> (data section)","text":"<p>Armazena dados est\u00e1ticos, como n\u00fameros, vetores e strings.</p> <p>Exemplo:</p> <pre><code>.data\nmsg: .asciz \"Hello!\\n\"\nx:   .word 42\n</code></pre>"},{"location":"modulos/modulo%201/mod1/#42-sessao-text-text-section","title":"4.2 Sess\u00e3o <code>.text</code> (text section)","text":"<p>Armazena o c\u00f3digo execut\u00e1vel.</p> <p>Exemplo:</p> <pre><code>.text\n.globl main           # .globl (global): define o ponto de entrada\n\nmain:\n    li a0, 42         # li = load immediate: coloca 42 em a0\n    li a7, 1          # c\u00f3digo da syscall print_int\n    ecall             # ecall = environment call\n</code></pre>"},{"location":"modulos/modulo%201/mod1/#43-labels","title":"4.3 Labels","text":"<p>Um label (r\u00f3tulo) \u00e9 um nome que representa um endere\u00e7o na mem\u00f3ria.</p> <p>Exemplo:</p> <pre><code>msg:\n</code></pre> <p>Esse nome representa o endere\u00e7o do primeiro byte da string <code>\"Hello!\\n\"</code>.</p> <p>Labels funcionam como ponteiros, iguais aos usados em C.</p>"},{"location":"modulos/modulo%201/mod1/#5-como-o-processador-enxerga-dados-e-instrucoes","title":"5. Como o processador enxerga dados e instru\u00e7\u00f5es","text":"<p>Para o processador, tudo \u00e9 apenas mem\u00f3ria.</p> <p>Ele n\u00e3o distingue \u201ctexto\u201d, \u201cn\u00fameros\u201d, \u201cstrings\u201d, \u201cinstru\u00e7\u00f5es\u201d ou \u201cvari\u00e1veis\u201d de forma sem\u00e2ntica.</p>"},{"location":"modulos/modulo%201/mod1/#a-memoria-e-uma-grande-linha-de-bytes","title":"A mem\u00f3ria \u00e9 uma grande linha de bytes:","text":"<pre><code>[00][04][3F][10][7A][FF][00]...\n</code></pre> <p>O processador interpreta esses bytes de acordo com o contexto:</p> <ul> <li>Em <code>.text</code>: interpreta os bytes como instru\u00e7\u00f5es.</li> <li>Em <code>.data</code>: interpreta como dados (palavras, strings, vetores etc.).</li> </ul> <p>Quando voc\u00ea escreve:</p> <pre><code>add t0, t1, t2\n</code></pre> <p>Isso \u00e9 convertido em 32 bits que o hardware interpreta como:</p> <p>\"some o registrador t1 com o registrador t2 e coloque o resultado em t0\".</p> <p>Quando voc\u00ea escreve:</p> <pre><code>.word 42\n</code></pre> <p>Isso apenas grava 42 em bin\u00e1rio na mem\u00f3ria \u2014 n\u00e3o h\u00e1 \u201ctipo inteiro\u201d, apenas bits.</p> <p>O comportamento \u00e9 definido pela instru\u00e7\u00e3o que l\u00ea esses bits.</p>"},{"location":"modulos/modulo%201/mod1/#6-como-o-processador-executa-um-programa","title":"6. Como o processador executa um programa","text":"<p>O processador possui:</p> <ul> <li>PC (program counter):   registrador que aponta para a pr\u00f3xima instru\u00e7\u00e3o a ser executada.</li> </ul> <p>O ciclo b\u00e1sico \u00e9:</p> <ol> <li>Ler a instru\u00e7\u00e3o apontada por PC</li> <li>Executar a instru\u00e7\u00e3o</li> <li>Avan\u00e7ar o PC (ou fazer um salto no caso de branches)</li> <li>Repetir</li> </ol> <p>Esse ciclo acontece milh\u00f5es de vezes por segundo.</p>"},{"location":"modulos/modulo%202/mod2/","title":"M\u00f3dulo 2 \u2014 Sess\u00f5es","text":"<p>Neste m\u00f3dulo voc\u00ea aprende:</p> <ul> <li>para que serve a sess\u00e3o <code>.data</code></li> <li>como funcionam labels (r\u00f3tulos) como ponteiros</li> <li>como declarar strings com <code>.string</code> e <code>.asciz</code></li> <li>como funciona a sess\u00e3o <code>.text</code></li> <li>como definir o ponto de entrada (<code>main:</code>)</li> <li>como carregar endere\u00e7os com <code>la</code> (load address)</li> </ul>"},{"location":"modulos/modulo%202/mod2/#1-a-sessao-data-onde-ficam-os-dados-do-programa","title":"1. A sess\u00e3o <code>.data</code> \u2014 onde ficam os dados do programa","text":"<p>A diretiva <code>.data</code> (data section) indica ao montador que tudo abaixo dela deve ser colocado na \u00e1rea de dados do programa: uma regi\u00e3o de mem\u00f3ria reservada para valores est\u00e1ticos, como:</p> <ul> <li>n\u00fameros</li> <li>vetores</li> <li>constantes</li> <li>strings</li> </ul> <p>Exemplo simples:</p> <pre><code>.data\nnumero: .word 42\n</code></pre> <p>Aqui:</p> <ul> <li><code>.word</code> aloca 4 bytes</li> <li><code>numero</code> \u00e9 um label (r\u00f3tulo) representando o endere\u00e7o onde o valor 42 est\u00e1 guardado</li> </ul>"},{"location":"modulos/modulo%202/mod2/#2-labels-label-como-ponteiros","title":"2. Labels (label:) como ponteiros","text":"<p>Um label (r\u00f3tulo) \u00e9 apenas um nome associado a um endere\u00e7o na mem\u00f3ria.</p> <p>Ele funciona como um ponteiro em C:</p> <pre><code>label  -----&gt;  endere\u00e7o onde o dado est\u00e1 colocado\n</code></pre> <p>Exemplo:</p> <pre><code>msg: .string \"Ol\u00e1\"\n</code></pre> <p>O label <code>msg</code> aponta para o primeiro byte da string.</p> <p>O label n\u00e3o cont\u00e9m o valor. O label cont\u00e9m o endere\u00e7o onde o valor est\u00e1.</p> <p>Isso \u00e9 fundamental, porque instru\u00e7\u00f5es como <code>la</code> (load address) funcionam exatamente assim:</p> <pre><code>la a0, msg     # a0 recebe o endere\u00e7o da string 'msg'\n</code></pre>"},{"location":"modulos/modulo%202/mod2/#3-declarando-strings-string-e-asciz","title":"3. Declarando strings: <code>.string</code> e <code>.asciz</code>","text":"<p>Existem duas diretivas para declarar strings:</p>"},{"location":"modulos/modulo%202/mod2/#string-texto","title":"<code>.string \"texto\"</code>","text":"<p>A diretiva <code>.string</code> grava a sequ\u00eancia de caracteres sem byte nulo no final.</p> <p>Exemplo:</p> <pre><code>msg: .string \"Hello\"\n</code></pre> <p>Mem\u00f3ria:</p> <pre><code>48 65 6C 6C 6F   (sem 00)\n H  e  l  l  o\n</code></pre>"},{"location":"modulos/modulo%202/mod2/#asciz-texto","title":"<code>.asciz \"texto\"</code>","text":"<p>A diretiva <code>.asciz</code> (ASCII zero-terminated) grava a string seguida de um byte zero, exatamente como em C.</p> <p>Exemplo:</p> <pre><code>msg: .asciz \"Hello\"\n</code></pre> <p>Mem\u00f3ria:</p> <pre><code>48 65 6C 6C 6F 00\n H  e  l  l  o \\0\n</code></pre> <p>O byte zero final (<code>\\0</code>) \u00e9 obrigat\u00f3rio para syscalls como print_string no simulador RARS (RISC-V Assembler and Runtime Simulator).</p>"},{"location":"modulos/modulo%202/mod2/#4-a-sessao-text-onde-ficam-as-instrucoes","title":"4. A sess\u00e3o <code>.text</code> \u2014 onde ficam as instru\u00e7\u00f5es","text":"<p>A diretiva <code>.text</code> (code section) marca o in\u00edcio do c\u00f3digo execut\u00e1vel: todas as instru\u00e7\u00f5es do programa.</p> <p>Exemplo:</p> <pre><code>.text\n</code></pre> <p>Dentro dela ficam comandos como:</p> <ul> <li><code>li</code> (load immediate)</li> <li><code>la</code> (load address)</li> <li><code>lw</code> (load word)</li> <li><code>sw</code> (store word)</li> <li><code>add</code>, <code>sub</code></li> <li><code>ecall</code> (environment call)</li> </ul>"},{"location":"modulos/modulo%202/mod2/#5-o-ponto-de-entrada-main","title":"5. O ponto de entrada: <code>main:</code>","text":"<p>O RARS procura por um r\u00f3tulo espec\u00edfico para come\u00e7ar a execu\u00e7\u00e3o:</p> <pre><code>main:\n</code></pre> <p>Esse \u00e9 o entry point (ponto de entrada).</p> <p>Exemplo completo:</p> <pre><code>.text\n.globl main     # .globl (global): torna 'main' vis\u00edvel como ponto de entrada\n\nmain:\n    li a0, 5\n    li a7, 1\n    ecall\n</code></pre> <p>A diretiva <code>.globl</code> (global symbol) informa ao montador que este r\u00f3tulo deve ser acess\u00edvel como s\u00edmbolo externo \u2014 \u00e9 assim que o RARS sabe que <code>main</code> \u00e9 seu ponto de in\u00edcio.</p>"},{"location":"modulos/modulo%202/mod2/#6-carregar-enderecos-com-la-load-address","title":"6. Carregar endere\u00e7os com <code>la</code> (load address)","text":"<p>A pseudo-instru\u00e7\u00e3o <code>la</code> (load address) carrega o endere\u00e7o associado a um label em um registrador.</p> <p>\u00c9 uma pseudo-instru\u00e7\u00e3o, ou seja, n\u00e3o existe diretamente no hardware RV32I; o montador traduz <code>la</code> em uma sequ\u00eancia de instru\u00e7\u00f5es reais (<code>lui</code> + <code>addi</code>).</p> <p>Exemplo:</p> <pre><code>la a0, msg\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <p>Coloque no registrador <code>a0</code> o endere\u00e7o onde a string <code>msg</code> est\u00e1 armazenada.</p> <p>Isso \u00e9 fundamental, porque syscalls usam endere\u00e7os, n\u00e3o labels.</p>"},{"location":"modulos/modulo%202/mod2/#7-exemplo-completo-reunindo-tudo","title":"7. Exemplo completo reunindo tudo","text":"<pre><code>.data\nmsg: .asciz \"Ol\u00e1, RISC-V!\\n\"   # string terminada em 0\n\nnumero: .word 123              # valor armazenado em 4 bytes\n\n.text\n.globl main\n\nmain:\n    # Imprimir string\n    la a0, msg                 # load address: a0 recebe endere\u00e7o da string\n    li a7, 4                   # print_string\n    ecall\n\n    # Imprimir n\u00famero\n    lw a0, numero              # load word: a0 recebe valor em 'numero'\n    li a7, 1                   # print_int\n    ecall\n\n    # Encerrar\n    li a7, 93                  # exit2\n    ecall\n</code></pre>"},{"location":"modulos/modulo%203/mod3/","title":"M\u00f3dulo 3 \u2014 Registradores do RV32I","text":"<p>O conjunto RV32I possui 32 registradores inteiros, cada um com um papel definido pela ABI (Application Binary Interface). A ABI determina como fun\u00e7\u00f5es recebem argumentos, como retornam valores, quais registradores podem ser sobrescritos e quais devem ser preservados.</p> <p>Este m\u00f3dulo apresenta:</p> <ul> <li>as categorias de registradores (<code>a*</code>, <code>t*</code>, <code>s*</code>, <code>zero</code>)</li> <li>como funcionam no calling convention (conven\u00e7\u00e3o de chamada)</li> <li>por que usamos <code>a0</code>, <code>a7</code>, <code>t0</code> etc.</li> <li>o que \u00e9 o registrador <code>sp</code> e como ele forma a pilha</li> </ul>"},{"location":"modulos/modulo%203/mod3/#1-visao-geral-por-que-existem-tipos-diferentes-de-registradores","title":"1. Vis\u00e3o geral: por que existem tipos diferentes de registradores?","text":"<p>O RISC-V segue uma regra essencial:</p> <p>Cada registrador tem uma fun\u00e7\u00e3o espec\u00edfica na conven\u00e7\u00e3o de chamada. Isso permite que fun\u00e7\u00f5es cooperem entre si de forma consistente.</p> <p>Assim, todo programa \u2014 do menor ao maior \u2014 funciona com o mesmo protocolo.</p> <p>As categorias s\u00e3o:</p> Categoria Registradores Nome t\u00e9cnico Fun\u00e7\u00e3o principal <code>zero</code> <code>x0</code> registrador zero sempre cont\u00e9m 0 <code>a*</code> <code>a0\u2013a7</code> argument registers argumentos e retorno de fun\u00e7\u00f5es/syscalls <code>t*</code> <code>t0\u2013t6</code> temporary registers valores tempor\u00e1rios (n\u00e3o preservados) <code>s*</code> <code>s0\u2013s11</code> saved registers valores preservados entre chamadas <code>sp</code> <code>x2</code> stack pointer topo da pilha (stack) <code>ra</code> <code>x1</code> return address endere\u00e7o para onde retornar ap\u00f3s <code>jal</code> <p>Vamos detalhar cada categoria.</p>"},{"location":"modulos/modulo%203/mod3/#2-o-registrador-zero-x0","title":"2. O registrador <code>zero</code> (<code>x0</code>)","text":"<p><code>x0</code> \u00e9 um registrador somente leitura que sempre cont\u00e9m o valor 0.</p> <p>Ele \u00e9 \u00fatil para:</p> <ul> <li>compara\u00e7\u00f5es (<code>beq t0, x0, label</code>)</li> <li>gerar valores 0 sem gastar instru\u00e7\u00f5es (<code>addi t0, x0, 0</code>)</li> <li>confirmar igualdade (<code>bne t0, x0, continuar</code>)</li> </ul> <p>Como ele nunca muda, evita erros e economiza espa\u00e7o no c\u00f3digo.</p>"},{"location":"modulos/modulo%203/mod3/#3-registradores-a-argument-registers","title":"3. Registradores <code>a*</code> \u2014 Argument Registers","text":"<p>Os registradores <code>a0\u2013a7</code> s\u00e3o usados para:</p> <ol> <li>Passar argumentos para fun\u00e7\u00f5es</li> <li>Receber argumentos de syscalls</li> <li>Receber valores de retorno</li> </ol>"},{"location":"modulos/modulo%203/mod3/#31-retorno-de-funcao","title":"3.1 Retorno de fun\u00e7\u00e3o","text":"<p>Toda fun\u00e7\u00e3o retorna valores em:</p> <ul> <li><code>a0</code> \u2014 primeiro valor de retorno</li> <li><code>a1</code> \u2014 segundo, se necess\u00e1rio</li> </ul> <p>Exemplo:</p> <pre><code>li a0, 42        # argumento\njal ra, dobro    # chama fun\u00e7\u00e3o\n\n# a0 agora cont\u00e9m o retorno\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#4-registradores-t-temporary-registers","title":"4. Registradores <code>t*</code> \u2014 Temporary Registers","text":"<p>Os registradores <code>t0\u2013t6</code> (temporary registers) s\u00e3o tempor\u00e1rios:</p> <ul> <li>a fun\u00e7\u00e3o pode sobrescrev\u00ea-los livremente</li> <li>n\u00e3o precisam ser preservados na pilha</li> </ul> <p>Use <code>t*</code> para:</p> <ul> <li>contadores</li> <li>vari\u00e1veis tempor\u00e1rias</li> <li>c\u00e1lculos intermedi\u00e1rios</li> <li>ponteiros tempor\u00e1rios</li> <li>la\u00e7os simples</li> </ul> <p>Exemplo t\u00edpico:</p> <pre><code>li t0, 5\naddi t0, t0, 1    # t0 = 6\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#5-registradores-s-saved-registers","title":"5. Registradores <code>s*</code> \u2014 Saved Registers","text":"<p>Registradores <code>s0\u2013s11</code> (saved registers) s\u00e3o usados quando um valor precisa sobreviver a chamadas de fun\u00e7\u00e3o.</p> <p>Regra da ABI:</p> <p>Se uma fun\u00e7\u00e3o modificar um registrador <code>s*</code>, ela \u00e9 obrigada a salv\u00e1-lo na pilha e restaur\u00e1-lo antes de retornar.</p> <p>\u00c9 assim que se cria uma vari\u00e1vel \u201clocal\u201d persistente:</p> <pre><code>addi sp, sp, -4\nsw s0, 0(sp)\n\nli s0, 99      # usa s0 dentro da fun\u00e7\u00e3o\n\nlw s0, 0(sp)\naddi sp, sp, 4\nret\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#6-registrador-sp-stack-pointer","title":"6. Registrador <code>sp</code> \u2014 Stack Pointer","text":"<p><code>sp</code> (stack pointer) aponta para o topo da pilha.</p> <p>A pilha \u00e9 uma regi\u00e3o de mem\u00f3ria com comportamento LIFO (last in, first out).</p>"},{"location":"modulos/modulo%203/mod3/#61-como-a-pilha-cresce","title":"6.1 Como a pilha cresce","text":"<p>A pilha cresce para endere\u00e7os menores:</p> <pre><code>addi sp, sp, -16   # reserva 16 bytes\n</code></pre> <p>E diminui quando liberamos espa\u00e7o:</p> <pre><code>addi sp, sp, 16    # libera espa\u00e7o\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#para-que-serve-a-pilha","title":"Para que serve a pilha?","text":"<ul> <li>armazenar vari\u00e1veis locais</li> <li>guardar registradores <code>s*</code></li> <li>armazenar o endere\u00e7o de retorno (<code>ra</code>) quando fun\u00e7\u00f5es chamam outras</li> <li>suportar recurs\u00e3o</li> </ul>"},{"location":"modulos/modulo%203/mod3/#7-por-que-usamos-a0-a7-t0-no-programa","title":"7. Por que usamos <code>a0</code>, <code>a7</code>, <code>t0</code>\u2026 no programa?","text":"<p>Isso segue a ABI (Application Binary Interface), que define:</p> <ol> <li>Qual registrador carrega argumentos (<code>a0\u2013a7</code>)</li> <li>Qual registrador recebe retorno (<code>a0</code>)</li> <li>Quais registradores s\u00e3o tempor\u00e1rios (<code>t0\u2013t6</code>)</li> <li>Quais s\u00e3o preservados (<code>s0\u2013s11</code>)</li> <li>Qual registrador aponta a pilha (<code>sp</code>)</li> <li>Qual guarda o endere\u00e7o de retorno (<code>ra</code>)</li> </ol>"},{"location":"modulos/modulo%203/mod3/#exemplos-reais","title":"Exemplos reais:","text":""},{"location":"modulos/modulo%203/mod3/#71-syscalls","title":"7.1 Syscalls","text":"<p>A syscall \u00e9 executada quando:</p> <ul> <li><code>a7</code> cont\u00e9m o c\u00f3digo da syscall</li> <li><code>a0</code> cont\u00e9m o argumento</li> </ul> <p>Exemplo:</p> <pre><code>li a0, 123         # argumento\nli a7, 1           # print_int\necall\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#72-funcoes","title":"7.2 Fun\u00e7\u00f5es","text":"<pre><code>li a0, 5\nli a1, 7\njal ra, soma       # soma(5,7)\n\n# a0 cont\u00e9m retorno\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/","title":"M\u00f3dulo 4 \u2014 Instru\u00e7\u00f5es de Imediato (<code>li</code>, <code>addi</code>)","text":"<p>As instru\u00e7\u00f5es de imediato s\u00e3o fundamentais no RISC-V (ISA \u2014 Instruction Set Architecture: conjunto de instru\u00e7\u00f5es que o processador entende), porque permitem trabalhar com valores constantes sem acessar a mem\u00f3ria.</p> <p>Neste m\u00f3dulo voc\u00ea vai ver:</p> <ul> <li>o que \u00e9 um imediato (immediate)</li> <li>como carregar um valor constante direto em um registrador com <code>li</code></li> <li>como somar um registrador com uma constante usando <code>addi</code></li> <li>como aplicar essas instru\u00e7\u00f5es em loops, aritm\u00e9tica e ponteiros</li> </ul>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#1-o-que-e-um-valor-imediato","title":"1. O que \u00e9 um \u201cvalor imediato\u201d?","text":"<p>Um imediato (immediate) \u00e9 um valor constante escrito diretamente na instru\u00e7\u00e3o, e n\u00e3o buscado da mem\u00f3ria.</p> <p>Exemplo conceitual:</p> <pre><code>addi t0, t0, 1     # addi (add immediate): soma o imediato 1 ao valor em t0 e guarda em t0\n</code></pre> <p>Aqui:</p> <ul> <li><code>t0</code> \u00e9 um registrador tempor\u00e1rio (temporary register)</li> <li><code>1</code> \u00e9 o imediato embutido na instru\u00e7\u00e3o</li> </ul> <p>Diferente de:</p> <pre><code>lw t0, 0(t1)       # lw (load word): carrega da mem\u00f3ria\n</code></pre> <p>onde o valor vem da mem\u00f3ria, n\u00e3o est\u00e1 \u201cdentro\u201d da instru\u00e7\u00e3o.</p>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#2-a-pseudo-instrucao-li-load-immediate","title":"2. A pseudo-instru\u00e7\u00e3o <code>li</code> \u2014 load immediate","text":"<p><code>li</code> (load immediate) \u00e9 uma pseudo-instru\u00e7\u00e3o do montador (n\u00e3o existe no hardware real RV32I) que carrega um valor imediato em um registrador.</p> <p>Sintaxe:</p> <pre><code>li rd, imediato\n</code></pre> <p>Significa:</p> <p>Colocar o valor constante <code>imediato</code> dentro do registrador <code>rd</code>.</p> <p>Exemplos:</p> <pre><code>li t0, 10           # li (load immediate): coloca o valor imediato 10 no registrador t0\nli a0, -5           # li (load immediate): coloca -5 em a0\nli s1, 2048         # li (load immediate): coloca 2048 em s1\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#como-o-montador-expande-li","title":"Como o montador expande <code>li</code>","text":"<p>Como <code>li</code> \u00e9 uma pseudo-instru\u00e7\u00e3o, o montador do RARS (RISC-V Assembler and Runtime Simulator) traduz para uma ou mais instru\u00e7\u00f5es reais, por exemplo:</p> <ul> <li>imediatos pequenos \u2192 <code>addi</code></li> <li>imediatos grandes \u2192 combina\u00e7\u00e3o de <code>lui</code> (load upper immediate) + <code>addi</code></li> </ul> <p>Voc\u00ea n\u00e3o precisa se preocupar com isso no come\u00e7o: use <code>li</code> livremente para carregar constantes.</p>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#3-a-instrucao-addi-add-immediate","title":"3. A instru\u00e7\u00e3o <code>addi</code> \u2014 add immediate","text":"<p><code>addi</code> (add immediate) \u00e9 uma instru\u00e7\u00e3o real do conjunto RV32I que soma o conte\u00fado de um registrador com um imediato de 12 bits (intervalo de -2048 at\u00e9 +2047).</p> <p>Sintaxe:</p> <pre><code>addi rd, rs1, imediato\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <p><code>rd = rs1 + imediato</code></p> <p>Exemplos:</p> <pre><code>addi t0, t0, 1      # addi (add immediate): t0 = t0 + 1  (incremento)\naddi t1, t1, -1     # addi (add immediate): t1 = t1 - 1  (decremento)\naddi a0, a0, 10     # addi (add immediate): a0 = a0 + 10\naddi t2, t0, 4      # addi (add immediate): t2 = t0 + 4\n</code></pre> <p>Se o imediato for grande demais para caber em 12 bits, voc\u00ea geralmente usa uma combina\u00e7\u00e3o de <code>li</code>, <code>lui</code> + <code>addi</code> \u2014 mas para a maioria dos exemplos iniciais, <code>addi</code> \u00e9 suficiente.</p>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#4-usos-comuns-de-li-e-addi","title":"4. Usos comuns de <code>li</code> e <code>addi</code>","text":""},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#41-inicializar-variaveis-em-registradores","title":"4.1 Inicializar \u201cvari\u00e1veis\u201d em registradores","text":"<pre><code>li t0, 0            # li (load immediate): inicializa t0 como contador com 0\nli t1, 10           # li (load immediate): define limite 10 em t1\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#42-criar-loops-com-incrementos-e-decrementos","title":"4.2 Criar loops com incrementos e decrementos","text":"<p>Aqui aparece <code>bne</code> (branch if not equal) pela primeira vez:</p> <ul> <li><code>bne rs1, rs2, label</code> desvia para <code>label</code> se <code>rs1 != rs2</code>.</li> </ul> <pre><code>li t0, 5            # t0 come\u00e7a em 5\n\nloop:\n    addi t0, t0, -1 # addi (add immediate): t0 = t0 - 1  (decrementa)\n    bne t0, x0, loop# bne (branch if not equal): se t0 != 0, volta para 'loop'\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#43-manipular-ponteiros-enderecos-em-vetores","title":"4.3 Manipular ponteiros (endere\u00e7os) em vetores","text":"<ul> <li><code>.data</code> \u2014 diretiva que inicia a sess\u00e3o de dados</li> <li><code>.text</code> \u2014 diretiva que inicia a sess\u00e3o de c\u00f3digo</li> <li><code>la</code> \u2014 load address, carrega o endere\u00e7o de um label</li> <li><code>lw</code> \u2014 load word, l\u00ea 4 bytes da mem\u00f3ria para um registrador</li> </ul> <p>Em vetores declarados com <code>.word</code>, cada elemento ocupa 4 bytes:</p> <pre><code>.data\nvetor: .word 10, 20, 30, 40   # vetor de 4 inteiros (4 bytes cada)\n\n.text\n.globl main                   # .globl (global): torna 'main' ponto de entrada\n\nmain:\n    la t0, vetor              # la (load address): t0 recebe o endere\u00e7o do primeiro elemento de 'vetor'\n    lw t1, 0(t0)              # lw (load word): t1 recebe vetor[0]\n    addi t0, t0, 4            # addi: avan\u00e7a o ponteiro para o pr\u00f3ximo elemento (vetor[1])\n\n    li a7, 93                 # li: escolhe syscall exit2 (c\u00f3digo 93)\n    ecall                     # ecall (environment call): executa a syscall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#44-criar-deslocamentos-para-calculos","title":"4.4 Criar deslocamentos para c\u00e1lculos","text":"<pre><code>addi t2, t1, 100    # addi: t2 = t1 + 100 (deslocamento de 100 bytes)\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#5-exemplos-completos","title":"5. Exemplos completos","text":""},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#51-incremento-simples-com-limite","title":"5.1 Incremento simples com limite","text":"<p><code>blt</code> (branch if less than): desvia se <code>rs1 &lt; rs2</code>.</p> <pre><code>li t0, 0                # t0 = 0 (contador)\nli t1, 10               # t1 = 10 (limite)\n\nloop:\n    addi t0, t0, 1      # addi (add immediate): t0 = t0 + 1\n    blt t0, t1, loop    # blt (branch if less than): se t0 &lt; t1, volta para 'loop'\n\n    li a7, 93           # li: escolhe syscall exit2\n    ecall               # encerra o programa\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#52-decremento-ate-zero","title":"5.2 Decremento at\u00e9 zero","text":"<pre><code>li t0, 7                # t0 come\u00e7a em 7\n\nloop:\n    addi t0, t0, -1     # addi: t0 = t0 - 1\n    bne t0, x0, loop    # bne: enquanto t0 != 0, repete o loop\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#53-somando-com-imediatos-e-usando-addsub","title":"5.3 Somando com imediatos e usando <code>add</code>/<code>sub</code>","text":"<ul> <li><code>add</code> \u2014 add: soma dois registradores   <code>add rd, rs1, rs2</code> \u2192 <code>rd = rs1 + rs2</code></li> <li><code>sub</code> \u2014 subtract: subtrai registradores   <code>sub rd, rs1, rs2</code> \u2192 <code>rd = rs1 - rs2</code></li> </ul> <pre><code>li t0, 12               # t0 = 12\nli t1, 30               # t1 = 30\n\naddi t2, t1, -12        # addi: t2 = t1 + (-12) = 30 - 12\nadd t3, t0, t2          # add (add): t3 = t0 + t2 = 12 + 18\n\nsub t4, t3, t0          # sub (subtract): t4 = t3 - t0 = 30 - 12\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#54-percorrer-vetor-usando-addi-para-andar-na-memoria","title":"5.4 Percorrer vetor usando <code>addi</code> para andar na mem\u00f3ria","text":"<pre><code>.data\nvet: .word 3, 6, 9, 12          # vetor com 4 inteiros\n\n.text\n.globl main\n\nmain:\n    la t0, vet                  # la: t0 = endere\u00e7o base de vet\n    li t1, 0                    # t1 = \u00edndice i\n    li t2, 4                    # t2 = tamanho (4 elementos)\n\nloop:\n    lw t3, 0(t0)                # lw: t3 = vet[i]\n    # aqui poder\u00edamos fazer algo com t3 (somar, imprimir etc.)\n\n    addi t0, t0, 4              # addi: avan\u00e7a ponteiro para o pr\u00f3ximo elemento\n    addi t1, t1, 1              # addi: i = i + 1\n\n    blt t1, t2, loop            # blt: enquanto i &lt; 4, continua no loop\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#6-exercicios-para-fixacao","title":"6. Exerc\u00edcios para fixa\u00e7\u00e3o","text":"<ol> <li>Carregue o valor 57 em <code>a0</code> usando <code>li</code>.</li> <li>Some 10 ao registrador <code>t1</code> usando <code>addi</code>.</li> <li>Implemente um contador que come\u00e7a em 1 e vai at\u00e9 20 usando <code>li</code>, <code>addi</code> e <code>blt</code> ou <code>bne</code>.</li> <li>Dado um vetor de 4 <code>word</code>, avance o ponteiro at\u00e9 o \u00faltimo elemento usando <code>addi</code> (de 4 em 4 bytes).</li> <li> <p>Implemente <code>t3 = (t0 + 4) - (t1 + 7)</code> usando apenas:</p> </li> <li> <p><code>li</code></p> </li> <li><code>addi</code></li> <li><code>add</code></li> <li><code>sub</code></li> </ol>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/","title":"M\u00f3dulo 4 \u2014 Movimenta\u00e7\u00e3o de Dados","text":"<p>(<code>mv</code>, <code>lw</code>, <code>sw</code>, <code>la</code>)</p> <p>Este m\u00f3dulo explica como mover dados entre registradores e mem\u00f3ria no RISC-V (RISC-V = Reduced Instruction Set Computer \u2013 Five; ISA \u2014 Instruction Set Architecture, isto \u00e9, o conjunto de instru\u00e7\u00f5es que o processador entende).</p> <p>Essas instru\u00e7\u00f5es s\u00e3o a base de todo programa: somar, comparar, chamar fun\u00e7\u00e3o, fazer loop \u2014 tudo depende de colocar os dados nos registradores certos na hora certa.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#1-visao-geral-registradores-e-memoria","title":"1. Vis\u00e3o geral: registradores e mem\u00f3ria","text":"<p>Antes de aprender as instru\u00e7\u00f5es, precisamos entender onde os dados vivem.</p> <p>O processador (CPU \u2014 Central Processing Unit) trabalha basicamente com:</p> <ul> <li> <p>Registradores \u2014 pequenas c\u00e9lulas internas, extremamente r\u00e1pidas   Exemplos:</p> </li> <li> <p><code>t0</code> (temporary register),</p> </li> <li><code>a0</code> (argument register),</li> <li> <p><code>s0</code> (saved register).     Esses apelidos s\u00e3o nomes \u201camig\u00e1veis\u201d para registradores <code>x5</code>, <code>x10</code>, <code>x8</code> etc.</p> </li> <li> <p>Mem\u00f3ria RAM (RAM \u2014 Random Access Memory) \u2014 \u00e1rea grande, externa ao n\u00facleo do processador, mas mais lenta   \u00c9 onde ficam:</p> </li> <li> <p>dados da sess\u00e3o <code>.data</code></p> </li> <li>arrays, strings, matrizes</li> <li>vari\u00e1veis globais, buffers, etc.</li> </ul> <p>O RISC-V segue o modelo load/store:</p> <p>O processador s\u00f3 faz opera\u00e7\u00f5es aritm\u00e9ticas e l\u00f3gicas com dados que j\u00e1 est\u00e3o em registradores. Para buscar ou gravar na mem\u00f3ria, usamos instru\u00e7\u00f5es espec\u00edficas de load (carregar) e store (armazenar).</p> <p>Por isso <code>lw</code> e <code>sw</code> s\u00e3o t\u00e3o importantes.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#2-mv-mover-valor-entre-registradores","title":"2. <code>mv</code> \u2014 mover valor entre registradores","text":"<p><code>mv</code> (move) \u00e9 uma pseudo-instru\u00e7\u00e3o. Pseudo-instru\u00e7\u00e3o = instru\u00e7\u00e3o que n\u00e3o existe no hardware, mas o montador converte automaticamente para uma ou mais instru\u00e7\u00f5es reais.</p> <p>Sintaxe:</p> <pre><code>mv rd, rs\n</code></pre> <p>Significa:</p> <p>Copiar o valor do registrador <code>rs</code> para o registrador <code>rd</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 42              # li (load immediate): carrega o valor 42 em t0\nmv a0, t0              # mv (move): copia o valor de t0 para a0\n</code></pre> <p>Internamente, o montador converte:</p> <pre><code>mv rd, rs\n</code></pre> <p>para:</p> <pre><code>addi rd, rs, 0         # addi (add immediate): rd = rs + 0\n</code></pre>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#3-lw-load-word-carregar-palavra-da-memoria","title":"3. <code>lw</code> \u2014 load word (carregar palavra da mem\u00f3ria)","text":"<p><code>lw</code> (load word) \u00e9 uma instru\u00e7\u00e3o real do conjunto b\u00e1sico RV32I (RV32I = vers\u00e3o de 32 bits do RISC-V para inteiros, RISC-V 32-bit Integer).</p> <ul> <li>Word = palavra de 32 bits (4 bytes).</li> <li>A mem\u00f3ria do RISC-V \u00e9 endere\u00e7ada por bytes (byte-addressable): cada endere\u00e7o aponta para 1 byte.</li> </ul> <p>Sintaxe:</p> <pre><code>lw rd, offset(rs)\n</code></pre> <p>Significa:</p> <p>Ler 4 bytes (1 word) da mem\u00f3ria no endere\u00e7o <code>rs + offset</code> e colocar o resultado no registrador <code>rd</code>.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#exemplo-basico-de-lw","title":"Exemplo b\u00e1sico de <code>lw</code>","text":"<p>Aqui aparecem algumas diretivas pela primeira vez:</p> <ul> <li><code>.data</code> \u2014 inicia a sess\u00e3o de dados, onde declaramos vari\u00e1veis na mem\u00f3ria.</li> <li><code>.word</code> \u2014 reserva 4 bytes (1 word) e grava um valor inteiro.</li> <li><code>.text</code> \u2014 inicia a sess\u00e3o de c\u00f3digo, onde ficam as instru\u00e7\u00f5es.</li> <li><code>.globl main</code> \u2014 torna o r\u00f3tulo <code>main</code> o ponto de entrada do programa.</li> </ul> <pre><code>.data\nx: .word 99                 # .word: reserva 4 bytes e coloca o inteiro 99 em x\n\n.text\n.globl main                 # .globl (global): exp\u00f5e 'main' como ponto de entrada\n\nmain:\n    la t0, x                # la (load address): carrega em t0 o endere\u00e7o do r\u00f3tulo x\n    lw t1, 0(t0)            # lw (load word): l\u00ea 4 bytes a partir de t0 e coloca o valor em t1 (99)\n\n    li a7, 93               # li: coloca 93 em a7 (c\u00f3digo da syscall exit2)\n    ecall                   # ecall (environment call): executa a syscall indicada em a7\n</code></pre> <p>Passo a passo:</p> <ol> <li><code>la t0, x</code> \u2192 <code>t0</code> recebe o endere\u00e7o de mem\u00f3ria onde est\u00e1 <code>x</code>.</li> <li><code>lw t1, 0(t0)</code> \u2192 l\u00ea 4 bytes a partir de <code>t0</code> e coloca o valor (99) em <code>t1</code>.</li> </ol>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#4-sw-store-word-armazenar-palavra-na-memoria","title":"4. <code>sw</code> \u2014 store word (armazenar palavra na mem\u00f3ria)","text":"<p><code>sw</code> (store word) grava um valor de 32 bits da CPU para a mem\u00f3ria.</p> <p>Sintaxe:</p> <pre><code>sw rs2, offset(rs1)\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <p>Armazena o valor de 32 bits do registrador <code>rs2</code> no endere\u00e7o <code>rs1 + offset</code>.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#exemplo-basico-de-sw","title":"Exemplo b\u00e1sico de <code>sw</code>","text":"<pre><code>.data\ny: .word 0                  # reserva 4 bytes e inicializa com 0\n\n.text\n.globl main\n\nmain:\n    li t0, 55               # li (load immediate): t0 recebe o valor 55\n    la t1, y                # la (load address): t1 recebe o endere\u00e7o de y\n    sw t0, 0(t1)            # sw (store word): grava o valor de t0 (55) na mem\u00f3ria em y\n\n    li a7, 93\n    ecall\n</code></pre> <p>Depois de executar:</p> <ul> <li>o registrador <code>t0</code> cont\u00e9m 55,</li> <li>a posi\u00e7\u00e3o de mem\u00f3ria associada a <code>y</code> tamb\u00e9m passa a conter 55.</li> </ul>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#5-la-load-address-carregar-endereco","title":"5. <code>la</code> \u2014 load address (carregar endere\u00e7o)","text":"<p><code>la</code> (load address) \u00e9 uma pseudo-instru\u00e7\u00e3o que carrega o endere\u00e7o de um r\u00f3tulo (<code>label</code>) para dentro de um registrador.</p> <p>Sintaxe:</p> <pre><code>la rd, label\n</code></pre> <p>Significa:</p> <p>Colocar no registrador <code>rd</code> o endere\u00e7o de mem\u00f3ria associado ao r\u00f3tulo <code>label</code>.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#exemplo-com-string-e-syscall","title":"Exemplo com string e syscall","text":"<p>Aqui aparece pela primeira vez:</p> <ul> <li><code>.asciz</code> \u2014 diretiva que cria uma string ASCII terminada em byte zero (<code>\\0</code>),   ASCII = American Standard Code for Information Interchange.</li> <li><code>syscall</code> \u2014 chamada de sistema (system call), servi\u00e7o fornecido pelo simulador.</li> <li><code>a7</code> como registrador de c\u00f3digo de syscall.</li> <li><code>a0</code> como registrador de argumento.</li> </ul> <pre><code>.data\nmsg: .asciz \"Hello\\n\"       # .asciz: string ASCII terminada em 0 (formato C-string)\n\n.text\n.globl main\n\nmain:\n    la a0, msg              # la: a0 recebe o endere\u00e7o do in\u00edcio da string msg\n    li a7, 4                # li: coloca 4 em a7 (c\u00f3digo da syscall print_string)\n    ecall                   # ecall: executa a syscall configurada (imprime a string)\n\n    li a7, 93               # 93 = exit2\n    ecall\n</code></pre> <p>Nos bastidores, o montador pode traduzir <code>la</code> para algo como:</p> <ul> <li><code>auipc</code> (add upper immediate to PC) \u2014 soma imediato \u00e0 parte alta do PC   PC = program counter, registrador que guarda o endere\u00e7o da pr\u00f3xima instru\u00e7\u00e3o.</li> <li><code>addi</code> (add immediate) \u2014 soma imediato \u00e0 parte baixa.</li> </ul> <p>Mas para quem est\u00e1 aprendendo, basta saber:</p> <p><code>la</code> devolve o endere\u00e7o do r\u00f3tulo.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#6-mapa-mental-quando-usar-cada-instrucao","title":"6. Mapa mental \u2014 quando usar cada instru\u00e7\u00e3o","text":"Tarefa Instru\u00e7\u00e3o Copiar valor entre registradores <code>mv</code> (move) Colocar n\u00famero imediato em registrador <code>li</code> (load immediate, pseudo) Ler inteiro (32 bits) da mem\u00f3ria <code>lw</code> (load word) Gravar inteiro (32 bits) na mem\u00f3ria <code>sw</code> (store word) Obter endere\u00e7o de um r\u00f3tulo na mem\u00f3ria <code>la</code> (load address, pseudo)"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#7-exercicio-1-copiar-gravar-e-ler","title":"7. Exerc\u00edcio 1 \u2014 copiar, gravar e ler","text":"<p>Objetivo:</p> <ol> <li>Colocar um valor em <code>t0</code></li> <li>Guardar esse valor na mem\u00f3ria</li> <li>Carregar de volta para <code>t2</code></li> </ol> <p>C\u00f3digo de refer\u00eancia:</p> <pre><code>.data\nvalor: .word 0                   # reserva 4 bytes para 'valor'\n\n.text\n.globl main\n\nmain:\n    li t0, 123                   # li: t0 = 123\n\n    la t1, valor                 # la: t1 recebe o endere\u00e7o de 'valor'\n    sw t0, 0(t1)                 # sw: grava o conte\u00fado de t0 na mem\u00f3ria em 'valor'\n\n    lw t2, 0(t1)                 # lw: carrega de volta o valor armazenado em 'valor' para t2\n\n    li a7, 93\n    ecall\n</code></pre> <p>No RARS, observe:</p> <ul> <li>painel Registers \u2192 valores em <code>t0</code>, <code>t1</code>, <code>t2</code></li> <li>painel Data \u2192 valor de <code>valor</code> na mem\u00f3ria</li> </ul>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#8-exercicio-2-vetor-array-de-4-elementos","title":"8. Exerc\u00edcio 2 \u2014 vetor (array) de 4 elementos","text":"<p>Objetivo:</p> <ul> <li>Somar os valores de um array usando <code>lw</code> para ler e <code>add</code> para acumular.</li> </ul> <p>Aqui aparece pela primeira vez:</p> <ul> <li><code>add</code> \u2014 add (somar dois registradores):   <code>add rd, rs1, rs2</code> \u2192 <code>rd = rs1 + rs2</code></li> <li><code>addi</code> \u2014 add immediate (somar imediato):   <code>addi rd, rs1, imediato</code> \u2192 <code>rd = rs1 + imediato</code></li> <li><code>blt</code> \u2014 branch if less than (desvia se menor que):   <code>blt rs1, rs2, label</code> \u2192 desvia se <code>rs1 &lt; rs2</code>.</li> </ul> <pre><code>.data\nvet: .word 3, 5, 7, 9           # quatro inteiros\n\n.text\n.globl main\n\nmain:\n    la t0, vet                  # la: t0 = endere\u00e7o do primeiro elemento (vet[0])\n    li t1, 0                    # li: t1 = \u00edndice i = 0\n    li t2, 0                    # li: t2 = soma acumulada = 0\n\nloop:\n    lw t3, 0(t0)                # lw: t3 = vet[i]\n    add t2, t2, t3              # add: t2 = t2 + t3  (soma += elemento)\n\n    addi t0, t0, 4              # addi: avan\u00e7a ponteiro para o pr\u00f3ximo elemento (4 bytes)\n    addi t1, t1, 1              # addi: i = i + 1    (incrementa \u00edndice)\n\n    li t4, 4                    # li: t4 = 4 (tamanho do vetor)\n    blt t1, t4, loop            # blt: enquanto i &lt; 4, volta para 'loop'\n\n    # aqui t2 cont\u00e9m a soma total (3 + 5 + 7 + 9)\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/","title":"M\u00f3dulo 4 \u2014 Aritm\u00e9tica B\u00e1sica","text":"<p>(<code>add</code>, <code>sub</code>)</p> <p>A aritm\u00e9tica no RISC-V (ISA \u2014 Instruction Set Architecture) \u00e9 extremamente simples e direta. O conjunto b\u00e1sico RV32I (Integer instruction set de 32 bits) traz instru\u00e7\u00f5es para somar, subtrair e adicionar imediatos. Este m\u00f3dulo cobre apenas a aritm\u00e9tica essencial: somar e subtrair.</p>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#1-por-que-aritmetica-em-assembly-e-tao-importante","title":"1. Por que aritm\u00e9tica em assembly \u00e9 t\u00e3o importante?","text":"<p>Toda opera\u00e7\u00e3o l\u00f3gica, toda condi\u00e7\u00e3o, todo loop, toda fun\u00e7\u00e3o\u2026 acaba dependendo do b\u00e1sico:</p> <ul> <li>somar \u00edndices</li> <li>subtrair contadores</li> <li>atualizar ponteiros</li> <li>calcular deslocamentos de mem\u00f3ria</li> <li>somar acumuladores</li> <li>fazer incrementos e decrementos</li> </ul> <p>No RISC-V, tudo isso \u00e9 feito com poucas instru\u00e7\u00f5es simples e totalmente determin\u00edsticas.</p>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#2-a-instrucao-add-somar-registradores","title":"2. A instru\u00e7\u00e3o <code>add</code> \u2014 somar registradores","text":"<p><code>add</code> (add) \u00e9 uma instru\u00e7\u00e3o real do RV32I que soma dois registradores e guarda o resultado em um terceiro.</p> <p>Sintaxe:</p> <pre><code>add rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd = rs1 + rs2</code></p> <p>Exemplo:</p> <pre><code>li t0, 7              # li (load immediate): coloca 7 em t0\nli t1, 5              # coloca 5 em t1\nadd t2, t0, t1        # t2 = 7 + 5 = 12\n</code></pre> <ul> <li>Somente registradores podem ser somados.</li> <li>O resultado sempre fica no registrador <code>rd</code>.</li> </ul>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#3-a-instrucao-addi-somar-com-imediato","title":"3. A instru\u00e7\u00e3o <code>addi</code> \u2014 somar com imediato","text":"<p><code>addi</code> (add immediate) \u00e9 a vers\u00e3o de soma onde o segundo operando \u00e9 um valor imediato de 12 bits (constante inteira).</p> <p>Sintaxe:</p> <pre><code>addi rd, rs1, imediato\n</code></pre> <p>Significa:</p> <p><code>rd = rs1 + imediato</code></p> <p>Exemplos \u00fateis:</p>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#incrementar-um-contador","title":"Incrementar um contador","text":"<pre><code>addi t0, t0, 1        # t0 = t0 + 1\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#decrementar","title":"Decrementar","text":"<pre><code>addi t0, t0, -1       # t0 = t0 - 1\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#somar-deslocamento-de-ponteiro","title":"Somar deslocamento de ponteiro","text":"<pre><code>addi t0, t0, 4        # avan\u00e7a 1 word (4 bytes)\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#4-a-instrucao-sub-subtracao","title":"4. A instru\u00e7\u00e3o <code>sub</code> \u2014 subtra\u00e7\u00e3o","text":"<p><code>sub</code> (subtract) \u00e9 uma instru\u00e7\u00e3o do RV32I que calcula a diferen\u00e7a entre dois registradores.</p> <p>Sintaxe:</p> <pre><code>sub rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd = rs1 - rs2</code></p> <p>Exemplo:</p> <pre><code>li t0, 20\nli t1, 7\nsub t2, t0, t1        # t2 = 20 - 7 = 13\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#5-aritmetica-e-flags-importante","title":"5. Aritm\u00e9tica e flags \u2014 importante!","text":"<p>Diferente de arquiteturas como x86, o RISC-V n\u00e3o possui flags (carry, overflow, zero, negativo). Por isso, opera\u00e7\u00f5es matem\u00e1ticas n\u00e3o alteram estados especiais.</p> <p>Compara\u00e7\u00f5es e desvios s\u00e3o feitos explicitamente com instru\u00e7\u00f5es de branch (<code>beq</code>, <code>bne</code>, <code>blt</code> etc.), n\u00e3o com flags autom\u00e1ticos.</p>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#6-exemplos-completos","title":"6. Exemplos completos","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#61-somar-dois-numeros","title":"6.1 Somar dois n\u00fameros","text":"<pre><code>li t0, 15              # primeiro n\u00famero\nli t1, 27              # segundo n\u00famero\nadd t2, t0, t1         # t2 = 42\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#62-subtrair-dois-numeros","title":"6.2 Subtrair dois n\u00fameros","text":"<pre><code>li t0, 50\nli t1, 12\nsub t2, t0, t1         # t2 = 38\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#63-incrementar-contador-ate-atingir-limite","title":"6.3 Incrementar contador at\u00e9 atingir limite","text":"<pre><code>li t0, 0               # contador\nli t1, 10              # limite\n\nloop:\n    addi t0, t0, 1     # contador++\n    blt t0, t1, loop   # repete at\u00e9 t0 &lt; 10\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#64-manipular-ponteiros-para-array","title":"6.4 Manipular ponteiros para array","text":"<pre><code>.data\nvet: .word 3, 6, 9, 12\n\n.text\nmain:\n    la t0, vet         # t0 = endere\u00e7o do vetor\n    lw t1, 0(t0)       # l\u00ea vet[0]\n    addi t0, t0, 4     # t0 agora aponta para vet[1]\n    lw t2, 0(t0)       # l\u00ea vet[1]\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#7-exercicios-para-fixacao","title":"7. Exerc\u00edcios para fixa\u00e7\u00e3o","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#1-some-os-numeros-12-e-31-e-coloque-o-resultado-em-t2","title":"1. Some os n\u00fameros 12 e 31 e coloque o resultado em <code>t2</code>.","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#2-subtraia-100-37-usando-sub","title":"2. Subtraia 100 \u2212 37 usando <code>sub</code>.","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#3-implemente-um-contador-que-comeca-em-10-e-vai-ate-0-usando-addi","title":"3. Implemente um contador que come\u00e7a em 10 e vai at\u00e9 0 usando <code>addi</code>.","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#4-some-todos-os-elementos-de-um-vetor-de-5-posicoes-usando","title":"4. Some todos os elementos de um vetor de 5 posi\u00e7\u00f5es usando:","text":"<ul> <li><code>add</code></li> <li><code>addi</code></li> <li><code>lw</code></li> </ul>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#5-calcule-t2-t0-4-t1-3-usando-somente-add-sub-e-addi","title":"5. Calcule <code>t2 = (t0 + 4) - (t1 - 3)</code> usando somente <code>add</code>, <code>sub</code> e <code>addi</code>.","text":""},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/","title":"M\u00f3dulo 4 \u2014 Compara\u00e7\u00f5es e Desvios","text":"<p>(<code>beq</code>, <code>bne</code>, <code>blt</code>, <code>bgt</code>, <code>beqz</code>, <code>bnez</code>)</p> <p>Este m\u00f3dulo mostra como o RISC-V (RISC-V = Reduced Instruction Set Computer \u2013 Five) usa instru\u00e7\u00f5es de desvio (branch instructions) para tomar decis\u00f5es.</p> <p>\u00c9 com essas instru\u00e7\u00f5es que implementamos, em assembly:</p> <ul> <li><code>if</code>, <code>else</code></li> <li><code>while</code></li> <li><code>for</code></li> <li>e qualquer tipo de decis\u00e3o condicional</li> </ul> <p>Vou assumir que voc\u00ea j\u00e1 tem no\u00e7\u00e3o de:</p> <ul> <li>registradores (como <code>a0</code>, <code>t0</code>, <code>x0</code>)</li> <li>diretivas <code>.data</code> e <code>.text</code></li> <li>no\u00e7\u00f5es b\u00e1sicas de syscalls (system calls) no RARS   RARS = RISC-V Assembler and Runtime Simulator, um simulador de RISC-V que monta e executa programas <code>.asm</code>.</li> </ul> <p>Mesmo assim, tudo que aparecer pela primeira vez neste arquivo \u00e9 explicado.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#1-ideia-central-nao-existe-if-so-branch","title":"1. Ideia central: n\u00e3o existe <code>if</code>, s\u00f3 branch","text":"<p>Em C:</p> <pre><code>if (x == y) {\n    // bloco verdadeiro\n} else {\n    // bloco falso\n}\n</code></pre> <p>Em RISC-V, o processador n\u00e3o conhece a palavra <code>if</code>. O que existe \u00e9:</p> <ol> <li>Comparar valores em registradores</li> <li>Se a condi\u00e7\u00e3o for verdadeira, desviar para um r\u00f3tulo (label), que \u00e9 um nome que marca uma posi\u00e7\u00e3o no c\u00f3digo</li> <li>Se a condi\u00e7\u00e3o for falsa, apenas continuar executando a pr\u00f3xima instru\u00e7\u00e3o</li> </ol> <p>Ou seja:</p> <p>\u201cIF\u201d \u00e9 s\u00f3 um jeito humano de organizar branches (instru\u00e7\u00f5es de desvio).</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#2-registradores-e-instrucoes-de-apoio","title":"2. Registradores e instru\u00e7\u00f5es de apoio","text":"<p>Dois tipos de registradores aparecem muito em compara\u00e7\u00f5es:</p> <ul> <li><code>x0</code> \u2014 registrador especial que sempre vale 0 (zero \u201cligado por hardware\u201d, hard-wired zero)</li> <li><code>t0</code>, <code>t1</code>, <code>t2</code>\u2026 \u2014 registradores tempor\u00e1rios (temporary registers), usados para c\u00e1lculos intermedi\u00e1rios</li> </ul> <p>Tamb\u00e9m vamos usar algumas instru\u00e7\u00f5es de apoio:</p> <ul> <li> <p><code>li rd, imm</code> \u2014 <code>li</code> (load immediate): carrega um valor imediato (constante) <code>imm</code> diretamente para o registrador <code>rd</code>.   Exemplo: <code>li t0, 10</code> coloca o valor 10 dentro de <code>t0</code>.</p> </li> <li> <p><code>addi rd, rs1, imm</code> \u2014 <code>addi</code> (add immediate): soma o valor imediato <code>imm</code> ao conte\u00fado de <code>rs1</code> e guarda o resultado em <code>rd</code>.   Exemplo: <code>addi t0, t0, 1</code> faz <code>t0 = t0 + 1</code>.</p> </li> <li> <p><code>j label</code> \u2014 <code>j</code> (jump): pseudo-instru\u00e7\u00e3o de salto incondicional.   O montador traduz <code>j label</code> para <code>jal x0, label</code>   (<code>jal</code> = jump and link, mas como o destino \u00e9 <code>x0</code>, o retorno \u00e9 descartado).</p> </li> <li> <p><code>ecall</code> \u2014 <code>ecall</code> (environment call): dispara uma syscall (chamada de sistema) configurada no registrador <code>a7</code>.   Por exemplo, no RARS: <code>a7 = 4</code> \u2192 imprimir string; <code>a7 = 93</code> \u2192 encerrar o programa.</p> </li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#3-instrucoes-de-desvio-basicas","title":"3. Instru\u00e7\u00f5es de desvio b\u00e1sicas","text":"<p>As instru\u00e7\u00f5es de desvio comparam dois registradores. Se a condi\u00e7\u00e3o for verdadeira, elas pulam para um r\u00f3tulo (<code>label:</code>).</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#31-beq-rs1-rs2-label","title":"3.1 <code>beq rs1, rs2, label</code>","text":"<p><code>beq</code> (branch if equal) desvia se os registradores forem iguais.</p> <p>Sintaxe:</p> <pre><code>beq rs1, rs2, label\n</code></pre> <p>Significa:</p> <p>Se <code>rs1 == rs2</code>, pule para <code>label</code>. Caso contr\u00e1rio, continue executando a pr\u00f3xima instru\u00e7\u00e3o.</p> <p>Exemplo:</p> <pre><code>li t0, 10           # li: t0 = 10\nli t1, 10           # li: t1 = 10\n\nbeq t0, t1, iguais  # beq: se t0 == t1, desvia para o r\u00f3tulo 'iguais'\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#32-bne-rs1-rs2-label","title":"3.2 <code>bne rs1, rs2, label</code>","text":"<p><code>bne</code> (branch if not equal) desvia se os registradores forem diferentes.</p> <p>Sintaxe:</p> <pre><code>bne rs1, rs2, label\n</code></pre> <p>Significa:</p> <p>Se <code>rs1 != rs2</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 5\nli t1, 7\n\nbne t0, t1, sao_diferentes   # bne: como 5 != 7, o desvio acontece\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#33-blt-rs1-rs2-label","title":"3.3 <code>blt rs1, rs2, label</code>","text":"<p><code>blt</code> (branch if less than) desvia se <code>rs1</code> for menor que <code>rs2</code>, tratando os valores como n\u00fameros com sinal (signed).</p> <p>Sintaxe:</p> <pre><code>blt rs1, rs2, label\n</code></pre> <p>Significa:</p> <p>Se <code>rs1 &lt; rs2</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 3\nli t1, 10\n\nblt t0, t1, menor          # blt: como 3 &lt; 10, o desvio acontece\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#34-bgt-rs1-rs2-label-pseudo-instrucao","title":"3.4 <code>bgt rs1, rs2, label</code> (pseudo-instru\u00e7\u00e3o)","text":"<p><code>bgt</code> (branch if greater than) n\u00e3o existe como instru\u00e7\u00e3o real no conjunto RV32I. Ela \u00e9 uma pseudo-instru\u00e7\u00e3o criada pelo montador para facilitar a escrita.</p> <p>Sintaxe:</p> <pre><code>bgt rs1, rs2, label\n</code></pre> <p>O montador normalmente converte isso em algo equivalente a:</p> <pre><code>blt rs2, rs1, label   # branch if rs2 &lt; rs1 \u2192 ou seja, rs1 &gt; rs2\n</code></pre> <p>Significa:</p> <p>Se <code>rs1 &gt; rs2</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 15\nli t1, 7\n\nbgt t0, t1, maior        # bgt: desvia, porque 15 &gt; 7\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#4-comparacoes-com-zero-beqz-e-bnez","title":"4. Compara\u00e7\u00f5es com zero: <code>beqz</code> e <code>bnez</code>","text":"<p>Comparar um registrador com zero \u00e9 t\u00e3o comum que o montador oferece pseudo-instru\u00e7\u00f5es especiais.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#41-beqz-rs-label","title":"4.1 <code>beqz rs, label</code>","text":"<p><code>beqz</code> (branch if equal to zero) \u00e9 uma pseudo-instru\u00e7\u00e3o que desvia se o registrador for igual a zero.</p> <p>Sintaxe:</p> <pre><code>beqz rs, label\n</code></pre> <p>O montador traduz para:</p> <pre><code>beq rs, x0, label       # compara com o registrador x0 (constante zero)\n</code></pre> <p>Significa:</p> <p>Se <code>rs == 0</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 0\nbeqz t0, eh_zero        # como t0 \u00e9 0, o desvio acontece\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#42-bnez-rs-label","title":"4.2 <code>bnez rs, label</code>","text":"<p><code>bnez</code> (branch if not equal to zero) \u00e9 a vers\u00e3o \u201cdiferente de zero\u201d.</p> <p>Sintaxe:</p> <pre><code>bnez rs, label\n</code></pre> <p>O montador traduz para:</p> <pre><code>bne rs, x0, label\n</code></pre> <p>Significa:</p> <p>Se <code>rs != 0</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 42\nbnez t0, nao_zero       # como t0 != 0, o desvio acontece\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#5-padrao-de-if-simples-em-risc-v","title":"5. Padr\u00e3o de IF simples em RISC-V","text":"<p>Vamos representar em C:</p> <pre><code>if (t0 == 10) {\n    // bloco verdadeiro\n}\n</code></pre> <p>Vers\u00e3o t\u00edpica em RISC-V:</p> <pre><code>    li t0, 10                   # t0 = 10\n    li t1, 10                   # valor de compara\u00e7\u00e3o\n\n    bne t0, t1, fim_if          # se t0 != 10, pula o bloco verdadeiro\n\n    # bloco verdadeiro (t0 == 10)\n    # ... c\u00f3digo do verdadeiro ...\n\nfim_if:\n    # continua\u00e7\u00e3o do programa\n</code></pre> <p>Estrat\u00e9gia:</p> <ul> <li>usar <code>bne</code> para saltar o bloco quando a condi\u00e7\u00e3o \u00e9 falsa</li> <li>colocar um r\u00f3tulo <code>fim_if</code> para marcar o ponto de continua\u00e7\u00e3o</li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#6-ifelse-em-risc-v","title":"6. IF\u2013ELSE em RISC-V","text":"<p>Em C:</p> <pre><code>if (t0 == 10) {\n    // verdadeiro\n} else {\n    // falso\n}\n</code></pre> <p>Vers\u00e3o em assembly:</p> <pre><code>    li t0, 10\n    li t1, 10\n\n    bne t0, t1, bloco_falso   # se t0 != 10, vai para o bloco falso\n\nbloco_verdadeiro:\n    # aqui t0 == 10\n    # ... c\u00f3digo do bloco verdadeiro ...\n    j fim_if                  # j (jump): salto incondicional para 'fim_if'\n\nbloco_falso:\n    # ... c\u00f3digo do bloco falso ...\n\nfim_if:\n    # segue o programa\n</code></pre> <p>Lembrando:</p> <ul> <li><code>j</code> \u00e9 pseudo-instru\u00e7\u00e3o de salto incondicional   O montador traduz <code>j fim_if</code> para <code>jal x0, fim_if</code>.</li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#7-exemplo-completo-negativo-zero-ou-positivo","title":"7. Exemplo completo: negativo, zero ou positivo","text":"<p>Vamos classificar um n\u00famero como negativo, zero ou positivo usando instru\u00e7\u00f5es de desvio.</p> <p>Aqui aparecem algumas diretivas pela primeira vez neste m\u00f3dulo:</p> <ul> <li><code>.data</code> \u2014 in\u00edcio da sess\u00e3o de dados, onde declaramos vari\u00e1veis e strings.</li> <li><code>.text</code> \u2014 in\u00edcio da sess\u00e3o de c\u00f3digo, onde ficam as instru\u00e7\u00f5es.</li> <li><code>.globl main</code> \u2014 torna o r\u00f3tulo <code>main</code> o ponto de entrada vis\u00edvel externamente.</li> <li><code>.asciz</code> \u2014 define uma string ASCII terminada com byte zero (<code>\\0</code>), formato esperado por algumas syscalls.</li> </ul> <p>Syscalls usadas (no RARS):</p> <ul> <li><code>a7 = 4</code> \u2192 print_string (imprime string apontada por <code>a0</code>)</li> <li><code>a7 = 93</code> \u2192 exit2 (encerra o programa)</li> </ul> <pre><code>.data\nmsgNeg:  .asciz \"Numero negativo\\n\"    # .asciz: string terminada em byte 0\nmsgZero: .asciz \"Numero zero\\n\"\nmsgPos:  .asciz \"Numero positivo\\n\"\n\n.text\n.globl main                            # .globl (global): exp\u00f5e 'main' como entrada\n\nmain:\n    # exemplo: vamos testar o valor -5\n    li t0, -5                          # li: carrega o valor imediato -5 em t0\n\n    blt t0, x0, negativo               # blt: se t0 &lt; 0, desvia para 'negativo'\n    beq t0, x0, eh_zero                # beq: se t0 == 0, desvia para 'eh_zero'\n\n    # se n\u00e3o \u00e9 &lt; 0 nem == 0, s\u00f3 pode ser positivo\n    la a0, msgPos                      # la (load address): a0 = endere\u00e7o de msgPos\n    li a7, 4                           # li: a7 = 4 (syscall print_string)\n    ecall                              # ecall: executa a syscall \u2192 imprime \"Numero positivo\"\n    j fim\n\nnegativo:\n    la a0, msgNeg\n    li a7, 4\n    ecall\n    j fim\n\neh_zero:\n    la a0, msgZero\n    li a7, 4\n    ecall\n\nfim:\n    li a7, 93                          # 93 = syscall exit2\n    ecall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#8-exemplo-beqzbnez-dentro-de-um-loop","title":"8. Exemplo: <code>beqz</code>/<code>bnez</code> dentro de um loop","text":"<p>Agora vamos usar <code>bnez</code> para pular os n\u00fameros \u00edmpares e imprimir apenas os pares de 1 a 10.</p> <p>Nova instru\u00e7\u00e3o:</p> <ul> <li><code>andi rd, rs1, imm</code> \u2014 <code>andi</code> (AND immediate): faz um AND bit a bit entre <code>rs1</code> e o imediato <code>imm</code> e coloca o resultado em <code>rd</code>.   Exemplo: <code>andi t2, t0, 1</code> pega apenas o bit menos significativo de <code>t0</code>.</li> </ul> <p>L\u00f3gica:</p> <ul> <li>se <code>t0 &amp; 1 == 0</code> \u2192 n\u00famero \u00e9 par</li> <li>se <code>t0 &amp; 1 != 0</code> \u2192 n\u00famero \u00e9 \u00edmpar</li> </ul> <pre><code>.text\n.globl main\n\nmain:\n    li  t0, 1                # t0 = 1 (contador)\n\nloop:\n    andi t2, t0, 1           # andi: t2 = t0 &amp; 1 (isola o bit menos significativo)\n    bnez t2, nao_par         # bnez: se t2 != 0, n\u00famero \u00e9 \u00edmpar \u2192 pula impress\u00e3o\n\n    # se chegou aqui, o n\u00famero \u00e9 par\n    mv  a0, t0               # mv: copia t0 para a0\n    li  a7, 1                # 1 = syscall print_int (imprimir inteiro)\n    ecall\n\n    # quebra de linha\n    li  a0, 10               # 10 = '\\n' em ASCII\n    li  a7, 11               # 11 = syscall print_char\n    ecall\n\nnao_par:\n    addi t0, t0, 1           # addi: t0 = t0 + 1\n    li   t1, 11              # t1 = 11 (limite superior exclusivo)\n    blt  t0, t1, loop        # blt: enquanto t0 &lt; 11, repete o loop\n\n    li   a7, 93              # exit2\n    ecall\n</code></pre> <p>Aqui <code>bnez</code> est\u00e1 fazendo exatamente o papel de:</p> <pre><code>if (t2 != 0) {\n    // n\u00e3o imprime (\u00e9 \u00edmpar)\n}\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#9-traducoes-uteis-de-c-para-risc-v","title":"9. Tradu\u00e7\u00f5es \u00fateis: de C para RISC-V","text":"<p>Uma \u201ccola r\u00e1pida\u201d de condi\u00e7\u00f5es comuns:</p> <ul> <li> <p><code>if (x == y)</code>   \u2192 <code>beq x, y, rotulo_verdadeiro</code></p> </li> <li> <p><code>if (x != y)</code>   \u2192 <code>bne x, y, rotulo_verdadeiro</code></p> </li> <li> <p><code>if (x &lt; y)</code>   \u2192 <code>blt x, y, rotulo_verdadeiro</code></p> </li> <li> <p><code>if (x &gt; y)</code>   \u2192 <code>bgt x, y, rotulo_verdadeiro</code>   (pseudo-instru\u00e7\u00e3o; montador converte em <code>blt y, x, rotulo_verdadeiro</code>)</p> </li> <li> <p><code>if (x == 0)</code>   \u2192 <code>beqz x, rotulo_verdadeiro</code>   (pseudo: <code>beq x, x0, rotulo_verdadeiro</code>)</p> </li> <li> <p><code>if (x != 0)</code>   \u2192 <code>bnez x, rotulo_verdadeiro</code>   (pseudo: <code>bne x, x0, rotulo_verdadeiro</code>)</p> </li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#10-exercicios-para-fixacao","title":"10. Exerc\u00edcios para fixa\u00e7\u00e3o","text":"<p>Os exerc\u00edcios abaixo s\u00e3o pensados para treinar exatamente as instru\u00e7\u00f5es deste m\u00f3dulo:</p> <ul> <li><code>beq</code>, <code>bne</code>, <code>blt</code>, <code>bgt</code>, <code>beqz</code>, <code>bnez</code></li> <li>combinadas com <code>li</code>, <code>addi</code>, <code>j</code>, <code>andi</code>, syscalls simples</li> </ul> <p>Use o RARS para montar e executar.</p> <p>Dica geral: no RARS, a syscall de leitura de inteiro (read_int) usa o c\u00f3digo 5 em <code>a7</code> e devolve o valor em <code>a0</code>.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-1-igual-ou-diferente-de-10","title":"Exerc\u00edcio 1 \u2014 Igual ou diferente de 10","text":"<p>Escreva um programa que:</p> <ol> <li>Coloque um valor em <code>t0</code> usando <code>li</code> (pode testar com 10, depois com 7).</li> <li>Compare <code>t0</code> com o valor 10.</li> <li>Se <code>t0 == 10</code>, imprima a mensagem:    <code>\"Valor igual a 10\\n\"</code>.</li> <li>Caso contr\u00e1rio, imprima:    <code>\"Valor diferente de 10\\n\"</code>.</li> </ol> <p>Restri\u00e7\u00e3o: use apenas <code>beq</code> e <code>bne</code> para o desvio.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-2-maior-de-dois-numeros","title":"Exerc\u00edcio 2 \u2014 Maior de dois n\u00fameros","text":"<p>Fa\u00e7a um programa que:</p> <ol> <li>Coloque dois valores em <code>t0</code> e <code>t1</code> usando <code>li</code>.</li> <li>Use <code>bgt</code> (pseudo-instru\u00e7\u00e3o) ou a combina\u00e7\u00e3o equivalente com <code>blt</code> para descobrir qual \u00e9 o maior.</li> <li> <p>Imprima:</p> </li> <li> <p><code>\"t0 \u00e9 maior\\n\"</code> se <code>t0 &gt; t1</code></p> </li> <li><code>\"t1 \u00e9 maior ou igual\\n\"</code> caso contr\u00e1rio</li> </ol> <p>Sugest\u00e3o: Use um r\u00f3tulo <code>t0_maior:</code> para o caso em que <code>t0</code> \u00e9 maior, e um r\u00f3tulo <code>fim:</code> para a continua\u00e7\u00e3o.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-3-classificar-numero-lido-do-usuario","title":"Exerc\u00edcio 3 \u2014 Classificar n\u00famero lido do usu\u00e1rio","text":"<p>Escreva um programa que:</p> <ol> <li> <p>Use a syscall de leitura de inteiro (c\u00f3digo 5 em <code>a7</code>) para ler um valor digitado pelo usu\u00e1rio.</p> </li> <li> <p>Copie o valor lido de <code>a0</code> para <code>t0</code>.</p> </li> <li> <p>Classifique o n\u00famero como:</p> </li> <li> <p>negativo (<code>&lt; 0</code>)</p> </li> <li>zero (<code>== 0</code>)</li> <li> <p>positivo (<code>&gt; 0</code>)</p> </li> <li> <p>Imprima uma das mensagens:</p> </li> <li> <p><code>\"Numero negativo\\n\"</code></p> </li> <li><code>\"Numero zero\\n\"</code></li> <li><code>\"Numero positivo\\n\"</code></li> </ol> <p>Restri\u00e7\u00e3o: use apenas <code>blt</code>, <code>beq</code> e <code>j</code> para os desvios.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-4-contador-decrescente-com-beqz","title":"Exerc\u00edcio 4 \u2014 Contador decrescente com <code>beqz</code>","text":"<p>Implemente um contador que:</p> <ol> <li> <p>Come\u00e7a em 10 (por exemplo, em <code>t0</code>).</p> </li> <li> <p>Em cada itera\u00e7\u00e3o do loop:</p> </li> <li> <p>imprime o valor atual em <code>t0</code></p> </li> <li> <p>decrementa <code>t0</code> em 1 (<code>addi t0, t0, -1</code>)</p> </li> <li> <p>Usa <code>beqz</code> para parar quando o contador chegar em 0.</p> </li> <li> <p>Ao final, encerra o programa com a syscall exit2 (c\u00f3digo 93 em <code>a7</code>).</p> </li> </ol>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-5-imprimir-apenas-impares-com-bnez","title":"Exerc\u00edcio 5 \u2014 Imprimir apenas \u00edmpares com <code>bnez</code>","text":"<p>Adapte o exemplo de pares para:</p> <ol> <li>Contar de 1 at\u00e9 20.</li> <li>Calcular <code>t0 &amp; 1</code> usando <code>andi</code>.</li> <li>Imprimir apenas os n\u00fameros \u00edmpares, pulando os pares.</li> </ol> <p>Restri\u00e7\u00e3o: use <code>bnez</code> para decidir se imprime ou n\u00e3o.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-6-contar-quantos-valores-sao-maiores-que-50","title":"Exerc\u00edcio 6 \u2014 Contar quantos valores s\u00e3o maiores que 50","text":"<p>Considere um vetor de 6 inteiros definido em <code>.data</code>, por exemplo:</p> <pre><code>.data\nvet: .word 10, 60, 51, 50, 100, 3\n</code></pre> <p>Fa\u00e7a um programa que:</p> <ol> <li> <p>Percorra o vetor com um loop (usando ponteiro + <code>addi</code> de 4 em 4).</p> </li> <li> <p>Para cada elemento:</p> </li> <li> <p>compare se o valor \u00e9 maior que 50</p> </li> <li> <p>se for, incremente um contador (por exemplo, <code>t2</code>)</p> </li> <li> <p>Ao final, tenha em <code>t2</code> o n\u00famero de elementos maiores que 50.</p> </li> <li> <p>Imprima esse total usando a syscall de inteiro (c\u00f3digo 1 em <code>a7</code>).</p> </li> </ol> <p>Sugest\u00e3o: Use <code>blt</code> ou <code>bgt</code> (pseudo-instru\u00e7\u00e3o) para implementar a compara\u00e7\u00e3o <code>valor &gt; 50</code>.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-7-loop-ate-encontrar-zero-sentinela","title":"Exerc\u00edcio 7 \u2014 Loop at\u00e9 encontrar zero (sentinela)","text":"<p>Crie um vetor terminado em 0, por exemplo:</p> <pre><code>.data\nvalores: .word 3, -1, 7, 9, 0, 5\n</code></pre> <p>Escreva um programa que:</p> <ol> <li> <p>Percorra o vetor do come\u00e7o at\u00e9 encontrar o valor 0.</p> </li> <li> <p>Para cada valor diferente de 0:</p> </li> <li> <p>some o valor em um acumulador (<code>t2</code>, por exemplo)</p> </li> <li> <p>avance para o pr\u00f3ximo elemento</p> </li> <li> <p>Pare o loop assim que encontrar 0, usando <code>beqz</code> ou <code>bnez</code> com o valor lido.</p> </li> <li> <p>Imprima a soma acumulada.</p> </li> </ol>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-8-desafio-funcao-sinal","title":"Exerc\u00edcio 8 (desafio) \u2014 Fun\u00e7\u00e3o sinal","text":"<p>Implemente uma \u201cfun\u00e7\u00e3o de sinal\u201d em assembly:</p> <ul> <li>Entrada: um n\u00famero em <code>a0</code></li> <li>Sa\u00edda: em <code>a0</code></li> </ul> <p>Defini\u00e7\u00e3o:</p> <ul> <li>se <code>a0 &lt; 0</code>, deve retornar <code>-1</code></li> <li>se <code>a0 == 0</code>, deve retornar <code>0</code></li> <li>se <code>a0 &gt; 0</code>, deve retornar <code>1</code></li> </ul> <p>Regras:</p> <ol> <li> <p>Implemente isso como um bloco de c\u00f3digo com r\u00f3tulo, por exemplo <code>sinal:</code>.</p> </li> <li> <p>Use apenas:</p> </li> <li> <p><code>blt</code></p> </li> <li><code>beq</code></li> <li><code>li</code></li> <li> <p><code>j</code></p> </li> <li> <p>No <code>main</code>, teste v\u00e1rios valores chamando esse bloco de c\u00f3digo (voc\u00ea pode s\u00f3 \u201csimular\u201d a chamada colocando valores em <code>a0</code> e fazendo <code>j sinal</code> \u2192 depois usando outro r\u00f3tulo para voltar).</p> </li> </ol>"},{"location":"modulos/modulo%204/mod4.5_saltos/","title":"M\u00f3dulo 4 \u2014 Saltos","text":"<p>(<code>j</code>, <code>jal</code>, <code>jalr</code>)</p> <p>Neste m\u00f3dulo voc\u00ea vai aprender como o RISC-V (RISC-V = Reduced Instruction Set Computer \u2013 Five) realiza saltos (jumps) \u2014 mudan\u00e7as expl\u00edcitas no fluxo do programa.</p> <p>Saltos s\u00e3o essenciais para:</p> <ul> <li>loops</li> <li>fun\u00e7\u00f5es</li> <li>desvios condicionais</li> <li>chamadas e retornos entre trechos de c\u00f3digo</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#1-o-que-e-um-salto","title":"1. O que \u00e9 um salto?","text":"<p>Um salto (jump) \u00e9 uma instru\u00e7\u00e3o que altera o PC (Program Counter \u2014 contador de programa), ou seja, o endere\u00e7o da pr\u00f3xima instru\u00e7\u00e3o a ser executada.</p> <p>Em vez de seguir a execu\u00e7\u00e3o linear (linha ap\u00f3s linha), o processador:</p> <p>\u201cpula\u201d para outro endere\u00e7o de c\u00f3digo, normalmente marcado por um r\u00f3tulo (label).</p> <p>Ao contr\u00e1rio das instru\u00e7\u00f5es de desvio condicional (<code>beq</code>, <code>bne</code>, etc.), os saltos deste m\u00f3dulo s\u00e3o incondicionais: sempre acontecem.</p> <p>As tr\u00eas instru\u00e7\u00f5es principais s\u00e3o:</p> <ul> <li><code>j</code> \u2014 salto incondicional simples (pseudo-instru\u00e7\u00e3o)</li> <li><code>jal</code> \u2014 salto que guarda o endere\u00e7o de retorno</li> <li><code>jalr</code> \u2014 salto indireto via registrador (endere\u00e7os din\u00e2micos)</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#2-a-pseudo-instrucao-j-jump","title":"2. A pseudo-instru\u00e7\u00e3o <code>j</code> \u2014 jump","text":"<p><code>j</code> (jump) \u00e9 uma pseudo-instru\u00e7\u00e3o de salto incondicional.</p> <p>Pseudo-instru\u00e7\u00e3o \u00e9 uma \u201cinstru\u00e7\u00e3o de mentira\u201d fornecida pelo montador (assembler): ela n\u00e3o existe no hardware, mas \u00e9 automaticamente traduzida para uma ou mais instru\u00e7\u00f5es reais.</p> <p>No caso de <code>j</code>, o montador converte:</p> <pre><code>j label\n</code></pre> <p>para:</p> <pre><code>jal x0, label\n</code></pre> <p>onde:</p> <ul> <li><code>jal</code> = <code>jal</code> (jump and link), instru\u00e7\u00e3o real que faz salto e guarda endere\u00e7o de retorno</li> <li><code>x0</code> \u00e9 o registrador que sempre vale 0; como o retorno \u00e9 guardado em <code>x0</code>, ele \u00e9 descartado</li> </ul> <p>Em portugu\u00eas simples:</p> <p><code>j label</code> = \u201cpula para <code>label</code> e n\u00e3o guarda retorno\u201d.</p> <p>Exemplo:</p> <pre><code>j loop      # sempre desvia para o r\u00f3tulo 'loop'\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#3-a-instrucao-jal-jump-and-link","title":"3. A instru\u00e7\u00e3o <code>jal</code> \u2014 jump and link","text":"<p><code>jal</code> (jump and link) \u00e9 uma instru\u00e7\u00e3o real da ISA RV32I (ISA = Instruction Set Architecture, arquitetura de conjunto de instru\u00e7\u00f5es).</p> <p>Ela faz duas coisas ao mesmo tempo:</p> <ol> <li>Salva o endere\u00e7o da pr\u00f3xima instru\u00e7\u00e3o em um registrador destino <code>rd</code>.</li> <li>Salta para o r\u00f3tulo indicado.</li> </ol> <p>Sintaxe:</p> <pre><code>jal rd, label\n</code></pre> <p>Significa:</p> <p><code>rd = endere\u00e7o_da_proxima_instru\u00e7\u00e3o</code> depois, PC = endere\u00e7o_do_label</p> <p>Uso t\u00edpico:</p> <ul> <li><code>rd</code> \u00e9 o registrador <code>ra</code> (return address), que \u00e9 o registrador de retorno padr\u00e3o (<code>x1</code>).</li> </ul> <p>Exemplo cl\u00e1ssico de chamada de fun\u00e7\u00e3o:</p> <pre><code>jal ra, funcao    # salva o endere\u00e7o de retorno em ra e pula para 'funcao'\n</code></pre> <p>Para retornar da fun\u00e7\u00e3o, usamos um salto indireto via <code>ra</code>:</p> <ul> <li>pseudo-instru\u00e7\u00e3o <code>ret</code></li> <li>ou a forma expl\u00edcita com <code>jalr</code></li> </ul> <p>Veremos isso a seguir.</p>"},{"location":"modulos/modulo%204/mod4.5_saltos/#4-a-instrucao-jalr-jump-and-link-register","title":"4. A instru\u00e7\u00e3o <code>jalr</code> \u2014 jump and link register","text":"<p><code>jalr</code> (jump and link register) \u00e9 a vers\u00e3o \u201cindireta\u201d de <code>jal</code>: em vez de pular para um label fixo, ela pula para um endere\u00e7o em um registrador.</p> <p>Sintaxe:</p> <pre><code>jalr rd, offset(rs1)\n</code></pre> <p>Significa:</p> <ol> <li><code>rd = endere\u00e7o_da_proxima_instru\u00e7\u00e3o</code></li> <li><code>PC = rs1 + offset</code></li> </ol> <p>Em palavras:</p> <p>Salta para o endere\u00e7o calculado como <code>rs1 + offset</code> e guarda o endere\u00e7o de retorno em <code>rd</code>.</p> <p>Usos comuns:</p> <ul> <li>retorno de fun\u00e7\u00e3o (via pseudo-instru\u00e7\u00e3o <code>ret</code>)</li> <li>saltos din\u00e2micos (tabelas de fun\u00e7\u00e3o, ponteiros de fun\u00e7\u00e3o, etc.)</li> </ul> <p>Exemplo de retorno \u201cpuro\u201d (sem guardar nada):</p> <pre><code>jalr x0, 0(ra)    # PC = ra + 0, n\u00e3o guarda retorno (rd = x0, descartado)\n</code></pre> <p>Essa \u00e9 justamente a forma que o montador usa para implementar a pseudo-instru\u00e7\u00e3o:</p> <pre><code>ret               # montador: jalr x0, 0(ra)\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#5-pseudo-instrucoes-relacionadas-jr-ret","title":"5. Pseudo-instru\u00e7\u00f5es relacionadas (<code>jr</code>, <code>ret</code>)","text":"<ul> <li><code>jr rd</code> (jump register)   Pula para o endere\u00e7o contido em <code>rd</code>, sem guardar retorno.   O montador expande:</li> </ul> <p><code>asm   jr rd          # pseudo</code></p> <p>para:</p> <p><code>asm   jalr x0, 0(rd) # salto indireto sem link (sem retorno)</code></p> <ul> <li><code>ret</code> (return)   Usada como retorno de fun\u00e7\u00e3o, padr\u00e3o da calling convention do RISC-V.</li> </ul> <p>O montador expande:</p> <p><code>asm   ret            # pseudo</code></p> <p>para:</p> <p><code>asm   jalr x0, 0(ra) # PC = ra, n\u00e3o guarda retorno</code></p> <p>onde:</p> <ul> <li><code>ra</code> (return address) \u00e9 o registrador de retorno (<code>x1</code>), definido na ABI   ABI = Application Binary Interface, conven\u00e7\u00e3o de chamada entre fun\u00e7\u00f5es.</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#6-exemplos-completos","title":"6. Exemplos completos","text":"<p>Nesta se\u00e7\u00e3o, al\u00e9m de <code>j</code>, <code>jal</code> e <code>jalr</code>, aparecem algumas instru\u00e7\u00f5es e diretivas:</p> <ul> <li><code>li rd, imm</code> \u2014 <code>li</code> (load immediate): carrega o valor imediato <code>imm</code> no registrador <code>rd</code>.   Ex.: <code>li t0, 0</code> coloca 0 em <code>t0</code>.</li> <li><code>addi rd, rs1, imm</code> \u2014 <code>addi</code> (add immediate): soma imediato a registrador.   Ex.: <code>addi t0, t0, 1</code> \u2192 <code>t0 = t0 + 1</code>.</li> <li><code>blt rs1, rs2, label</code> \u2014 <code>blt</code> (branch if less than): desvia se <code>rs1 &lt; rs2</code>.</li> <li><code>.text</code> \u2014 in\u00edcio da sess\u00e3o de c\u00f3digo (onde ficam instru\u00e7\u00f5es execut\u00e1veis).</li> <li><code>.data</code> \u2014 in\u00edcio da sess\u00e3o de dados (vari\u00e1veis, strings, etc.).</li> <li><code>.globl main</code> \u2014 torna <code>main</code> vis\u00edvel como ponto de entrada.</li> <li><code>.asciz</code> \u2014 string ASCII terminada em byte zero (<code>\\0</code>).</li> <li><code>la rd, label</code> \u2014 <code>la</code> (load address): pseudo-instru\u00e7\u00e3o que carrega o endere\u00e7o do r\u00f3tulo <code>label</code> em <code>rd</code>.</li> <li><code>ecall</code> \u2014 environment call: dispara uma syscall configurada em <code>a7</code>.</li> <li><code>a7</code> \u2014 registrador que indica qual syscall ser\u00e1 chamada (no RARS).</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#61-exemplo-simples-usando-j","title":"6.1 Exemplo simples usando <code>j</code>","text":"<p>Loop que incrementa um contador at\u00e9 5 usando <code>j</code> para voltar:</p> <pre><code>.text\n.globl main\n\nmain:\n    li t0, 0                # li (load immediate): t0 = 0\n\nloop:\n    addi t0, t0, 1          # addi (add immediate): t0 = t0 + 1\n\n    li t1, 5                # t1 = 5\n    blt t0, t1, loop        # blt (branch if less than): se t0 &lt; 5, volta pro r\u00f3tulo 'loop'\n\n    # chegou aqui quando t0 &gt;= 5\nfim:\n    li a7, 93               # li: a7 = 93 \u2192 syscall exit2 (encerrar programa)\n    ecall                   # ecall (environment call): executa a syscall\n</code></pre> <p>Vers\u00e3o com <code>j</code> para loop incondicional:</p> <pre><code>.text\n.globl main\n\nmain:\n    li t0, 0\n\nloop:\n    addi t0, t0, 1          # t0++\n    j loop                  # j (jump): volta para o r\u00f3tulo 'loop' para sempre (loop infinito)\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#62-funcao-simples-usando-jal-e-ret","title":"6.2 Fun\u00e7\u00e3o simples usando <code>jal</code> e <code>ret</code>","text":"<p>Programa que chama uma fun\u00e7\u00e3o <code>ola</code> que imprime uma mensagem:</p> <pre><code>.data\nmsg: .asciz \"Ola!\\n\"        # .asciz: string terminada em 0\n\n.text\n.globl main\n\nmain:\n    jal ra, ola             # jal (jump and link): salva retorno em ra e salta para 'ola'\n\n    li a7, 93               # exit2\n    ecall\n\nola:\n    la a0, msg              # la (load address): a0 = endere\u00e7o de 'msg'\n    li a7, 4                # 4 = syscall print_string\n    ecall                   # imprime \"Ola!\\n\"\n\n    ret                     # ret: jalr x0, 0(ra) \u2192 volta para depois do jal em main\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#63-chamadas-aninhadas-com-jal-e-ret","title":"6.3 Chamadas aninhadas com <code>jal</code> e <code>ret</code>","text":"<p>Aqui vemos <code>main</code> chamando <code>A</code>, que chama <code>B</code>, que chama <code>C</code>:</p> <pre><code>.text\n.globl main\n\nmain:\n    jal ra, A               # chama A\n    li a7, 93               # exit2\n    ecall\n\nA:\n    jal ra, B               # chama B\n    ret                     # retorna para main\n\nB:\n    jal ra, C               # chama C\n    ret                     # retorna para A\n\nC:\n    ret                     # retorna para B\n</code></pre> <p>Em cada n\u00edvel, o endere\u00e7o de retorno \u00e9 automaticamente gerenciado em <code>ra</code>, de acordo com a conven\u00e7\u00e3o de chamada (ABI).</p>"},{"location":"modulos/modulo%204/mod4.5_saltos/#64-uso-de-jalr-para-saltos-indiretos","title":"6.4 Uso de <code>jalr</code> para saltos indiretos","text":"<p>Exemplo did\u00e1tico de salto indireto:</p> <pre><code>.data\nmsg: .asciz \"Salto indireto executado!\\n\"\n\n.text\n.globl main\n\nmain:\n    la t0, destino          # la: t0 recebe o endere\u00e7o do r\u00f3tulo 'destino'\n    jalr ra, 0(t0)          # jalr: salva retorno em ra e salta para endere\u00e7o em t0\n                            # ou seja, salta para 'destino'\n\n    li a7, 93               # exit2\n    ecall\n\ndestino:\n    la a0, msg              # a0 = endere\u00e7o da string\n    li a7, 4                # 4 = print_string\n    ecall                   # imprime \"Salto indireto executado!\\n\"\n    ret                     # volta para depois do jalr em main\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#7-comparacao-entre-j-jal-e-jalr","title":"7. Compara\u00e7\u00e3o entre <code>j</code>, <code>jal</code> e <code>jalr</code>","text":"Instru\u00e7\u00e3o Tipo de salto Guarda endere\u00e7o de retorno? Destino \u00e9 label fixo? Destino via registrador? <code>j</code> incondicional \u274c n\u00e3o \u2714 sim \u274c n\u00e3o <code>jal</code> incondicional \u2714 sim (em <code>rd</code>) \u2714 sim \u274c n\u00e3o <code>jalr</code> incondicional \u2714 sim (em <code>rd</code>) \u274c n\u00e3o \u2714 sim (<code>rs1 + offset</code>)"},{"location":"modulos/modulo%204/mod4.5_saltos/#8-exercicios-para-fixacao","title":"8. Exerc\u00edcios para fixa\u00e7\u00e3o","text":"<p>Use o RARS (RISC-V Assembler and Runtime Simulator) para montar e testar cada exerc\u00edcio. Sempre que usar syscalls:</p> <ul> <li>lembre que <code>a7</code> define qual syscall (por exemplo, <code>4</code> = print_string, <code>1</code> = print_int, <code>93</code> = exit2),</li> <li><code>a0</code> normalmente carrega o argumento (string ou inteiro),</li> <li>e <code>ecall</code> executa a syscall.</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#exercicio-1-saltos-simples-com-j","title":"Exerc\u00edcio 1 \u2014 Saltos simples com <code>j</code>","text":"<p>Crie um programa que:</p> <ol> <li>Imprima <code>\"A\\n\"</code>.</li> <li>Use <code>j</code> para pular diretamente para o r\u00f3tulo <code>C</code>.</li> <li>No meio do c\u00f3digo, coloque uma impress\u00e3o <code>\"B\\n\"</code> que n\u00e3o deve ser executada.</li> <li>No r\u00f3tulo <code>C</code>, imprima <code>\"C\\n\"</code>.</li> <li>Encerre o programa com a syscall <code>exit2</code> (c\u00f3digo 93 em <code>a7</code>).</li> </ol> <p>Dica de estrutura:</p> <pre><code>.data\nmsgA: .asciz \"A\\n\"\nmsgB: .asciz \"B\\n\"\nmsgC: .asciz \"C\\n\"\n\n.text\n.globl main\n\nmain:\n    # imprime A\n    # j C\n    # imprime B (n\u00e3o deve rodar)\nC:\n    # imprime C\n    # exit\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#exercicio-2-funcao-quadradon-com-jal-e-ret","title":"Exerc\u00edcio 2 \u2014 Fun\u00e7\u00e3o <code>quadrado(n)</code> com <code>jal</code> e <code>ret</code>","text":"<p>Implemente uma fun\u00e7\u00e3o <code>quadrado</code> em RISC-V que:</p> <ul> <li>recebe um inteiro <code>n</code> em <code>a0</code>,</li> <li>devolve <code>n * n</code> em <code>a0</code>.</li> </ul> <p>Regras:</p> <ol> <li>Em <code>main</code>, carregue um valor em <code>a0</code> (por exemplo, 7).</li> <li>Chame a fun\u00e7\u00e3o com <code>jal ra, quadrado</code>.</li> <li>Ao retornar, imprima o resultado com <code>print_int</code> (syscall 1).</li> <li>Use <code>ret</code> dentro da fun\u00e7\u00e3o para voltar.</li> </ol> <p>Sugest\u00e3o de l\u00f3gica da fun\u00e7\u00e3o:</p> <pre><code>quadrado:\n    # pode usar algum registrador tempor\u00e1rio t0\n    # a0 = a0 * a0  (pode ser soma repetida ou multiplica\u00e7\u00e3o se voc\u00ea j\u00e1 tiver)\n    ret\n</code></pre> <p>(Se ainda n\u00e3o viu multiplica\u00e7\u00e3o, pode usar somas sucessivas s\u00f3 pra fins did\u00e1ticos.)</p>"},{"location":"modulos/modulo%204/mod4.5_saltos/#exercicio-3-chamada-indireta-com-jalr","title":"Exerc\u00edcio 3 \u2014 Chamada indireta com <code>jalr</code>","text":"<p>Fa\u00e7a um programa que:</p> <ol> <li>Carregue em <code>t0</code> o endere\u00e7o de uma fun\u00e7\u00e3o <code>f1</code> usando <code>la</code>.</li> <li>Use <code>jalr ra, 0(t0)</code> para pular at\u00e9 <code>f1</code>.</li> <li>Dentro de <code>f1</code>, imprima uma mensagem, por exemplo <code>\"Chamado por jalr!\\n\"</code>.</li> <li>Retorne com <code>ret</code>.</li> <li>Ao voltar em <code>main</code>, encerre o programa com <code>exit2</code>.</li> </ol> <p>Extens\u00e3o (opcional): crie duas fun\u00e7\u00f5es, <code>f1</code> e <code>f2</code>, e use uma vari\u00e1vel em <code>.data</code> para decidir, em tempo de execu\u00e7\u00e3o, para qual delas pular com <code>jalr</code>.</p>"},{"location":"modulos/modulo%204/mod4.5_saltos/#exercicio-4-loop-reescrito-apenas-com-j","title":"Exerc\u00edcio 4 \u2014 Loop reescrito apenas com <code>j</code>","text":"<p>Pegue um loop que use <code>blt</code> ou <code>bne</code> e reescreva para usar apenas saltos incondicionais e compara\u00e7\u00f5es manuais.</p> <p>Exemplo em C:</p> <pre><code>for (i = 0; i &lt; 5; i++) {\n    // corpo\n}\n</code></pre> <p>Sugerido em assembly:</p> <ol> <li>Iniciar <code>i = 0</code> em <code>t0</code>.</li> <li>No in\u00edcio do loop, comparar <code>i</code> com 5.</li> <li>Se <code>i &gt;= 5</code>, saltar para o fim usando <code>j</code>.</li> <li>Caso contr\u00e1rio, executar o corpo.</li> <li>Incrementar <code>i</code> e usar <code>j</code> para voltar ao teste.</li> </ol> <p>Tente evitar <code>blt</code> e reproduzir a l\u00f3gica usando:</p> <ul> <li><code>bge</code> (se j\u00e1 tiver visto) ou</li> <li>compara\u00e7\u00f5es equivalentes e saltos com <code>j</code>.</li> </ul>"}]}