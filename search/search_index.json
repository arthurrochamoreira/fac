{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":""},{"location":"#fac","title":"FAC","text":"<p>Documenta\u00e7\u00e3o pessoal sobre Fundamentos de Arquitetura de Computadores, desenvolvida como apoio aos estudos da disciplina cursada na gradua\u00e7\u00e3o em Engenharia de Software.</p>"},{"location":"mod1/","title":"Modulo 1 - Introdu\u00e7\u00e3o","text":""},{"location":"mod1/#1-o-que-e-risc-v","title":"1. O que \u00e9 RISC-V?","text":"<p>RISC-V \u00e9 uma arquitetura de conjunto de instru\u00e7\u00f5es (ISA \u2014 Instruction Set Architecture). Uma ISA \u00e9 o \u201cvocabul\u00e1rio\u201d que o processador entende: as opera\u00e7\u00f5es b\u00e1sicas que ele sabe executar.</p> <ul> <li>RISC (Reduced Instruction Set Computer) = arquitetura com poucas instru\u00e7\u00f5es, simples e r\u00e1pidas.</li> <li>V = quinta gera\u00e7\u00e3o dessa fam\u00edlia RISC.</li> <li>RV32I = vers\u00e3o de 32 bits (32 = largura dos registradores) com o conjunto b\u00e1sico de instru\u00e7\u00f5es inteiras (I = Integer).</li> </ul> <p>Um processador RISC-V s\u00f3 entende opera\u00e7\u00f5es fundamentais, como:</p> <ul> <li>mover valores entre registradores (pequenas mem\u00f3rias internas do processador)</li> <li>ler/escrever na mem\u00f3ria</li> <li>fazer opera\u00e7\u00f5es aritm\u00e9ticas</li> <li>saltar para outro ponto do c\u00f3digo</li> </ul>"},{"location":"mod1/#observacao-importante","title":"Observa\u00e7\u00e3o importante","text":"<p>Os registradores possuem apelidos educativos (<code>a0</code>, <code>t0</code>, <code>s0</code> etc.), mas internamente eles continuam sendo <code>x0</code>, <code>x1</code>, \u2026, <code>x31</code>. Por exemplo:</p> <ul> <li><code>a0</code> = <code>x10</code></li> <li><code>a7</code> = <code>x17</code></li> <li><code>t0</code> = <code>x5</code></li> </ul> <p>Isso aparece no painel \u201cRegisters\u201d do RARS.</p>"},{"location":"mod1/#2-o-que-e-o-rars","title":"2. O que \u00e9 o RARS?","text":"<p>O RARS (RISC-V Assembler and Runtime Simulator) \u00e9 um simulador, ou seja:</p> <p>Um programa que imita um processador RISC-V para permitir que voc\u00ea execute c\u00f3digo sem ter o hardware real.</p> <p>Ele funciona assim:</p> <ol> <li>Voc\u00ea escreve um arquivo <code>.asm</code>    (arquivo contendo c\u00f3digo em assembly, a linguagem textual da ISA).</li> <li>O RARS monta o c\u00f3digo    (assembler = traduz para instru\u00e7\u00f5es bin\u00e1rias reais).</li> <li>O RARS executa e mostra o que acontece nos registradores e na mem\u00f3ria.</li> </ol> <p>Al\u00e9m disso, o RARS oferece syscalls (system calls): servi\u00e7os prontos como imprimir texto ou ler n\u00fameros do usu\u00e1rio.</p>"},{"location":"mod1/#3-registradores-sua-caixa-de-ferramentas","title":"3. Registradores: sua caixa de ferramentas","text":"<p>Um registrador \u00e9 uma pequena \u00e1rea de armazenamento dentro do processador. \u00c9 muito mais r\u00e1pido acessar registradores do que acessar mem\u00f3ria.</p> <p>O RISC-V possui 32 registradores inteiros, de <code>x0</code> a <code>x31</code>, cada um com um apelido:</p> Nome Uso <code>x0</code> sempre cont\u00e9m o valor 0 <code>a0\u2013a7</code> argumentos de fun\u00e7\u00f5es e syscalls (argument registers) <code>t0\u2013t6</code> tempor\u00e1rios (temporary registers) <code>s0\u2013s11</code> vari\u00e1veis preservadas (saved registers) <code>sp</code> ponteiro da pilha (stack pointer) <code>ra</code> endere\u00e7o de retorno (return address) <p>Para o Hello World utilizamos principalmente:</p> <ul> <li><code>a0</code> \u2014 registrador que cont\u00e9m o argumento da syscall</li> <li><code>a7</code> \u2014 registrador que cont\u00e9m o c\u00f3digo da syscall</li> </ul>"},{"location":"mod1/#4-formato-basico-das-instrucoes","title":"4. Formato b\u00e1sico das instru\u00e7\u00f5es","text":"<p>Uma instru\u00e7\u00e3o \u00e9 um comando da ISA. No RV32I, muitos comandos seguem o formato:</p> <pre><code>instru\u00e7\u00e3o destino, fonte1, fonte2\n</code></pre> <p>Exemplos:</p> <pre><code>add t0, t1, t2   # add = soma: t0 recebe t1 + t2\nli a0, 5         # li = load immediate: coloca 5 dentro de a0\nla a0, msg       # la = load address: carrega o endere\u00e7o do r\u00f3tulo msg\nlw t1, 0(t0)     # lw = load word: l\u00ea 4 bytes da mem\u00f3ria no endere\u00e7o t0\n</code></pre>"},{"location":"mod1/#nota-tecnica","title":"Nota t\u00e9cnica","text":"<p>No RISC-V, todos os endere\u00e7os se referem a 1 byte (mem\u00f3ria byte-addressable). Um <code>lw</code> l\u00ea 4 bytes a partir daquele endere\u00e7o.</p>"},{"location":"mod1/#5-pseudo-instrucoes","title":"5. Pseudo-instru\u00e7\u00f5es","text":"<p>O montador do RARS fornece pseudo-instru\u00e7\u00f5es, que n\u00e3o existem no hardware real, mas tornam o c\u00f3digo mais f\u00e1cil de escrever:</p> <ul> <li><code>li</code> \u2014 load immediate: carrega um valor imediato</li> <li><code>la</code> \u2014 load address: carrega o endere\u00e7o de um r\u00f3tulo</li> <li><code>mv</code> \u2014 move: copia o valor de um registrador para outro</li> </ul> <p>O montador converte essas pseudo-instru\u00e7\u00f5es em instru\u00e7\u00f5es reais RV32I durante a montagem.</p>"},{"location":"mod1/#6-sessoes-do-programa","title":"6. Sess\u00f5es do programa","text":"<p>Um arquivo <code>.asm</code> \u00e9 dividido em sess\u00f5es:</p>"},{"location":"mod1/#data-dados-estaticos-na-memoria","title":"<code>.data</code> \u2014 dados est\u00e1ticos na mem\u00f3ria","text":"<pre><code>.data\nmsg: .asciz \"Hello, World!\\n\"\n</code></pre> <p><code>.asciz</code> define uma string terminada em byte zero (<code>\\0</code>). Isso \u00e9 importante porque a syscall 4 (print_string) espera exatamente esse formato.</p>"},{"location":"mod1/#text-codigo-executavel","title":"<code>.text</code> \u2014 c\u00f3digo execut\u00e1vel","text":"<pre><code>.text\n.globl main     # .globl = global: torna 'main' o ponto de entrada\n</code></pre> <p>A execu\u00e7\u00e3o come\u00e7a no r\u00f3tulo <code>main:</code>.</p>"},{"location":"mod1/#7-como-o-rars-imprime-syscalls","title":"7. Como o RARS imprime (syscalls)","text":"<p>Uma syscall (system call) \u00e9 uma chamada ao sistema operacional do simulador para executar a\u00e7\u00f5es prontas, como imprimir ou ler entradas.</p>"},{"location":"mod1/#para-chamar-uma-syscall","title":"Para chamar uma syscall:","text":"<ol> <li>Coloque o c\u00f3digo da syscall em <code>a7</code></li> <li>Coloque o argumento em <code>a0</code></li> <li>Execute <code>ecall</code> (environment call)</li> </ol> <p>Resumo perfeito:</p> <p><code>a7</code> escolhe o servi\u00e7o, <code>a0</code> fornece o dado, <code>ecall</code> executa.</p>"},{"location":"mod1/#syscalls-usadas-no-hello-world","title":"Syscalls usadas no Hello World:","text":"C\u00f3digo Fun\u00e7\u00e3o <code>4</code> imprimir string (print_string) <code>10</code> encerrar o programa (exit2) <p>Exemplo:</p> <pre><code>la a0, msg     # a0 = endere\u00e7o da string\nli a7, 4       # a7 = c\u00f3digo de print_string\necall          # dispara a syscall\n</code></pre>"},{"location":"mod1/#8-montando-tudo-hello-world","title":"8. Montando tudo: Hello World","text":"<pre><code>    .data                           # sess\u00e3o de dados\nmsg: .asciz \"Hello, World!\\n\"       # string terminada em zero\n\n    .text                           # sess\u00e3o de c\u00f3digo\n    .globl main                     # torna 'main' vis\u00edvel\n\nmain:\n    la a0, msg                      # carrega o endere\u00e7o da string msg em a0\n    li a7, 4                        # syscall 4 = print_string\n    ecall                           # imprime\n\n    li a0, 0                        # c\u00f3digo de sa\u00edda (0 = sucesso)\n    li a7, 10                       # syscall 93 = exit2\n    ecall                           # encerra\n</code></pre>"},{"location":"modulos/modulo%201/mod1/","title":"M\u00f3dulo 1 \u2014 Introdu\u00e7\u00e3o ao RISC-V","text":"<p>Este m\u00f3dulo apresenta a base conceitual necess\u00e1ria para entender como funciona um programa em assembly RISC-V: o que \u00e9 uma ISA, por que come\u00e7amos pelo conjunto RV32I, como funciona o simulador RARS e como o processador enxerga mem\u00f3ria, dados e instru\u00e7\u00f5es.</p>"},{"location":"modulos/modulo%201/mod1/#1-o-que-e-risc-v","title":"1. O que \u00e9 RISC-V?","text":"<p>RISC-V \u00e9 uma arquitetura de conjunto de instru\u00e7\u00f5es (ISA \u2014 Instruction Set Architecture). Uma ISA \u00e9 o conjunto de comandos que o processador entende no n\u00edvel mais baixo, como:</p> <ul> <li>somar valores</li> <li>carregar dados da mem\u00f3ria</li> <li>desviar para outro ponto do c\u00f3digo</li> <li>comparar n\u00fameros</li> <li>executar opera\u00e7\u00f5es l\u00f3gicas</li> </ul> <p>O termo RISC significa Reduced Instruction Set Computer: uma filosofia de projeto que preza por instru\u00e7\u00f5es simples, diretas e r\u00e1pidas.</p> <p>O \u201cV\u201d indica que esta \u00e9 a quinta gera\u00e7\u00e3o da fam\u00edlia RISC dessa linha de pesquisa.</p>"},{"location":"modulos/modulo%201/mod1/#2-o-que-e-rv32i-e-por-que-comecamos-por-ele","title":"2. O que \u00e9 RV32I e por que come\u00e7amos por ele","text":"<p>A sigla RV32I significa:</p> <ul> <li>RV \u2014 RISC-V</li> <li>32 \u2014 registradores e endere\u00e7os possuem 32 bits</li> <li>I \u2014 conjunto b\u00e1sico de instru\u00e7\u00f5es inteiras (Integer)</li> </ul> <p>O RV32I \u00e9:</p> <ul> <li>o menor conjunto completo e funcional da ISA</li> <li>suficiente para aprender todos os fundamentos de assembly</li> <li>compat\u00edvel com praticamente qualquer simulador</li> <li>limpo, simples e ideal para iniciantes</li> </ul> <p>Tudo que voc\u00ea aprender aqui funciona em qualquer implementa\u00e7\u00e3o real de RISC-V, incluindo microcontroladores, processadores embarcados e sistemas operacionais reais.</p>"},{"location":"modulos/modulo%201/mod1/#3-o-que-e-um-simulador-rars","title":"3. O que \u00e9 um simulador (RARS)","text":"<p>Para programar em RISC-V sem comprar um chip f\u00edsico, usamos o RARS (RISC-V Assembler and Runtime Simulator).</p> <p>O RARS permite:</p>"},{"location":"modulos/modulo%201/mod1/#31-montar-o-codigo","title":"3.1 Montar o c\u00f3digo","text":"<p>O montador (assembler) converte o c\u00f3digo <code>.asm</code> em instru\u00e7\u00f5es bin\u00e1rias reais da ISA.</p>"},{"location":"modulos/modulo%201/mod1/#32-executar-o-programa","title":"3.2 Executar o programa","text":"<p>O simulador roda o bin\u00e1rio e mostra o fluxo do programa.</p>"},{"location":"modulos/modulo%201/mod1/#33-inspecionar-registradores-e-memoria","title":"3.3 Inspecionar registradores e mem\u00f3ria","text":"<p>\u00c9 poss\u00edvel acompanhar:</p> <ul> <li>valores nos registradores (<code>a0</code>, <code>t0</code>, <code>s0</code>\u2026)</li> <li>conte\u00fado da mem\u00f3ria em v\u00e1rias representa\u00e7\u00f5es</li> <li>execu\u00e7\u00e3o passo a passo (modo step)</li> </ul>"},{"location":"modulos/modulo%201/mod1/#4-estrutura-geral-de-um-programa-asm","title":"4. Estrutura geral de um programa <code>.asm</code>","text":"<p>Um programa t\u00edpico possui duas sess\u00f5es principais:</p>"},{"location":"modulos/modulo%201/mod1/#41-sessao-data-data-section","title":"4.1 Sess\u00e3o <code>.data</code> (data section)","text":"<p>Armazena dados est\u00e1ticos, como n\u00fameros, vetores e strings.</p> <p>Exemplo:</p> <pre><code>.data\nmsg: .asciz \"Hello!\\n\"\nx:   .word 42\n</code></pre>"},{"location":"modulos/modulo%201/mod1/#42-sessao-text-text-section","title":"4.2 Sess\u00e3o <code>.text</code> (text section)","text":"<p>Armazena o c\u00f3digo execut\u00e1vel.</p> <p>Exemplo:</p> <pre><code>.text\n.globl main           # .globl (global): define o ponto de entrada\n\nmain:\n    li a0, 42         # li = load immediate: coloca 42 em a0\n    li a7, 1          # c\u00f3digo da syscall print_int\n    ecall             # ecall = environment call\n</code></pre>"},{"location":"modulos/modulo%201/mod1/#43-labels","title":"4.3 Labels","text":"<p>Um label (r\u00f3tulo) \u00e9 um nome que representa um endere\u00e7o na mem\u00f3ria.</p> <p>Exemplo:</p> <pre><code>msg:\n</code></pre> <p>Esse nome representa o endere\u00e7o do primeiro byte da string <code>\"Hello!\\n\"</code>.</p> <p>Labels funcionam como ponteiros, iguais aos usados em C.</p>"},{"location":"modulos/modulo%201/mod1/#5-como-o-processador-enxerga-dados-e-instrucoes","title":"5. Como o processador enxerga dados e instru\u00e7\u00f5es","text":"<p>Para o processador, tudo \u00e9 apenas mem\u00f3ria.</p> <p>Ele n\u00e3o distingue \u201ctexto\u201d, \u201cn\u00fameros\u201d, \u201cstrings\u201d, \u201cinstru\u00e7\u00f5es\u201d ou \u201cvari\u00e1veis\u201d de forma sem\u00e2ntica.</p>"},{"location":"modulos/modulo%201/mod1/#a-memoria-e-uma-grande-linha-de-bytes","title":"A mem\u00f3ria \u00e9 uma grande linha de bytes:","text":"<pre><code>[00][04][3F][10][7A][FF][00]...\n</code></pre> <p>O processador interpreta esses bytes de acordo com o contexto:</p> <ul> <li>Em <code>.text</code>: interpreta os bytes como instru\u00e7\u00f5es.</li> <li>Em <code>.data</code>: interpreta como dados (palavras, strings, vetores etc.).</li> </ul> <p>Quando voc\u00ea escreve:</p> <pre><code>add t0, t1, t2\n</code></pre> <p>Isso \u00e9 convertido em 32 bits que o hardware interpreta como:</p> <p>\"some o registrador t1 com o registrador t2 e coloque o resultado em t0\".</p> <p>Quando voc\u00ea escreve:</p> <pre><code>.word 42\n</code></pre> <p>Isso apenas grava 42 em bin\u00e1rio na mem\u00f3ria \u2014 n\u00e3o h\u00e1 \u201ctipo inteiro\u201d, apenas bits.</p> <p>O comportamento \u00e9 definido pela instru\u00e7\u00e3o que l\u00ea esses bits.</p>"},{"location":"modulos/modulo%201/mod1/#6-como-o-processador-executa-um-programa","title":"6. Como o processador executa um programa","text":"<p>O processador possui:</p> <ul> <li>PC (program counter):   registrador que aponta para a pr\u00f3xima instru\u00e7\u00e3o a ser executada.</li> </ul> <p>O ciclo b\u00e1sico \u00e9:</p> <ol> <li>Ler a instru\u00e7\u00e3o apontada por PC</li> <li>Executar a instru\u00e7\u00e3o</li> <li>Avan\u00e7ar o PC (ou fazer um salto no caso de branches)</li> <li>Repetir</li> </ol> <p>Esse ciclo acontece milh\u00f5es de vezes por segundo.</p>"},{"location":"modulos/modulo%202/mod2/","title":"M\u00f3dulo 2 \u2014 Sess\u00f5es","text":"<p>Neste m\u00f3dulo voc\u00ea aprende:</p> <ul> <li>para que serve a sess\u00e3o <code>.data</code></li> <li>como funcionam labels (r\u00f3tulos) como ponteiros</li> <li>como declarar strings com <code>.string</code> e <code>.asciz</code></li> <li>como funciona a sess\u00e3o <code>.text</code></li> <li>como definir o ponto de entrada (<code>main:</code>)</li> <li>como carregar endere\u00e7os com <code>la</code> (load address)</li> </ul>"},{"location":"modulos/modulo%202/mod2/#1-a-sessao-data-onde-ficam-os-dados-do-programa","title":"1. A sess\u00e3o <code>.data</code> \u2014 onde ficam os dados do programa","text":"<p>A diretiva <code>.data</code> (data section) indica ao montador que tudo abaixo dela deve ser colocado na \u00e1rea de dados do programa: uma regi\u00e3o de mem\u00f3ria reservada para valores est\u00e1ticos, como:</p> <ul> <li>n\u00fameros</li> <li>vetores</li> <li>constantes</li> <li>strings</li> </ul> <p>Exemplo simples:</p> <pre><code>.data\nnumero: .word 42\n</code></pre> <p>Aqui:</p> <ul> <li><code>.word</code> aloca 4 bytes</li> <li><code>numero</code> \u00e9 um label (r\u00f3tulo) representando o endere\u00e7o onde o valor 42 est\u00e1 guardado</li> </ul>"},{"location":"modulos/modulo%202/mod2/#2-labels-label-como-ponteiros","title":"2. Labels (label:) como ponteiros","text":"<p>Um label (r\u00f3tulo) \u00e9 apenas um nome associado a um endere\u00e7o na mem\u00f3ria.</p> <p>Ele funciona como um ponteiro em C:</p> <pre><code>label  -----&gt;  endere\u00e7o onde o dado est\u00e1 colocado\n</code></pre> <p>Exemplo:</p> <pre><code>msg: .string \"Ol\u00e1\"\n</code></pre> <p>O label <code>msg</code> aponta para o primeiro byte da string.</p> <p>O label n\u00e3o cont\u00e9m o valor. O label cont\u00e9m o endere\u00e7o onde o valor est\u00e1.</p> <p>Isso \u00e9 fundamental, porque instru\u00e7\u00f5es como <code>la</code> (load address) funcionam exatamente assim:</p> <pre><code>la a0, msg     # a0 recebe o endere\u00e7o da string 'msg'\n</code></pre>"},{"location":"modulos/modulo%202/mod2/#3-declarando-strings-string-e-asciz","title":"3. Declarando strings: <code>.string</code> e <code>.asciz</code>","text":"<p>Existem duas diretivas para declarar strings:</p>"},{"location":"modulos/modulo%202/mod2/#string-texto","title":"<code>.string \"texto\"</code>","text":"<p>A diretiva <code>.string</code> grava a sequ\u00eancia de caracteres sem byte nulo no final.</p> <p>Exemplo:</p> <pre><code>msg: .string \"Hello\"\n</code></pre> <p>Mem\u00f3ria:</p> <pre><code>48 65 6C 6C 6F   (sem 00)\n H  e  l  l  o\n</code></pre>"},{"location":"modulos/modulo%202/mod2/#asciz-texto","title":"<code>.asciz \"texto\"</code>","text":"<p>A diretiva <code>.asciz</code> (ASCII zero-terminated) grava a string seguida de um byte zero, exatamente como em C.</p> <p>Exemplo:</p> <pre><code>msg: .asciz \"Hello\"\n</code></pre> <p>Mem\u00f3ria:</p> <pre><code>48 65 6C 6C 6F 00\n H  e  l  l  o \\0\n</code></pre> <p>O byte zero final (<code>\\0</code>) \u00e9 obrigat\u00f3rio para syscalls como print_string no simulador RARS (RISC-V Assembler and Runtime Simulator).</p>"},{"location":"modulos/modulo%202/mod2/#4-a-sessao-text-onde-ficam-as-instrucoes","title":"4. A sess\u00e3o <code>.text</code> \u2014 onde ficam as instru\u00e7\u00f5es","text":"<p>A diretiva <code>.text</code> (code section) marca o in\u00edcio do c\u00f3digo execut\u00e1vel: todas as instru\u00e7\u00f5es do programa.</p> <p>Exemplo:</p> <pre><code>.text\n</code></pre> <p>Dentro dela ficam comandos como:</p> <ul> <li><code>li</code> (load immediate)</li> <li><code>la</code> (load address)</li> <li><code>lw</code> (load word)</li> <li><code>sw</code> (store word)</li> <li><code>add</code>, <code>sub</code></li> <li><code>ecall</code> (environment call)</li> </ul>"},{"location":"modulos/modulo%202/mod2/#5-o-ponto-de-entrada-main","title":"5. O ponto de entrada: <code>main:</code>","text":"<p>O RARS procura por um r\u00f3tulo espec\u00edfico para come\u00e7ar a execu\u00e7\u00e3o:</p> <pre><code>main:\n</code></pre> <p>Esse \u00e9 o entry point (ponto de entrada).</p> <p>Exemplo completo:</p> <pre><code>.text\n.globl main     # .globl (global): torna 'main' vis\u00edvel como ponto de entrada\n\nmain:\n    li a0, 5\n    li a7, 1\n    ecall\n</code></pre> <p>A diretiva <code>.globl</code> (global symbol) informa ao montador que este r\u00f3tulo deve ser acess\u00edvel como s\u00edmbolo externo \u2014 \u00e9 assim que o RARS sabe que <code>main</code> \u00e9 seu ponto de in\u00edcio.</p>"},{"location":"modulos/modulo%202/mod2/#6-carregar-enderecos-com-la-load-address","title":"6. Carregar endere\u00e7os com <code>la</code> (load address)","text":"<p>A pseudo-instru\u00e7\u00e3o <code>la</code> (load address) carrega o endere\u00e7o associado a um label em um registrador.</p> <p>\u00c9 uma pseudo-instru\u00e7\u00e3o, ou seja, n\u00e3o existe diretamente no hardware RV32I; o montador traduz <code>la</code> em uma sequ\u00eancia de instru\u00e7\u00f5es reais (<code>lui</code> + <code>addi</code>).</p> <p>Exemplo:</p> <pre><code>la a0, msg\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <p>Coloque no registrador <code>a0</code> o endere\u00e7o onde a string <code>msg</code> est\u00e1 armazenada.</p> <p>Isso \u00e9 fundamental, porque syscalls usam endere\u00e7os, n\u00e3o labels.</p>"},{"location":"modulos/modulo%202/mod2/#7-exemplo-completo-reunindo-tudo","title":"7. Exemplo completo reunindo tudo","text":"<pre><code>.data\nmsg: .asciz \"Ol\u00e1, RISC-V!\\n\"   # string terminada em 0\n\nnumero: .word 123              # valor armazenado em 4 bytes\n\n.text\n.globl main\n\nmain:\n    # Imprimir string\n    la a0, msg                 # load address: a0 recebe endere\u00e7o da string\n    li a7, 4                   # print_string\n    ecall\n\n    # Imprimir n\u00famero\n    lw a0, numero              # load word: a0 recebe valor em 'numero'\n    li a7, 1                   # print_int\n    ecall\n\n    # Encerrar\n    li a7, 93                  # exit2\n    ecall\n</code></pre>"},{"location":"modulos/modulo%203/mod3/","title":"M\u00f3dulo 3 \u2014 Registradores do RV32I","text":"<p>O conjunto RV32I possui 32 registradores inteiros, cada um com um papel definido pela ABI (Application Binary Interface). A ABI determina como fun\u00e7\u00f5es recebem argumentos, como retornam valores, quais registradores podem ser sobrescritos e quais devem ser preservados.</p> <p>Este m\u00f3dulo apresenta:</p> <ul> <li>as categorias de registradores (<code>a*</code>, <code>t*</code>, <code>s*</code>, <code>zero</code>)</li> <li>como funcionam no calling convention (conven\u00e7\u00e3o de chamada)</li> <li>por que usamos <code>a0</code>, <code>a7</code>, <code>t0</code> etc.</li> <li>o que \u00e9 o registrador <code>sp</code> e como ele forma a pilha</li> </ul>"},{"location":"modulos/modulo%203/mod3/#1-visao-geral-por-que-existem-tipos-diferentes-de-registradores","title":"1. Vis\u00e3o geral: por que existem tipos diferentes de registradores?","text":"<p>O RISC-V segue uma regra essencial:</p> <p>Cada registrador tem uma fun\u00e7\u00e3o espec\u00edfica na conven\u00e7\u00e3o de chamada. Isso permite que fun\u00e7\u00f5es cooperem entre si de forma consistente.</p> <p>Assim, todo programa \u2014 do menor ao maior \u2014 funciona com o mesmo protocolo.</p> <p>As categorias s\u00e3o:</p> Categoria Registradores Nome t\u00e9cnico Fun\u00e7\u00e3o principal <code>zero</code> <code>x0</code> registrador zero sempre cont\u00e9m 0 <code>a*</code> <code>a0\u2013a7</code> argument registers argumentos e retorno de fun\u00e7\u00f5es/syscalls <code>t*</code> <code>t0\u2013t6</code> temporary registers valores tempor\u00e1rios (n\u00e3o preservados) <code>s*</code> <code>s0\u2013s11</code> saved registers valores preservados entre chamadas <code>sp</code> <code>x2</code> stack pointer topo da pilha (stack) <code>ra</code> <code>x1</code> return address endere\u00e7o para onde retornar ap\u00f3s <code>jal</code> <p>Vamos detalhar cada categoria.</p>"},{"location":"modulos/modulo%203/mod3/#2-o-registrador-zero-x0","title":"2. O registrador <code>zero</code> (<code>x0</code>)","text":"<p><code>x0</code> \u00e9 um registrador somente leitura que sempre cont\u00e9m o valor 0.</p> <p>Ele \u00e9 \u00fatil para:</p> <ul> <li>compara\u00e7\u00f5es (<code>beq t0, x0, label</code>)</li> <li>gerar valores 0 sem gastar instru\u00e7\u00f5es (<code>addi t0, x0, 0</code>)</li> <li>confirmar igualdade (<code>bne t0, x0, continuar</code>)</li> </ul> <p>Como ele nunca muda, evita erros e economiza espa\u00e7o no c\u00f3digo.</p>"},{"location":"modulos/modulo%203/mod3/#3-registradores-a-argument-registers","title":"3. Registradores <code>a*</code> \u2014 Argument Registers","text":"<p>Os registradores <code>a0\u2013a7</code> s\u00e3o usados para:</p> <ol> <li>Passar argumentos para fun\u00e7\u00f5es</li> <li>Receber argumentos de syscalls</li> <li>Receber valores de retorno</li> </ol>"},{"location":"modulos/modulo%203/mod3/#31-retorno-de-funcao","title":"3.1 Retorno de fun\u00e7\u00e3o","text":"<p>Toda fun\u00e7\u00e3o retorna valores em:</p> <ul> <li><code>a0</code> \u2014 primeiro valor de retorno</li> <li><code>a1</code> \u2014 segundo, se necess\u00e1rio</li> </ul> <p>Exemplo:</p> <pre><code>li a0, 42        # argumento\njal ra, dobro    # chama fun\u00e7\u00e3o\n\n# a0 agora cont\u00e9m o retorno\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#4-registradores-t-temporary-registers","title":"4. Registradores <code>t*</code> \u2014 Temporary Registers","text":"<p>Os registradores <code>t0\u2013t6</code> (temporary registers) s\u00e3o tempor\u00e1rios:</p> <ul> <li>a fun\u00e7\u00e3o pode sobrescrev\u00ea-los livremente</li> <li>n\u00e3o precisam ser preservados na pilha</li> </ul> <p>Use <code>t*</code> para:</p> <ul> <li>contadores</li> <li>vari\u00e1veis tempor\u00e1rias</li> <li>c\u00e1lculos intermedi\u00e1rios</li> <li>ponteiros tempor\u00e1rios</li> <li>la\u00e7os simples</li> </ul> <p>Exemplo t\u00edpico:</p> <pre><code>li t0, 5\naddi t0, t0, 1    # t0 = 6\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#5-registradores-s-saved-registers","title":"5. Registradores <code>s*</code> \u2014 Saved Registers","text":"<p>Registradores <code>s0\u2013s11</code> (saved registers) s\u00e3o usados quando um valor precisa sobreviver a chamadas de fun\u00e7\u00e3o.</p> <p>Regra da ABI:</p> <p>Se uma fun\u00e7\u00e3o modificar um registrador <code>s*</code>, ela \u00e9 obrigada a salv\u00e1-lo na pilha e restaur\u00e1-lo antes de retornar.</p> <p>\u00c9 assim que se cria uma vari\u00e1vel \u201clocal\u201d persistente:</p> <pre><code>addi sp, sp, -4\nsw s0, 0(sp)\n\nli s0, 99      # usa s0 dentro da fun\u00e7\u00e3o\n\nlw s0, 0(sp)\naddi sp, sp, 4\nret\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#6-registrador-sp-stack-pointer","title":"6. Registrador <code>sp</code> \u2014 Stack Pointer","text":"<p><code>sp</code> (stack pointer) aponta para o topo da pilha.</p> <p>A pilha \u00e9 uma regi\u00e3o de mem\u00f3ria com comportamento LIFO (last in, first out).</p>"},{"location":"modulos/modulo%203/mod3/#61-como-a-pilha-cresce","title":"6.1 Como a pilha cresce","text":"<p>A pilha cresce para endere\u00e7os menores:</p> <pre><code>addi sp, sp, -16   # reserva 16 bytes\n</code></pre> <p>E diminui quando liberamos espa\u00e7o:</p> <pre><code>addi sp, sp, 16    # libera espa\u00e7o\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#para-que-serve-a-pilha","title":"Para que serve a pilha?","text":"<ul> <li>armazenar vari\u00e1veis locais</li> <li>guardar registradores <code>s*</code></li> <li>armazenar o endere\u00e7o de retorno (<code>ra</code>) quando fun\u00e7\u00f5es chamam outras</li> <li>suportar recurs\u00e3o</li> </ul>"},{"location":"modulos/modulo%203/mod3/#7-por-que-usamos-a0-a7-t0-no-programa","title":"7. Por que usamos <code>a0</code>, <code>a7</code>, <code>t0</code>\u2026 no programa?","text":"<p>Isso segue a ABI (Application Binary Interface), que define:</p> <ol> <li>Qual registrador carrega argumentos (<code>a0\u2013a7</code>)</li> <li>Qual registrador recebe retorno (<code>a0</code>)</li> <li>Quais registradores s\u00e3o tempor\u00e1rios (<code>t0\u2013t6</code>)</li> <li>Quais s\u00e3o preservados (<code>s0\u2013s11</code>)</li> <li>Qual registrador aponta a pilha (<code>sp</code>)</li> <li>Qual guarda o endere\u00e7o de retorno (<code>ra</code>)</li> </ol>"},{"location":"modulos/modulo%203/mod3/#exemplos-reais","title":"Exemplos reais:","text":""},{"location":"modulos/modulo%203/mod3/#71-syscalls","title":"7.1 Syscalls","text":"<p>A syscall \u00e9 executada quando:</p> <ul> <li><code>a7</code> cont\u00e9m o c\u00f3digo da syscall</li> <li><code>a0</code> cont\u00e9m o argumento</li> </ul> <p>Exemplo:</p> <pre><code>li a0, 123         # argumento\nli a7, 1           # print_int\necall\n</code></pre>"},{"location":"modulos/modulo%203/mod3/#72-funcoes","title":"7.2 Fun\u00e7\u00f5es","text":"<pre><code>li a0, 5\nli a1, 7\njal ra, soma       # soma(5,7)\n\n# a0 cont\u00e9m retorno\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/","title":"M\u00f3dulo 4.1. \u2014 Instru\u00e7\u00f5es de Imediato","text":"<p>As instru\u00e7\u00f5es de imediato s\u00e3o fundamentais no RISC-V (ISA \u2014 Instruction Set Architecture: conjunto de instru\u00e7\u00f5es que o processador entende), porque permitem trabalhar com valores constantes sem acessar a mem\u00f3ria.</p> <p>Neste m\u00f3dulo voc\u00ea vai ver:</p> <ul> <li>o que \u00e9 um imediato (immediate)</li> <li>como carregar um valor constante direto em um registrador com <code>li</code></li> <li>como somar um registrador com uma constante usando <code>addi</code></li> <li>como aplicar essas instru\u00e7\u00f5es em loops, aritm\u00e9tica e ponteiros</li> </ul>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#1-o-que-e-um-valor-imediato","title":"1. O que \u00e9 um \u201cvalor imediato\u201d?","text":"<p>Um imediato (immediate) \u00e9 um valor constante escrito diretamente na instru\u00e7\u00e3o, e n\u00e3o buscado da mem\u00f3ria.</p> <p>Exemplo conceitual:</p> <pre><code>addi t0, t0, 1     # addi (add immediate): soma o imediato 1 ao valor em t0 e guarda em t0\n</code></pre> <p>Aqui:</p> <ul> <li><code>t0</code> \u00e9 um registrador tempor\u00e1rio (temporary register)</li> <li><code>1</code> \u00e9 o imediato embutido na instru\u00e7\u00e3o</li> </ul> <p>Diferente de:</p> <pre><code>lw t0, 0(t1)       # lw (load word): carrega da mem\u00f3ria\n</code></pre> <p>onde o valor vem da mem\u00f3ria, n\u00e3o est\u00e1 \u201cdentro\u201d da instru\u00e7\u00e3o.</p>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#2-a-pseudo-instrucao-li-load-immediate","title":"2. A pseudo-instru\u00e7\u00e3o <code>li</code> \u2014 load immediate","text":"<p><code>li</code> (load immediate) \u00e9 uma pseudo-instru\u00e7\u00e3o do montador (n\u00e3o existe no hardware real RV32I) que carrega um valor imediato em um registrador.</p> <p>Sintaxe:</p> <pre><code>li rd, imediato\n</code></pre> <p>Significa:</p> <p>Colocar o valor constante <code>imediato</code> dentro do registrador <code>rd</code>.</p> <p>Exemplos:</p> <pre><code>li t0, 10           # li (load immediate): coloca o valor imediato 10 no registrador t0\nli a0, -5           # li (load immediate): coloca -5 em a0\nli s1, 2048         # li (load immediate): coloca 2048 em s1\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#como-o-montador-expande-li","title":"Como o montador expande <code>li</code>","text":"<p>Como <code>li</code> \u00e9 uma pseudo-instru\u00e7\u00e3o, o montador do RARS (RISC-V Assembler and Runtime Simulator) traduz para uma ou mais instru\u00e7\u00f5es reais, por exemplo:</p> <ul> <li>imediatos pequenos \u2192 <code>addi</code></li> <li>imediatos grandes \u2192 combina\u00e7\u00e3o de <code>lui</code> (load upper immediate) + <code>addi</code></li> </ul> <p>Voc\u00ea n\u00e3o precisa se preocupar com isso no come\u00e7o: use <code>li</code> livremente para carregar constantes.</p>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#3-a-instrucao-addi-add-immediate","title":"3. A instru\u00e7\u00e3o <code>addi</code> \u2014 add immediate","text":"<p><code>addi</code> (add immediate) \u00e9 uma instru\u00e7\u00e3o real do conjunto RV32I que soma o conte\u00fado de um registrador com um imediato de 12 bits (intervalo de -2048 at\u00e9 +2047).</p> <p>Sintaxe:</p> <pre><code>addi rd, rs1, imediato\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <p><code>rd = rs1 + imediato</code></p> <p>Exemplos:</p> <pre><code>addi t0, t0, 1      # addi (add immediate): t0 = t0 + 1  (incremento)\naddi t1, t1, -1     # addi (add immediate): t1 = t1 - 1  (decremento)\naddi a0, a0, 10     # addi (add immediate): a0 = a0 + 10\naddi t2, t0, 4      # addi (add immediate): t2 = t0 + 4\n</code></pre> <p>Se o imediato for grande demais para caber em 12 bits, voc\u00ea geralmente usa uma combina\u00e7\u00e3o de <code>li</code>, <code>lui</code> + <code>addi</code> \u2014 mas para a maioria dos exemplos iniciais, <code>addi</code> \u00e9 suficiente.</p>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#4-usos-comuns-de-li-e-addi","title":"4. Usos comuns de <code>li</code> e <code>addi</code>","text":""},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#41-inicializar-variaveis-em-registradores","title":"4.1 Inicializar \u201cvari\u00e1veis\u201d em registradores","text":"<pre><code>li t0, 0            # li (load immediate): inicializa t0 como contador com 0\nli t1, 10           # li (load immediate): define limite 10 em t1\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#42-criar-loops-com-incrementos-e-decrementos","title":"4.2 Criar loops com incrementos e decrementos","text":"<p>Aqui aparece <code>bne</code> (branch if not equal) pela primeira vez:</p> <ul> <li><code>bne rs1, rs2, label</code> desvia para <code>label</code> se <code>rs1 != rs2</code>.</li> </ul> <pre><code>li t0, 5            # t0 come\u00e7a em 5\n\nloop:\n    addi t0, t0, -1 # addi (add immediate): t0 = t0 - 1  (decrementa)\n    bne t0, x0, loop# bne (branch if not equal): se t0 != 0, volta para 'loop'\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#43-manipular-ponteiros-enderecos-em-vetores","title":"4.3 Manipular ponteiros (endere\u00e7os) em vetores","text":"<ul> <li><code>.data</code> \u2014 diretiva que inicia a sess\u00e3o de dados</li> <li><code>.text</code> \u2014 diretiva que inicia a sess\u00e3o de c\u00f3digo</li> <li><code>la</code> \u2014 load address, carrega o endere\u00e7o de um label</li> <li><code>lw</code> \u2014 load word, l\u00ea 4 bytes da mem\u00f3ria para um registrador</li> </ul> <p>Em vetores declarados com <code>.word</code>, cada elemento ocupa 4 bytes:</p> <pre><code>.data\nvetor: .word 10, 20, 30, 40   # vetor de 4 inteiros (4 bytes cada)\n\n.text\n.globl main                   # .globl (global): torna 'main' ponto de entrada\n\nmain:\n    la t0, vetor              # la (load address): t0 recebe o endere\u00e7o do primeiro elemento de 'vetor'\n    lw t1, 0(t0)              # lw (load word): t1 recebe vetor[0]\n    addi t0, t0, 4            # addi: avan\u00e7a o ponteiro para o pr\u00f3ximo elemento (vetor[1])\n\n    li a7, 93                 # li: escolhe syscall exit2 (c\u00f3digo 93)\n    ecall                     # ecall (environment call): executa a syscall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#44-criar-deslocamentos-para-calculos","title":"4.4 Criar deslocamentos para c\u00e1lculos","text":"<pre><code>addi t2, t1, 100    # addi: t2 = t1 + 100 (deslocamento de 100 bytes)\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#5-exemplos-completos","title":"5. Exemplos completos","text":""},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#51-incremento-simples-com-limite","title":"5.1 Incremento simples com limite","text":"<p><code>blt</code> (branch if less than): desvia se <code>rs1 &lt; rs2</code>.</p> <pre><code>li t0, 0                # t0 = 0 (contador)\nli t1, 10               # t1 = 10 (limite)\n\nloop:\n    addi t0, t0, 1      # addi (add immediate): t0 = t0 + 1\n    blt t0, t1, loop    # blt (branch if less than): se t0 &lt; t1, volta para 'loop'\n\n    li a7, 93           # li: escolhe syscall exit2\n    ecall               # encerra o programa\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#52-decremento-ate-zero","title":"5.2 Decremento at\u00e9 zero","text":"<pre><code>li t0, 7                # t0 come\u00e7a em 7\n\nloop:\n    addi t0, t0, -1     # addi: t0 = t0 - 1\n    bne t0, x0, loop    # bne: enquanto t0 != 0, repete o loop\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#53-somando-com-imediatos-e-usando-addsub","title":"5.3 Somando com imediatos e usando <code>add</code>/<code>sub</code>","text":"<ul> <li><code>add</code> \u2014 add: soma dois registradores   <code>add rd, rs1, rs2</code> \u2192 <code>rd = rs1 + rs2</code></li> <li><code>sub</code> \u2014 subtract: subtrai registradores   <code>sub rd, rs1, rs2</code> \u2192 <code>rd = rs1 - rs2</code></li> </ul> <pre><code>li t0, 12               # t0 = 12\nli t1, 30               # t1 = 30\n\naddi t2, t1, -12        # addi: t2 = t1 + (-12) = 30 - 12\nadd t3, t0, t2          # add (add): t3 = t0 + t2 = 12 + 18\n\nsub t4, t3, t0          # sub (subtract): t4 = t3 - t0 = 30 - 12\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#54-percorrer-vetor-usando-addi-para-andar-na-memoria","title":"5.4 Percorrer vetor usando <code>addi</code> para andar na mem\u00f3ria","text":"<pre><code>.data\nvet: .word 3, 6, 9, 12          # vetor com 4 inteiros\n\n.text\n.globl main\n\nmain:\n    la t0, vet                  # la: t0 = endere\u00e7o base de vet\n    li t1, 0                    # t1 = \u00edndice i\n    li t2, 4                    # t2 = tamanho (4 elementos)\n\nloop:\n    lw t3, 0(t0)                # lw: t3 = vet[i]\n    # aqui poder\u00edamos fazer algo com t3 (somar, imprimir etc.)\n\n    addi t0, t0, 4              # addi: avan\u00e7a ponteiro para o pr\u00f3ximo elemento\n    addi t1, t1, 1              # addi: i = i + 1\n\n    blt t1, t2, loop            # blt: enquanto i &lt; 4, continua no loop\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.1_instrucoes_de_imediato/#6-exercicios-para-fixacao","title":"6. Exerc\u00edcios para fixa\u00e7\u00e3o","text":"<ol> <li>Carregue o valor 57 em <code>a0</code> usando <code>li</code>.</li> <li>Some 10 ao registrador <code>t1</code> usando <code>addi</code>.</li> <li>Implemente um contador que come\u00e7a em 1 e vai at\u00e9 20 usando <code>li</code>, <code>addi</code> e <code>blt</code> ou <code>bne</code>.</li> <li>Dado um vetor de 4 <code>word</code>, avance o ponteiro at\u00e9 o \u00faltimo elemento usando <code>addi</code> (de 4 em 4 bytes).</li> <li> <p>Implemente <code>t3 = (t0 + 4) - (t1 + 7)</code> usando apenas:</p> </li> <li> <p><code>li</code></p> </li> <li><code>addi</code></li> <li><code>add</code></li> <li><code>sub</code></li> </ol>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/","title":"M\u00f3dulo 4.2. \u2014 Movimenta\u00e7\u00e3o de Dados","text":"<p>(<code>mv</code>, <code>lw</code>, <code>sw</code>, <code>la</code>)</p> <p>Este m\u00f3dulo explica como mover dados entre registradores e mem\u00f3ria no RISC-V (RISC-V = Reduced Instruction Set Computer \u2013 Five; ISA \u2014 Instruction Set Architecture, isto \u00e9, o conjunto de instru\u00e7\u00f5es que o processador entende).</p> <p>Essas instru\u00e7\u00f5es s\u00e3o a base de todo programa: somar, comparar, chamar fun\u00e7\u00e3o, fazer loop \u2014 tudo depende de colocar os dados nos registradores certos na hora certa.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#1-visao-geral-registradores-e-memoria","title":"1. Vis\u00e3o geral: registradores e mem\u00f3ria","text":"<p>Antes de aprender as instru\u00e7\u00f5es, precisamos entender onde os dados vivem.</p> <p>O processador (CPU \u2014 Central Processing Unit) trabalha basicamente com:</p> <ul> <li> <p>Registradores \u2014 pequenas c\u00e9lulas internas, extremamente r\u00e1pidas   Exemplos:</p> </li> <li> <p><code>t0</code> (temporary register),</p> </li> <li><code>a0</code> (argument register),</li> <li> <p><code>s0</code> (saved register).     Esses apelidos s\u00e3o nomes \u201camig\u00e1veis\u201d para registradores <code>x5</code>, <code>x10</code>, <code>x8</code> etc.</p> </li> <li> <p>Mem\u00f3ria RAM (RAM \u2014 Random Access Memory) \u2014 \u00e1rea grande, externa ao n\u00facleo do processador, mas mais lenta   \u00c9 onde ficam:</p> </li> <li> <p>dados da sess\u00e3o <code>.data</code></p> </li> <li>arrays, strings, matrizes</li> <li>vari\u00e1veis globais, buffers, etc.</li> </ul> <p>O RISC-V segue o modelo load/store:</p> <p>O processador s\u00f3 faz opera\u00e7\u00f5es aritm\u00e9ticas e l\u00f3gicas com dados que j\u00e1 est\u00e3o em registradores. Para buscar ou gravar na mem\u00f3ria, usamos instru\u00e7\u00f5es espec\u00edficas de load (carregar) e store (armazenar).</p> <p>Por isso <code>lw</code> e <code>sw</code> s\u00e3o t\u00e3o importantes.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#2-mv-mover-valor-entre-registradores","title":"2. <code>mv</code> \u2014 mover valor entre registradores","text":"<p><code>mv</code> (move) \u00e9 uma pseudo-instru\u00e7\u00e3o. Pseudo-instru\u00e7\u00e3o = instru\u00e7\u00e3o que n\u00e3o existe no hardware, mas o montador converte automaticamente para uma ou mais instru\u00e7\u00f5es reais.</p> <p>Sintaxe:</p> <pre><code>mv rd, rs\n</code></pre> <p>Significa:</p> <p>Copiar o valor do registrador <code>rs</code> para o registrador <code>rd</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 42              # li (load immediate): carrega o valor 42 em t0\nmv a0, t0              # mv (move): copia o valor de t0 para a0\n</code></pre> <p>Internamente, o montador converte:</p> <pre><code>mv rd, rs\n</code></pre> <p>para:</p> <pre><code>addi rd, rs, 0         # addi (add immediate): rd = rs + 0\n</code></pre>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#3-lw-load-word-carregar-palavra-da-memoria","title":"3. <code>lw</code> \u2014 load word (carregar palavra da mem\u00f3ria)","text":"<p><code>lw</code> (load word) \u00e9 uma instru\u00e7\u00e3o real do conjunto b\u00e1sico RV32I (RV32I = vers\u00e3o de 32 bits do RISC-V para inteiros, RISC-V 32-bit Integer).</p> <ul> <li>Word = palavra de 32 bits (4 bytes).</li> <li>A mem\u00f3ria do RISC-V \u00e9 endere\u00e7ada por bytes (byte-addressable): cada endere\u00e7o aponta para 1 byte.</li> </ul> <p>Sintaxe:</p> <pre><code>lw rd, offset(rs)\n</code></pre> <p>Significa:</p> <p>Ler 4 bytes (1 word) da mem\u00f3ria no endere\u00e7o <code>rs + offset</code> e colocar o resultado no registrador <code>rd</code>.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#exemplo-basico-de-lw","title":"Exemplo b\u00e1sico de <code>lw</code>","text":"<p>Aqui aparecem algumas diretivas pela primeira vez:</p> <ul> <li><code>.data</code> \u2014 inicia a sess\u00e3o de dados, onde declaramos vari\u00e1veis na mem\u00f3ria.</li> <li><code>.word</code> \u2014 reserva 4 bytes (1 word) e grava um valor inteiro.</li> <li><code>.text</code> \u2014 inicia a sess\u00e3o de c\u00f3digo, onde ficam as instru\u00e7\u00f5es.</li> <li><code>.globl main</code> \u2014 torna o r\u00f3tulo <code>main</code> o ponto de entrada do programa.</li> </ul> <pre><code>.data\nx: .word 99                 # .word: reserva 4 bytes e coloca o inteiro 99 em x\n\n.text\n.globl main                 # .globl (global): exp\u00f5e 'main' como ponto de entrada\n\nmain:\n    la t0, x                # la (load address): carrega em t0 o endere\u00e7o do r\u00f3tulo x\n    lw t1, 0(t0)            # lw (load word): l\u00ea 4 bytes a partir de t0 e coloca o valor em t1 (99)\n\n    li a7, 93               # li: coloca 93 em a7 (c\u00f3digo da syscall exit2)\n    ecall                   # ecall (environment call): executa a syscall indicada em a7\n</code></pre> <p>Passo a passo:</p> <ol> <li><code>la t0, x</code> \u2192 <code>t0</code> recebe o endere\u00e7o de mem\u00f3ria onde est\u00e1 <code>x</code>.</li> <li><code>lw t1, 0(t0)</code> \u2192 l\u00ea 4 bytes a partir de <code>t0</code> e coloca o valor (99) em <code>t1</code>.</li> </ol>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#4-sw-store-word-armazenar-palavra-na-memoria","title":"4. <code>sw</code> \u2014 store word (armazenar palavra na mem\u00f3ria)","text":"<p><code>sw</code> (store word) grava um valor de 32 bits da CPU para a mem\u00f3ria.</p> <p>Sintaxe:</p> <pre><code>sw rs2, offset(rs1)\n</code></pre> <p>Interpreta\u00e7\u00e3o:</p> <p>Armazena o valor de 32 bits do registrador <code>rs2</code> no endere\u00e7o <code>rs1 + offset</code>.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#exemplo-basico-de-sw","title":"Exemplo b\u00e1sico de <code>sw</code>","text":"<pre><code>.data\ny: .word 0                  # reserva 4 bytes e inicializa com 0\n\n.text\n.globl main\n\nmain:\n    li t0, 55               # li (load immediate): t0 recebe o valor 55\n    la t1, y                # la (load address): t1 recebe o endere\u00e7o de y\n    sw t0, 0(t1)            # sw (store word): grava o valor de t0 (55) na mem\u00f3ria em y\n\n    li a7, 93\n    ecall\n</code></pre> <p>Depois de executar:</p> <ul> <li>o registrador <code>t0</code> cont\u00e9m 55,</li> <li>a posi\u00e7\u00e3o de mem\u00f3ria associada a <code>y</code> tamb\u00e9m passa a conter 55.</li> </ul>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#5-la-load-address-carregar-endereco","title":"5. <code>la</code> \u2014 load address (carregar endere\u00e7o)","text":"<p><code>la</code> (load address) \u00e9 uma pseudo-instru\u00e7\u00e3o que carrega o endere\u00e7o de um r\u00f3tulo (<code>label</code>) para dentro de um registrador.</p> <p>Sintaxe:</p> <pre><code>la rd, label\n</code></pre> <p>Significa:</p> <p>Colocar no registrador <code>rd</code> o endere\u00e7o de mem\u00f3ria associado ao r\u00f3tulo <code>label</code>.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#exemplo-com-string-e-syscall","title":"Exemplo com string e syscall","text":"<p>Aqui aparece pela primeira vez:</p> <ul> <li><code>.asciz</code> \u2014 diretiva que cria uma string ASCII terminada em byte zero (<code>\\0</code>),   ASCII = American Standard Code for Information Interchange.</li> <li><code>syscall</code> \u2014 chamada de sistema (system call), servi\u00e7o fornecido pelo simulador.</li> <li><code>a7</code> como registrador de c\u00f3digo de syscall.</li> <li><code>a0</code> como registrador de argumento.</li> </ul> <pre><code>.data\nmsg: .asciz \"Hello\\n\"       # .asciz: string ASCII terminada em 0 (formato C-string)\n\n.text\n.globl main\n\nmain:\n    la a0, msg              # la: a0 recebe o endere\u00e7o do in\u00edcio da string msg\n    li a7, 4                # li: coloca 4 em a7 (c\u00f3digo da syscall print_string)\n    ecall                   # ecall: executa a syscall configurada (imprime a string)\n\n    li a7, 93               # 93 = exit2\n    ecall\n</code></pre> <p>Nos bastidores, o montador pode traduzir <code>la</code> para algo como:</p> <ul> <li><code>auipc</code> (add upper immediate to PC) \u2014 soma imediato \u00e0 parte alta do PC   PC = program counter, registrador que guarda o endere\u00e7o da pr\u00f3xima instru\u00e7\u00e3o.</li> <li><code>addi</code> (add immediate) \u2014 soma imediato \u00e0 parte baixa.</li> </ul> <p>Mas para quem est\u00e1 aprendendo, basta saber:</p> <p><code>la</code> devolve o endere\u00e7o do r\u00f3tulo.</p>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#6-mapa-mental-quando-usar-cada-instrucao","title":"6. Mapa mental \u2014 quando usar cada instru\u00e7\u00e3o","text":"Tarefa Instru\u00e7\u00e3o Copiar valor entre registradores <code>mv</code> (move) Colocar n\u00famero imediato em registrador <code>li</code> (load immediate, pseudo) Ler inteiro (32 bits) da mem\u00f3ria <code>lw</code> (load word) Gravar inteiro (32 bits) na mem\u00f3ria <code>sw</code> (store word) Obter endere\u00e7o de um r\u00f3tulo na mem\u00f3ria <code>la</code> (load address, pseudo)"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#7-exercicio-1-copiar-gravar-e-ler","title":"7. Exerc\u00edcio 1 \u2014 copiar, gravar e ler","text":"<p>Objetivo:</p> <ol> <li>Colocar um valor em <code>t0</code></li> <li>Guardar esse valor na mem\u00f3ria</li> <li>Carregar de volta para <code>t2</code></li> </ol> <p>C\u00f3digo de refer\u00eancia:</p> <pre><code>.data\nvalor: .word 0                   # reserva 4 bytes para 'valor'\n\n.text\n.globl main\n\nmain:\n    li t0, 123                   # li: t0 = 123\n\n    la t1, valor                 # la: t1 recebe o endere\u00e7o de 'valor'\n    sw t0, 0(t1)                 # sw: grava o conte\u00fado de t0 na mem\u00f3ria em 'valor'\n\n    lw t2, 0(t1)                 # lw: carrega de volta o valor armazenado em 'valor' para t2\n\n    li a7, 93\n    ecall\n</code></pre> <p>No RARS, observe:</p> <ul> <li>painel Registers \u2192 valores em <code>t0</code>, <code>t1</code>, <code>t2</code></li> <li>painel Data \u2192 valor de <code>valor</code> na mem\u00f3ria</li> </ul>"},{"location":"modulos/modulo%204/mod4.2_movimentacoes_de_dados/#8-exercicio-2-vetor-array-de-4-elementos","title":"8. Exerc\u00edcio 2 \u2014 vetor (array) de 4 elementos","text":"<p>Objetivo:</p> <ul> <li>Somar os valores de um array usando <code>lw</code> para ler e <code>add</code> para acumular.</li> </ul> <p>Aqui aparece pela primeira vez:</p> <ul> <li><code>add</code> \u2014 add (somar dois registradores):   <code>add rd, rs1, rs2</code> \u2192 <code>rd = rs1 + rs2</code></li> <li><code>addi</code> \u2014 add immediate (somar imediato):   <code>addi rd, rs1, imediato</code> \u2192 <code>rd = rs1 + imediato</code></li> <li><code>blt</code> \u2014 branch if less than (desvia se menor que):   <code>blt rs1, rs2, label</code> \u2192 desvia se <code>rs1 &lt; rs2</code>.</li> </ul> <pre><code>.data\nvet: .word 3, 5, 7, 9           # quatro inteiros\n\n.text\n.globl main\n\nmain:\n    la t0, vet                  # la: t0 = endere\u00e7o do primeiro elemento (vet[0])\n    li t1, 0                    # li: t1 = \u00edndice i = 0\n    li t2, 0                    # li: t2 = soma acumulada = 0\n\nloop:\n    lw t3, 0(t0)                # lw: t3 = vet[i]\n    add t2, t2, t3              # add: t2 = t2 + t3  (soma += elemento)\n\n    addi t0, t0, 4              # addi: avan\u00e7a ponteiro para o pr\u00f3ximo elemento (4 bytes)\n    addi t1, t1, 1              # addi: i = i + 1    (incrementa \u00edndice)\n\n    li t4, 4                    # li: t4 = 4 (tamanho do vetor)\n    blt t1, t4, loop            # blt: enquanto i &lt; 4, volta para 'loop'\n\n    # aqui t2 cont\u00e9m a soma total (3 + 5 + 7 + 9)\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/","title":"M\u00f3dulo 4.3. \u2014 Aritm\u00e9tica B\u00e1sica","text":"<p>(<code>add</code>, <code>sub</code>)</p> <p>A aritm\u00e9tica no RISC-V (ISA \u2014 Instruction Set Architecture) \u00e9 extremamente simples e direta. O conjunto b\u00e1sico RV32I (Integer instruction set de 32 bits) traz instru\u00e7\u00f5es para somar, subtrair e adicionar imediatos. Este m\u00f3dulo cobre apenas a aritm\u00e9tica essencial: somar e subtrair.</p>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#1-por-que-aritmetica-em-assembly-e-tao-importante","title":"1. Por que aritm\u00e9tica em assembly \u00e9 t\u00e3o importante?","text":"<p>Toda opera\u00e7\u00e3o l\u00f3gica, toda condi\u00e7\u00e3o, todo loop, toda fun\u00e7\u00e3o\u2026 acaba dependendo do b\u00e1sico:</p> <ul> <li>somar \u00edndices</li> <li>subtrair contadores</li> <li>atualizar ponteiros</li> <li>calcular deslocamentos de mem\u00f3ria</li> <li>somar acumuladores</li> <li>fazer incrementos e decrementos</li> </ul> <p>No RISC-V, tudo isso \u00e9 feito com poucas instru\u00e7\u00f5es simples e totalmente determin\u00edsticas.</p>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#2-a-instrucao-add-somar-registradores","title":"2. A instru\u00e7\u00e3o <code>add</code> \u2014 somar registradores","text":"<p><code>add</code> (add) \u00e9 uma instru\u00e7\u00e3o real do RV32I que soma dois registradores e guarda o resultado em um terceiro.</p> <p>Sintaxe:</p> <pre><code>add rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd = rs1 + rs2</code></p> <p>Exemplo:</p> <pre><code>li t0, 7              # li (load immediate): coloca 7 em t0\nli t1, 5              # coloca 5 em t1\nadd t2, t0, t1        # t2 = 7 + 5 = 12\n</code></pre> <ul> <li>Somente registradores podem ser somados.</li> <li>O resultado sempre fica no registrador <code>rd</code>.</li> </ul>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#3-a-instrucao-addi-somar-com-imediato","title":"3. A instru\u00e7\u00e3o <code>addi</code> \u2014 somar com imediato","text":"<p><code>addi</code> (add immediate) \u00e9 a vers\u00e3o de soma onde o segundo operando \u00e9 um valor imediato de 12 bits (constante inteira).</p> <p>Sintaxe:</p> <pre><code>addi rd, rs1, imediato\n</code></pre> <p>Significa:</p> <p><code>rd = rs1 + imediato</code></p> <p>Exemplos \u00fateis:</p>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#incrementar-um-contador","title":"Incrementar um contador","text":"<pre><code>addi t0, t0, 1        # t0 = t0 + 1\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#decrementar","title":"Decrementar","text":"<pre><code>addi t0, t0, -1       # t0 = t0 - 1\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#somar-deslocamento-de-ponteiro","title":"Somar deslocamento de ponteiro","text":"<pre><code>addi t0, t0, 4        # avan\u00e7a 1 word (4 bytes)\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#4-a-instrucao-sub-subtracao","title":"4. A instru\u00e7\u00e3o <code>sub</code> \u2014 subtra\u00e7\u00e3o","text":"<p><code>sub</code> (subtract) \u00e9 uma instru\u00e7\u00e3o do RV32I que calcula a diferen\u00e7a entre dois registradores.</p> <p>Sintaxe:</p> <pre><code>sub rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd = rs1 - rs2</code></p> <p>Exemplo:</p> <pre><code>li t0, 20\nli t1, 7\nsub t2, t0, t1        # t2 = 20 - 7 = 13\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#5-aritmetica-e-flags-importante","title":"5. Aritm\u00e9tica e flags \u2014 importante!","text":"<p>Diferente de arquiteturas como x86, o RISC-V n\u00e3o possui flags (carry, overflow, zero, negativo). Por isso, opera\u00e7\u00f5es matem\u00e1ticas n\u00e3o alteram estados especiais.</p> <p>Compara\u00e7\u00f5es e desvios s\u00e3o feitos explicitamente com instru\u00e7\u00f5es de branch (<code>beq</code>, <code>bne</code>, <code>blt</code> etc.), n\u00e3o com flags autom\u00e1ticos.</p>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#6-exemplos-completos","title":"6. Exemplos completos","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#61-somar-dois-numeros","title":"6.1 Somar dois n\u00fameros","text":"<pre><code>li t0, 15              # primeiro n\u00famero\nli t1, 27              # segundo n\u00famero\nadd t2, t0, t1         # t2 = 42\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#62-subtrair-dois-numeros","title":"6.2 Subtrair dois n\u00fameros","text":"<pre><code>li t0, 50\nli t1, 12\nsub t2, t0, t1         # t2 = 38\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#63-incrementar-contador-ate-atingir-limite","title":"6.3 Incrementar contador at\u00e9 atingir limite","text":"<pre><code>li t0, 0               # contador\nli t1, 10              # limite\n\nloop:\n    addi t0, t0, 1     # contador++\n    blt t0, t1, loop   # repete at\u00e9 t0 &lt; 10\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#64-manipular-ponteiros-para-array","title":"6.4 Manipular ponteiros para array","text":"<pre><code>.data\nvet: .word 3, 6, 9, 12\n\n.text\nmain:\n    la t0, vet         # t0 = endere\u00e7o do vetor\n    lw t1, 0(t0)       # l\u00ea vet[0]\n    addi t0, t0, 4     # t0 agora aponta para vet[1]\n    lw t2, 0(t0)       # l\u00ea vet[1]\n</code></pre>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#7-exercicios-para-fixacao","title":"7. Exerc\u00edcios para fixa\u00e7\u00e3o","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#1-some-os-numeros-12-e-31-e-coloque-o-resultado-em-t2","title":"1. Some os n\u00fameros 12 e 31 e coloque o resultado em <code>t2</code>.","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#2-subtraia-100-37-usando-sub","title":"2. Subtraia 100 \u2212 37 usando <code>sub</code>.","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#3-implemente-um-contador-que-comeca-em-10-e-vai-ate-0-usando-addi","title":"3. Implemente um contador que come\u00e7a em 10 e vai at\u00e9 0 usando <code>addi</code>.","text":""},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#4-some-todos-os-elementos-de-um-vetor-de-5-posicoes-usando","title":"4. Some todos os elementos de um vetor de 5 posi\u00e7\u00f5es usando:","text":"<ul> <li><code>add</code></li> <li><code>addi</code></li> <li><code>lw</code></li> </ul>"},{"location":"modulos/modulo%204/mod4.3_aritmetica_basica/#5-calcule-t2-t0-4-t1-3-usando-somente-add-sub-e-addi","title":"5. Calcule <code>t2 = (t0 + 4) - (t1 - 3)</code> usando somente <code>add</code>, <code>sub</code> e <code>addi</code>.","text":""},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/","title":"M\u00f3dulo 4.4. \u2014 Compara\u00e7\u00f5es e Desvios","text":"<p>(<code>beq</code>, <code>bne</code>, <code>blt</code>, <code>bgt</code>, <code>beqz</code>, <code>bnez</code>)</p> <p>Este m\u00f3dulo mostra como o RISC-V (RISC-V = Reduced Instruction Set Computer \u2013 Five) usa instru\u00e7\u00f5es de desvio (branch instructions) para tomar decis\u00f5es.</p> <p>\u00c9 com essas instru\u00e7\u00f5es que implementamos, em assembly:</p> <ul> <li><code>if</code>, <code>else</code></li> <li><code>while</code></li> <li><code>for</code></li> <li>e qualquer tipo de decis\u00e3o condicional</li> </ul> <p>Vou assumir que voc\u00ea j\u00e1 tem no\u00e7\u00e3o de:</p> <ul> <li>registradores (como <code>a0</code>, <code>t0</code>, <code>x0</code>)</li> <li>diretivas <code>.data</code> e <code>.text</code></li> <li>no\u00e7\u00f5es b\u00e1sicas de syscalls (system calls) no RARS   RARS = RISC-V Assembler and Runtime Simulator, um simulador de RISC-V que monta e executa programas <code>.asm</code>.</li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#1-ideia-central-nao-existe-if-so-branch","title":"1. Ideia central: n\u00e3o existe <code>if</code>, s\u00f3 branch","text":"<p>Em C:</p> <pre><code>if (x == y) {\n    // bloco verdadeiro\n} else {\n    // bloco falso\n}\n</code></pre> <p>Em RISC-V, o processador n\u00e3o conhece a palavra <code>if</code>. O que existe \u00e9:</p> <ol> <li>Comparar valores em registradores</li> <li>Se a condi\u00e7\u00e3o for verdadeira, desviar para um r\u00f3tulo (label), que \u00e9 um nome que marca uma posi\u00e7\u00e3o no c\u00f3digo</li> <li>Se a condi\u00e7\u00e3o for falsa, apenas continuar executando a pr\u00f3xima instru\u00e7\u00e3o</li> </ol> <p>Ou seja:</p> <p>\u201cIF\u201d \u00e9 s\u00f3 um jeito humano de organizar branches (instru\u00e7\u00f5es de desvio).</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#2-registradores-e-instrucoes-de-apoio","title":"2. Registradores e instru\u00e7\u00f5es de apoio","text":"<p>Dois tipos de registradores aparecem muito em compara\u00e7\u00f5es:</p> <ul> <li><code>x0</code> \u2014 registrador especial que sempre vale 0 (zero \u201cligado por hardware\u201d, hard-wired zero)</li> <li><code>t0</code>, <code>t1</code>, <code>t2</code>\u2026 \u2014 registradores tempor\u00e1rios (temporary registers), usados para c\u00e1lculos intermedi\u00e1rios</li> </ul> <p>Tamb\u00e9m vamos usar algumas instru\u00e7\u00f5es de apoio:</p> <ul> <li> <p><code>li rd, imm</code> \u2014 <code>li</code> (load immediate): carrega um valor imediato (constante) <code>imm</code> diretamente para o registrador <code>rd</code>.   Exemplo: <code>li t0, 10</code> coloca o valor 10 dentro de <code>t0</code>.</p> </li> <li> <p><code>addi rd, rs1, imm</code> \u2014 <code>addi</code> (add immediate): soma o valor imediato <code>imm</code> ao conte\u00fado de <code>rs1</code> e guarda o resultado em <code>rd</code>.   Exemplo: <code>addi t0, t0, 1</code> faz <code>t0 = t0 + 1</code>.</p> </li> <li> <p><code>j label</code> \u2014 <code>j</code> (jump): pseudo-instru\u00e7\u00e3o de salto incondicional.   O montador traduz <code>j label</code> para <code>jal x0, label</code>   (<code>jal</code> = jump and link, mas como o destino \u00e9 <code>x0</code>, o retorno \u00e9 descartado).</p> </li> <li> <p><code>ecall</code> \u2014 <code>ecall</code> (environment call): dispara uma syscall (chamada de sistema) configurada no registrador <code>a7</code>.   Por exemplo, no RARS: <code>a7 = 4</code> \u2192 imprimir string; <code>a7 = 93</code> \u2192 encerrar o programa.</p> </li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#3-instrucoes-de-desvio-basicas","title":"3. Instru\u00e7\u00f5es de desvio b\u00e1sicas","text":"<p>As instru\u00e7\u00f5es de desvio comparam dois registradores. Se a condi\u00e7\u00e3o for verdadeira, elas pulam para um r\u00f3tulo (<code>label:</code>).</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#31-beq-rs1-rs2-label","title":"3.1 <code>beq rs1, rs2, label</code>","text":"<p><code>beq</code> (branch if equal) desvia se os registradores forem iguais.</p> <p>Sintaxe:</p> <pre><code>beq rs1, rs2, label\n</code></pre> <p>Significa:</p> <p>Se <code>rs1 == rs2</code>, pule para <code>label</code>. Caso contr\u00e1rio, continue executando a pr\u00f3xima instru\u00e7\u00e3o.</p> <p>Exemplo:</p> <pre><code>li t0, 10           # li: t0 = 10\nli t1, 10           # li: t1 = 10\n\nbeq t0, t1, iguais  # beq: se t0 == t1, desvia para o r\u00f3tulo 'iguais'\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#32-bne-rs1-rs2-label","title":"3.2 <code>bne rs1, rs2, label</code>","text":"<p><code>bne</code> (branch if not equal) desvia se os registradores forem diferentes.</p> <p>Sintaxe:</p> <pre><code>bne rs1, rs2, label\n</code></pre> <p>Significa:</p> <p>Se <code>rs1 != rs2</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 5\nli t1, 7\n\nbne t0, t1, sao_diferentes   # bne: como 5 != 7, o desvio acontece\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#33-blt-rs1-rs2-label","title":"3.3 <code>blt rs1, rs2, label</code>","text":"<p><code>blt</code> (branch if less than) desvia se <code>rs1</code> for menor que <code>rs2</code>, tratando os valores como n\u00fameros com sinal (signed).</p> <p>Sintaxe:</p> <pre><code>blt rs1, rs2, label\n</code></pre> <p>Significa:</p> <p>Se <code>rs1 &lt; rs2</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 3\nli t1, 10\n\nblt t0, t1, menor          # blt: como 3 &lt; 10, o desvio acontece\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#34-bgt-rs1-rs2-label-pseudo-instrucao","title":"3.4 <code>bgt rs1, rs2, label</code> (pseudo-instru\u00e7\u00e3o)","text":"<p><code>bgt</code> (branch if greater than) n\u00e3o existe como instru\u00e7\u00e3o real no conjunto RV32I. Ela \u00e9 uma pseudo-instru\u00e7\u00e3o criada pelo montador para facilitar a escrita.</p> <p>Sintaxe:</p> <pre><code>bgt rs1, rs2, label\n</code></pre> <p>O montador normalmente converte isso em algo equivalente a:</p> <pre><code>blt rs2, rs1, label   # branch if rs2 &lt; rs1 \u2192 ou seja, rs1 &gt; rs2\n</code></pre> <p>Significa:</p> <p>Se <code>rs1 &gt; rs2</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 15\nli t1, 7\n\nbgt t0, t1, maior        # bgt: desvia, porque 15 &gt; 7\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#4-comparacoes-com-zero-beqz-e-bnez","title":"4. Compara\u00e7\u00f5es com zero: <code>beqz</code> e <code>bnez</code>","text":"<p>Comparar um registrador com zero \u00e9 t\u00e3o comum que o montador oferece pseudo-instru\u00e7\u00f5es especiais.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#41-beqz-rs-label","title":"4.1 <code>beqz rs, label</code>","text":"<p><code>beqz</code> (branch if equal to zero) \u00e9 uma pseudo-instru\u00e7\u00e3o que desvia se o registrador for igual a zero.</p> <p>Sintaxe:</p> <pre><code>beqz rs, label\n</code></pre> <p>O montador traduz para:</p> <pre><code>beq rs, x0, label       # compara com o registrador x0 (constante zero)\n</code></pre> <p>Significa:</p> <p>Se <code>rs == 0</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 0\nbeqz t0, eh_zero        # como t0 \u00e9 0, o desvio acontece\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#42-bnez-rs-label","title":"4.2 <code>bnez rs, label</code>","text":"<p><code>bnez</code> (branch if not equal to zero) \u00e9 a vers\u00e3o \u201cdiferente de zero\u201d.</p> <p>Sintaxe:</p> <pre><code>bnez rs, label\n</code></pre> <p>O montador traduz para:</p> <pre><code>bne rs, x0, label\n</code></pre> <p>Significa:</p> <p>Se <code>rs != 0</code>, pule para <code>label</code>.</p> <p>Exemplo:</p> <pre><code>li t0, 42\nbnez t0, nao_zero       # como t0 != 0, o desvio acontece\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#5-padrao-de-if-simples-em-risc-v","title":"5. Padr\u00e3o de IF simples em RISC-V","text":"<p>Vamos representar em C:</p> <pre><code>if (t0 == 10) {\n    // bloco verdadeiro\n}\n</code></pre> <p>Vers\u00e3o t\u00edpica em RISC-V:</p> <pre><code>    li t0, 10                   # t0 = 10\n    li t1, 10                   # valor de compara\u00e7\u00e3o\n\n    bne t0, t1, fim_if          # se t0 != 10, pula o bloco verdadeiro\n\n    # bloco verdadeiro (t0 == 10)\n    # ... c\u00f3digo do verdadeiro ...\n\nfim_if:\n    # continua\u00e7\u00e3o do programa\n</code></pre> <p>Estrat\u00e9gia:</p> <ul> <li>usar <code>bne</code> para saltar o bloco quando a condi\u00e7\u00e3o \u00e9 falsa</li> <li>colocar um r\u00f3tulo <code>fim_if</code> para marcar o ponto de continua\u00e7\u00e3o</li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#6-ifelse-em-risc-v","title":"6. IF\u2013ELSE em RISC-V","text":"<p>Em C:</p> <pre><code>if (t0 == 10) {\n    // verdadeiro\n} else {\n    // falso\n}\n</code></pre> <p>Vers\u00e3o em assembly:</p> <pre><code>    li t0, 10\n    li t1, 10\n\n    bne t0, t1, bloco_falso   # se t0 != 10, vai para o bloco falso\n\nbloco_verdadeiro:\n    # aqui t0 == 10\n    # ... c\u00f3digo do bloco verdadeiro ...\n    j fim_if                  # j (jump): salto incondicional para 'fim_if'\n\nbloco_falso:\n    # ... c\u00f3digo do bloco falso ...\n\nfim_if:\n    # segue o programa\n</code></pre> <p>Lembrando:</p> <ul> <li><code>j</code> \u00e9 pseudo-instru\u00e7\u00e3o de salto incondicional   O montador traduz <code>j fim_if</code> para <code>jal x0, fim_if</code>.</li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#7-exemplo-completo-negativo-zero-ou-positivo","title":"7. Exemplo completo: negativo, zero ou positivo","text":"<p>Vamos classificar um n\u00famero como negativo, zero ou positivo usando instru\u00e7\u00f5es de desvio.</p> <p>Aqui aparecem algumas diretivas pela primeira vez neste m\u00f3dulo:</p> <ul> <li><code>.data</code> \u2014 in\u00edcio da sess\u00e3o de dados, onde declaramos vari\u00e1veis e strings.</li> <li><code>.text</code> \u2014 in\u00edcio da sess\u00e3o de c\u00f3digo, onde ficam as instru\u00e7\u00f5es.</li> <li><code>.globl main</code> \u2014 torna o r\u00f3tulo <code>main</code> o ponto de entrada vis\u00edvel externamente.</li> <li><code>.asciz</code> \u2014 define uma string ASCII terminada com byte zero (<code>\\0</code>), formato esperado por algumas syscalls.</li> </ul> <p>Syscalls usadas (no RARS):</p> <ul> <li><code>a7 = 4</code> \u2192 print_string (imprime string apontada por <code>a0</code>)</li> <li><code>a7 = 93</code> \u2192 exit2 (encerra o programa)</li> </ul> <pre><code>.data\nmsgNeg:  .asciz \"Numero negativo\\n\"    # .asciz: string terminada em byte 0\nmsgZero: .asciz \"Numero zero\\n\"\nmsgPos:  .asciz \"Numero positivo\\n\"\n\n.text\n.globl main                            # .globl (global): exp\u00f5e 'main' como entrada\n\nmain:\n    # exemplo: vamos testar o valor -5\n    li t0, -5                          # li: carrega o valor imediato -5 em t0\n\n    blt t0, x0, negativo               # blt: se t0 &lt; 0, desvia para 'negativo'\n    beq t0, x0, eh_zero                # beq: se t0 == 0, desvia para 'eh_zero'\n\n    # se n\u00e3o \u00e9 &lt; 0 nem == 0, s\u00f3 pode ser positivo\n    la a0, msgPos                      # la (load address): a0 = endere\u00e7o de msgPos\n    li a7, 4                           # li: a7 = 4 (syscall print_string)\n    ecall                              # ecall: executa a syscall \u2192 imprime \"Numero positivo\"\n    j fim\n\nnegativo:\n    la a0, msgNeg\n    li a7, 4\n    ecall\n    j fim\n\neh_zero:\n    la a0, msgZero\n    li a7, 4\n    ecall\n\nfim:\n    li a7, 93                          # 93 = syscall exit2\n    ecall\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#8-exemplo-beqzbnez-dentro-de-um-loop","title":"8. Exemplo: <code>beqz</code>/<code>bnez</code> dentro de um loop","text":"<p>Agora vamos usar <code>bnez</code> para pular os n\u00fameros \u00edmpares e imprimir apenas os pares de 1 a 10.</p> <p>Nova instru\u00e7\u00e3o:</p> <ul> <li><code>andi rd, rs1, imm</code> \u2014 <code>andi</code> (AND immediate): faz um AND bit a bit entre <code>rs1</code> e o imediato <code>imm</code> e coloca o resultado em <code>rd</code>.   Exemplo: <code>andi t2, t0, 1</code> pega apenas o bit menos significativo de <code>t0</code>.</li> </ul> <p>L\u00f3gica:</p> <ul> <li>se <code>t0 &amp; 1 == 0</code> \u2192 n\u00famero \u00e9 par</li> <li>se <code>t0 &amp; 1 != 0</code> \u2192 n\u00famero \u00e9 \u00edmpar</li> </ul> <pre><code>.text\n.globl main\n\nmain:\n    li  t0, 1                # t0 = 1 (contador)\n\nloop:\n    andi t2, t0, 1           # andi: t2 = t0 &amp; 1 (isola o bit menos significativo)\n    bnez t2, nao_par         # bnez: se t2 != 0, n\u00famero \u00e9 \u00edmpar \u2192 pula impress\u00e3o\n\n    # se chegou aqui, o n\u00famero \u00e9 par\n    mv  a0, t0               # mv: copia t0 para a0\n    li  a7, 1                # 1 = syscall print_int (imprimir inteiro)\n    ecall\n\n    # quebra de linha\n    li  a0, 10               # 10 = '\\n' em ASCII\n    li  a7, 11               # 11 = syscall print_char\n    ecall\n\nnao_par:\n    addi t0, t0, 1           # addi: t0 = t0 + 1\n    li   t1, 11              # t1 = 11 (limite superior exclusivo)\n    blt  t0, t1, loop        # blt: enquanto t0 &lt; 11, repete o loop\n\n    li   a7, 93              # exit2\n    ecall\n</code></pre> <p>Aqui <code>bnez</code> est\u00e1 fazendo exatamente o papel de:</p> <pre><code>if (t2 != 0) {\n    // n\u00e3o imprime (\u00e9 \u00edmpar)\n}\n</code></pre>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#9-traducoes-uteis-de-c-para-risc-v","title":"9. Tradu\u00e7\u00f5es \u00fateis: de C para RISC-V","text":"<p>Uma \u201ccola r\u00e1pida\u201d de condi\u00e7\u00f5es comuns:</p> <ul> <li> <p><code>if (x == y)</code>   \u2192 <code>beq x, y, rotulo_verdadeiro</code></p> </li> <li> <p><code>if (x != y)</code>   \u2192 <code>bne x, y, rotulo_verdadeiro</code></p> </li> <li> <p><code>if (x &lt; y)</code>   \u2192 <code>blt x, y, rotulo_verdadeiro</code></p> </li> <li> <p><code>if (x &gt; y)</code>   \u2192 <code>bgt x, y, rotulo_verdadeiro</code>   (pseudo-instru\u00e7\u00e3o; montador converte em <code>blt y, x, rotulo_verdadeiro</code>)</p> </li> <li> <p><code>if (x == 0)</code>   \u2192 <code>beqz x, rotulo_verdadeiro</code>   (pseudo: <code>beq x, x0, rotulo_verdadeiro</code>)</p> </li> <li> <p><code>if (x != 0)</code>   \u2192 <code>bnez x, rotulo_verdadeiro</code>   (pseudo: <code>bne x, x0, rotulo_verdadeiro</code>)</p> </li> </ul>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#10-exercicios-para-fixacao","title":"10. Exerc\u00edcios para fixa\u00e7\u00e3o","text":"<p>Os exerc\u00edcios abaixo s\u00e3o pensados para treinar exatamente as instru\u00e7\u00f5es deste m\u00f3dulo:</p> <ul> <li><code>beq</code>, <code>bne</code>, <code>blt</code>, <code>bgt</code>, <code>beqz</code>, <code>bnez</code></li> <li>combinadas com <code>li</code>, <code>addi</code>, <code>j</code>, <code>andi</code>, syscalls simples</li> </ul> <p>Use o RARS para montar e executar.</p> <p>Dica geral: no RARS, a syscall de leitura de inteiro (read_int) usa o c\u00f3digo 5 em <code>a7</code> e devolve o valor em <code>a0</code>.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-1-igual-ou-diferente-de-10","title":"Exerc\u00edcio 1 \u2014 Igual ou diferente de 10","text":"<p>Escreva um programa que:</p> <ol> <li>Coloque um valor em <code>t0</code> usando <code>li</code> (pode testar com 10, depois com 7).</li> <li>Compare <code>t0</code> com o valor 10.</li> <li>Se <code>t0 == 10</code>, imprima a mensagem:    <code>\"Valor igual a 10\\n\"</code>.</li> <li>Caso contr\u00e1rio, imprima:    <code>\"Valor diferente de 10\\n\"</code>.</li> </ol> <p>Restri\u00e7\u00e3o: use apenas <code>beq</code> e <code>bne</code> para o desvio.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-2-maior-de-dois-numeros","title":"Exerc\u00edcio 2 \u2014 Maior de dois n\u00fameros","text":"<p>Fa\u00e7a um programa que:</p> <ol> <li>Coloque dois valores em <code>t0</code> e <code>t1</code> usando <code>li</code>.</li> <li>Use <code>bgt</code> (pseudo-instru\u00e7\u00e3o) ou a combina\u00e7\u00e3o equivalente com <code>blt</code> para descobrir qual \u00e9 o maior.</li> <li> <p>Imprima:</p> </li> <li> <p><code>\"t0 \u00e9 maior\\n\"</code> se <code>t0 &gt; t1</code></p> </li> <li><code>\"t1 \u00e9 maior ou igual\\n\"</code> caso contr\u00e1rio</li> </ol> <p>Sugest\u00e3o: Use um r\u00f3tulo <code>t0_maior:</code> para o caso em que <code>t0</code> \u00e9 maior, e um r\u00f3tulo <code>fim:</code> para a continua\u00e7\u00e3o.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-3-classificar-numero-lido-do-usuario","title":"Exerc\u00edcio 3 \u2014 Classificar n\u00famero lido do usu\u00e1rio","text":"<p>Escreva um programa que:</p> <ol> <li> <p>Use a syscall de leitura de inteiro (c\u00f3digo 5 em <code>a7</code>) para ler um valor digitado pelo usu\u00e1rio.</p> </li> <li> <p>Copie o valor lido de <code>a0</code> para <code>t0</code>.</p> </li> <li> <p>Classifique o n\u00famero como:</p> </li> <li> <p>negativo (<code>&lt; 0</code>)</p> </li> <li>zero (<code>== 0</code>)</li> <li> <p>positivo (<code>&gt; 0</code>)</p> </li> <li> <p>Imprima uma das mensagens:</p> </li> <li> <p><code>\"Numero negativo\\n\"</code></p> </li> <li><code>\"Numero zero\\n\"</code></li> <li><code>\"Numero positivo\\n\"</code></li> </ol> <p>Restri\u00e7\u00e3o: use apenas <code>blt</code>, <code>beq</code> e <code>j</code> para os desvios.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-4-contador-decrescente-com-beqz","title":"Exerc\u00edcio 4 \u2014 Contador decrescente com <code>beqz</code>","text":"<p>Implemente um contador que:</p> <ol> <li> <p>Come\u00e7a em 10 (por exemplo, em <code>t0</code>).</p> </li> <li> <p>Em cada itera\u00e7\u00e3o do loop:</p> </li> <li> <p>imprime o valor atual em <code>t0</code></p> </li> <li> <p>decrementa <code>t0</code> em 1 (<code>addi t0, t0, -1</code>)</p> </li> <li> <p>Usa <code>beqz</code> para parar quando o contador chegar em 0.</p> </li> <li> <p>Ao final, encerra o programa com a syscall exit2 (c\u00f3digo 93 em <code>a7</code>).</p> </li> </ol>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-5-imprimir-apenas-impares-com-bnez","title":"Exerc\u00edcio 5 \u2014 Imprimir apenas \u00edmpares com <code>bnez</code>","text":"<p>Adapte o exemplo de pares para:</p> <ol> <li>Contar de 1 at\u00e9 20.</li> <li>Calcular <code>t0 &amp; 1</code> usando <code>andi</code>.</li> <li>Imprimir apenas os n\u00fameros \u00edmpares, pulando os pares.</li> </ol> <p>Restri\u00e7\u00e3o: use <code>bnez</code> para decidir se imprime ou n\u00e3o.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-6-contar-quantos-valores-sao-maiores-que-50","title":"Exerc\u00edcio 6 \u2014 Contar quantos valores s\u00e3o maiores que 50","text":"<p>Considere um vetor de 6 inteiros definido em <code>.data</code>, por exemplo:</p> <pre><code>.data\nvet: .word 10, 60, 51, 50, 100, 3\n</code></pre> <p>Fa\u00e7a um programa que:</p> <ol> <li> <p>Percorra o vetor com um loop (usando ponteiro + <code>addi</code> de 4 em 4).</p> </li> <li> <p>Para cada elemento:</p> </li> <li> <p>compare se o valor \u00e9 maior que 50</p> </li> <li> <p>se for, incremente um contador (por exemplo, <code>t2</code>)</p> </li> <li> <p>Ao final, tenha em <code>t2</code> o n\u00famero de elementos maiores que 50.</p> </li> <li> <p>Imprima esse total usando a syscall de inteiro (c\u00f3digo 1 em <code>a7</code>).</p> </li> </ol> <p>Sugest\u00e3o: Use <code>blt</code> ou <code>bgt</code> (pseudo-instru\u00e7\u00e3o) para implementar a compara\u00e7\u00e3o <code>valor &gt; 50</code>.</p>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-7-loop-ate-encontrar-zero-sentinela","title":"Exerc\u00edcio 7 \u2014 Loop at\u00e9 encontrar zero (sentinela)","text":"<p>Crie um vetor terminado em 0, por exemplo:</p> <pre><code>.data\nvalores: .word 3, -1, 7, 9, 0, 5\n</code></pre> <p>Escreva um programa que:</p> <ol> <li> <p>Percorra o vetor do come\u00e7o at\u00e9 encontrar o valor 0.</p> </li> <li> <p>Para cada valor diferente de 0:</p> </li> <li> <p>some o valor em um acumulador (<code>t2</code>, por exemplo)</p> </li> <li> <p>avance para o pr\u00f3ximo elemento</p> </li> <li> <p>Pare o loop assim que encontrar 0, usando <code>beqz</code> ou <code>bnez</code> com o valor lido.</p> </li> <li> <p>Imprima a soma acumulada.</p> </li> </ol>"},{"location":"modulos/modulo%204/mod4.4_comparacoes_e_desvios/#exercicio-8-desafio-funcao-sinal","title":"Exerc\u00edcio 8 (desafio) \u2014 Fun\u00e7\u00e3o sinal","text":"<p>Implemente uma \u201cfun\u00e7\u00e3o de sinal\u201d em assembly:</p> <ul> <li>Entrada: um n\u00famero em <code>a0</code></li> <li>Sa\u00edda: em <code>a0</code></li> </ul> <p>Defini\u00e7\u00e3o:</p> <ul> <li>se <code>a0 &lt; 0</code>, deve retornar <code>-1</code></li> <li>se <code>a0 == 0</code>, deve retornar <code>0</code></li> <li>se <code>a0 &gt; 0</code>, deve retornar <code>1</code></li> </ul> <p>Regras:</p> <ol> <li> <p>Implemente isso como um bloco de c\u00f3digo com r\u00f3tulo, por exemplo <code>sinal:</code>.</p> </li> <li> <p>Use apenas:</p> </li> <li> <p><code>blt</code></p> </li> <li><code>beq</code></li> <li><code>li</code></li> <li> <p><code>j</code></p> </li> <li> <p>No <code>main</code>, teste v\u00e1rios valores chamando esse bloco de c\u00f3digo (voc\u00ea pode s\u00f3 \u201csimular\u201d a chamada colocando valores em <code>a0</code> e fazendo <code>j sinal</code> \u2192 depois usando outro r\u00f3tulo para voltar).</p> </li> </ol>"},{"location":"modulos/modulo%204/mod4.5_saltos/","title":"M\u00f3dulo 4.5. \u2014 Saltos","text":"<p>(<code>j</code>, <code>jal</code>, <code>jalr</code>)</p> <p>Neste m\u00f3dulo voc\u00ea vai aprender como o RISC-V (RISC-V = Reduced Instruction Set Computer \u2013 Five) realiza saltos (jumps) \u2014 mudan\u00e7as expl\u00edcitas no fluxo do programa.</p> <p>Saltos s\u00e3o essenciais para:</p> <ul> <li>loops</li> <li>fun\u00e7\u00f5es</li> <li>desvios condicionais</li> <li>chamadas e retornos entre trechos de c\u00f3digo</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#1-o-que-e-um-salto","title":"1. O que \u00e9 um salto?","text":"<p>Um salto (jump) \u00e9 uma instru\u00e7\u00e3o que altera o PC (Program Counter \u2014 contador de programa), ou seja, o endere\u00e7o da pr\u00f3xima instru\u00e7\u00e3o a ser executada.</p> <p>Em vez de seguir a execu\u00e7\u00e3o linear (linha ap\u00f3s linha), o processador:</p> <p>\u201cpula\u201d para outro endere\u00e7o de c\u00f3digo, normalmente marcado por um r\u00f3tulo (label).</p> <p>Ao contr\u00e1rio das instru\u00e7\u00f5es de desvio condicional (<code>beq</code>, <code>bne</code>, etc.), os saltos deste m\u00f3dulo s\u00e3o incondicionais: sempre acontecem.</p> <p>As tr\u00eas instru\u00e7\u00f5es principais s\u00e3o:</p> <ul> <li><code>j</code> \u2014 salto incondicional simples (pseudo-instru\u00e7\u00e3o)</li> <li><code>jal</code> \u2014 salto que guarda o endere\u00e7o de retorno</li> <li><code>jalr</code> \u2014 salto indireto via registrador (endere\u00e7os din\u00e2micos)</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#2-a-pseudo-instrucao-j-jump","title":"2. A pseudo-instru\u00e7\u00e3o <code>j</code> \u2014 jump","text":"<p><code>j</code> (jump) \u00e9 uma pseudo-instru\u00e7\u00e3o de salto incondicional.</p> <p>Pseudo-instru\u00e7\u00e3o \u00e9 uma \u201cinstru\u00e7\u00e3o de mentira\u201d fornecida pelo montador (assembler): ela n\u00e3o existe no hardware, mas \u00e9 automaticamente traduzida para uma ou mais instru\u00e7\u00f5es reais.</p> <p>No caso de <code>j</code>, o montador converte:</p> <pre><code>j label\n</code></pre> <p>para:</p> <pre><code>jal x0, label\n</code></pre> <p>onde:</p> <ul> <li><code>jal</code> = <code>jal</code> (jump and link), instru\u00e7\u00e3o real que faz salto e guarda endere\u00e7o de retorno</li> <li><code>x0</code> \u00e9 o registrador que sempre vale 0; como o retorno \u00e9 guardado em <code>x0</code>, ele \u00e9 descartado</li> </ul> <p>Em portugu\u00eas simples:</p> <p><code>j label</code> = \u201cpula para <code>label</code> e n\u00e3o guarda retorno\u201d.</p> <p>Exemplo:</p> <pre><code>j loop      # sempre desvia para o r\u00f3tulo 'loop'\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#3-a-instrucao-jal-jump-and-link","title":"3. A instru\u00e7\u00e3o <code>jal</code> \u2014 jump and link","text":"<p><code>jal</code> (jump and link) \u00e9 uma instru\u00e7\u00e3o real da ISA RV32I (ISA = Instruction Set Architecture, arquitetura de conjunto de instru\u00e7\u00f5es).</p> <p>Ela faz duas coisas ao mesmo tempo:</p> <ol> <li>Salva o endere\u00e7o da pr\u00f3xima instru\u00e7\u00e3o em um registrador destino <code>rd</code>.</li> <li>Salta para o r\u00f3tulo indicado.</li> </ol> <p>Sintaxe:</p> <pre><code>jal rd, label\n</code></pre> <p>Significa:</p> <p><code>rd = endere\u00e7o_da_proxima_instru\u00e7\u00e3o</code> depois, PC = endere\u00e7o_do_label</p> <p>Uso t\u00edpico:</p> <ul> <li><code>rd</code> \u00e9 o registrador <code>ra</code> (return address), que \u00e9 o registrador de retorno padr\u00e3o (<code>x1</code>).</li> </ul> <p>Exemplo cl\u00e1ssico de chamada de fun\u00e7\u00e3o:</p> <pre><code>jal ra, funcao    # salva o endere\u00e7o de retorno em ra e pula para 'funcao'\n</code></pre> <p>Para retornar da fun\u00e7\u00e3o, usamos um salto indireto via <code>ra</code>:</p> <ul> <li>pseudo-instru\u00e7\u00e3o <code>ret</code></li> <li>ou a forma expl\u00edcita com <code>jalr</code></li> </ul> <p>Veremos isso a seguir.</p>"},{"location":"modulos/modulo%204/mod4.5_saltos/#4-a-instrucao-jalr-jump-and-link-register","title":"4. A instru\u00e7\u00e3o <code>jalr</code> \u2014 jump and link register","text":"<p><code>jalr</code> (jump and link register) \u00e9 a vers\u00e3o \u201cindireta\u201d de <code>jal</code>: em vez de pular para um label fixo, ela pula para um endere\u00e7o em um registrador.</p> <p>Sintaxe:</p> <pre><code>jalr rd, offset(rs1)\n</code></pre> <p>Significa:</p> <ol> <li><code>rd = endere\u00e7o_da_proxima_instru\u00e7\u00e3o</code></li> <li><code>PC = rs1 + offset</code></li> </ol> <p>Em palavras:</p> <p>Salta para o endere\u00e7o calculado como <code>rs1 + offset</code> e guarda o endere\u00e7o de retorno em <code>rd</code>.</p> <p>Usos comuns:</p> <ul> <li>retorno de fun\u00e7\u00e3o (via pseudo-instru\u00e7\u00e3o <code>ret</code>)</li> <li>saltos din\u00e2micos (tabelas de fun\u00e7\u00e3o, ponteiros de fun\u00e7\u00e3o, etc.)</li> </ul> <p>Exemplo de retorno \u201cpuro\u201d (sem guardar nada):</p> <pre><code>jalr x0, 0(ra)    # PC = ra + 0, n\u00e3o guarda retorno (rd = x0, descartado)\n</code></pre> <p>Essa \u00e9 justamente a forma que o montador usa para implementar a pseudo-instru\u00e7\u00e3o:</p> <pre><code>ret               # montador: jalr x0, 0(ra)\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#5-pseudo-instrucoes-relacionadas-jr-ret","title":"5. Pseudo-instru\u00e7\u00f5es relacionadas (<code>jr</code>, <code>ret</code>)","text":"<ul> <li><code>jr rd</code> (jump register)   Pula para o endere\u00e7o contido em <code>rd</code>, sem guardar retorno.   O montador expande:</li> </ul> <p><code>asm   jr rd          # pseudo</code></p> <p>para:</p> <p><code>asm   jalr x0, 0(rd) # salto indireto sem link (sem retorno)</code></p> <ul> <li><code>ret</code> (return)   Usada como retorno de fun\u00e7\u00e3o, padr\u00e3o da calling convention do RISC-V.</li> </ul> <p>O montador expande:</p> <p><code>asm   ret            # pseudo</code></p> <p>para:</p> <p><code>asm   jalr x0, 0(ra) # PC = ra, n\u00e3o guarda retorno</code></p> <p>onde:</p> <ul> <li><code>ra</code> (return address) \u00e9 o registrador de retorno (<code>x1</code>), definido na ABI   ABI = Application Binary Interface, conven\u00e7\u00e3o de chamada entre fun\u00e7\u00f5es.</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#6-exemplos-completos","title":"6. Exemplos completos","text":"<p>Nesta se\u00e7\u00e3o, al\u00e9m de <code>j</code>, <code>jal</code> e <code>jalr</code>, aparecem algumas instru\u00e7\u00f5es e diretivas:</p> <ul> <li><code>li rd, imm</code> \u2014 <code>li</code> (load immediate): carrega o valor imediato <code>imm</code> no registrador <code>rd</code>.   Ex.: <code>li t0, 0</code> coloca 0 em <code>t0</code>.</li> <li><code>addi rd, rs1, imm</code> \u2014 <code>addi</code> (add immediate): soma imediato a registrador.   Ex.: <code>addi t0, t0, 1</code> \u2192 <code>t0 = t0 + 1</code>.</li> <li><code>blt rs1, rs2, label</code> \u2014 <code>blt</code> (branch if less than): desvia se <code>rs1 &lt; rs2</code>.</li> <li><code>.text</code> \u2014 in\u00edcio da sess\u00e3o de c\u00f3digo (onde ficam instru\u00e7\u00f5es execut\u00e1veis).</li> <li><code>.data</code> \u2014 in\u00edcio da sess\u00e3o de dados (vari\u00e1veis, strings, etc.).</li> <li><code>.globl main</code> \u2014 torna <code>main</code> vis\u00edvel como ponto de entrada.</li> <li><code>.asciz</code> \u2014 string ASCII terminada em byte zero (<code>\\0</code>).</li> <li><code>la rd, label</code> \u2014 <code>la</code> (load address): pseudo-instru\u00e7\u00e3o que carrega o endere\u00e7o do r\u00f3tulo <code>label</code> em <code>rd</code>.</li> <li><code>ecall</code> \u2014 environment call: dispara uma syscall configurada em <code>a7</code>.</li> <li><code>a7</code> \u2014 registrador que indica qual syscall ser\u00e1 chamada (no RARS).</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#61-exemplo-simples-usando-j","title":"6.1 Exemplo simples usando <code>j</code>","text":"<p>Loop que incrementa um contador at\u00e9 5 usando <code>j</code> para voltar:</p> <pre><code>.text\n.globl main\n\nmain:\n    li t0, 0                # li (load immediate): t0 = 0\n\nloop:\n    addi t0, t0, 1          # addi (add immediate): t0 = t0 + 1\n\n    li t1, 5                # t1 = 5\n    blt t0, t1, loop        # blt (branch if less than): se t0 &lt; 5, volta pro r\u00f3tulo 'loop'\n\n    # chegou aqui quando t0 &gt;= 5\nfim:\n    li a7, 93               # li: a7 = 93 \u2192 syscall exit2 (encerrar programa)\n    ecall                   # ecall (environment call): executa a syscall\n</code></pre> <p>Vers\u00e3o com <code>j</code> para loop incondicional:</p> <pre><code>.text\n.globl main\n\nmain:\n    li t0, 0\n\nloop:\n    addi t0, t0, 1          # t0++\n    j loop                  # j (jump): volta para o r\u00f3tulo 'loop' para sempre (loop infinito)\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#62-funcao-simples-usando-jal-e-ret","title":"6.2 Fun\u00e7\u00e3o simples usando <code>jal</code> e <code>ret</code>","text":"<p>Programa que chama uma fun\u00e7\u00e3o <code>ola</code> que imprime uma mensagem:</p> <pre><code>.data\nmsg: .asciz \"Ola!\\n\"        # .asciz: string terminada em 0\n\n.text\n.globl main\n\nmain:\n    jal ra, ola             # jal (jump and link): salva retorno em ra e salta para 'ola'\n\n    li a7, 93               # exit2\n    ecall\n\nola:\n    la a0, msg              # la (load address): a0 = endere\u00e7o de 'msg'\n    li a7, 4                # 4 = syscall print_string\n    ecall                   # imprime \"Ola!\\n\"\n\n    ret                     # ret: jalr x0, 0(ra) \u2192 volta para depois do jal em main\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#63-chamadas-aninhadas-com-jal-e-ret","title":"6.3 Chamadas aninhadas com <code>jal</code> e <code>ret</code>","text":"<p>Aqui vemos <code>main</code> chamando <code>A</code>, que chama <code>B</code>, que chama <code>C</code>:</p> <pre><code>.text\n.globl main\n\nmain:\n    jal ra, A               # chama A\n    li a7, 93               # exit2\n    ecall\n\nA:\n    jal ra, B               # chama B\n    ret                     # retorna para main\n\nB:\n    jal ra, C               # chama C\n    ret                     # retorna para A\n\nC:\n    ret                     # retorna para B\n</code></pre> <p>Em cada n\u00edvel, o endere\u00e7o de retorno \u00e9 automaticamente gerenciado em <code>ra</code>, de acordo com a conven\u00e7\u00e3o de chamada (ABI).</p>"},{"location":"modulos/modulo%204/mod4.5_saltos/#64-uso-de-jalr-para-saltos-indiretos","title":"6.4 Uso de <code>jalr</code> para saltos indiretos","text":"<p>Exemplo did\u00e1tico de salto indireto:</p> <pre><code>.data\nmsg: .asciz \"Salto indireto executado!\\n\"\n\n.text\n.globl main\n\nmain:\n    la t0, destino          # la: t0 recebe o endere\u00e7o do r\u00f3tulo 'destino'\n    jalr ra, 0(t0)          # jalr: salva retorno em ra e salta para endere\u00e7o em t0\n                            # ou seja, salta para 'destino'\n\n    li a7, 93               # exit2\n    ecall\n\ndestino:\n    la a0, msg              # a0 = endere\u00e7o da string\n    li a7, 4                # 4 = print_string\n    ecall                   # imprime \"Salto indireto executado!\\n\"\n    ret                     # volta para depois do jalr em main\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#7-comparacao-entre-j-jal-e-jalr","title":"7. Compara\u00e7\u00e3o entre <code>j</code>, <code>jal</code> e <code>jalr</code>","text":"Instru\u00e7\u00e3o Tipo de salto Guarda endere\u00e7o de retorno? Destino \u00e9 label fixo? Destino via registrador? <code>j</code> incondicional \u274c n\u00e3o \u2714 sim \u274c n\u00e3o <code>jal</code> incondicional \u2714 sim (em <code>rd</code>) \u2714 sim \u274c n\u00e3o <code>jalr</code> incondicional \u2714 sim (em <code>rd</code>) \u274c n\u00e3o \u2714 sim (<code>rs1 + offset</code>)"},{"location":"modulos/modulo%204/mod4.5_saltos/#8-exercicios-para-fixacao","title":"8. Exerc\u00edcios para fixa\u00e7\u00e3o","text":"<p>Use o RARS (RISC-V Assembler and Runtime Simulator) para montar e testar cada exerc\u00edcio. Sempre que usar syscalls:</p> <ul> <li>lembre que <code>a7</code> define qual syscall (por exemplo, <code>4</code> = print_string, <code>1</code> = print_int, <code>93</code> = exit2),</li> <li><code>a0</code> normalmente carrega o argumento (string ou inteiro),</li> <li>e <code>ecall</code> executa a syscall.</li> </ul>"},{"location":"modulos/modulo%204/mod4.5_saltos/#exercicio-1-saltos-simples-com-j","title":"Exerc\u00edcio 1 \u2014 Saltos simples com <code>j</code>","text":"<p>Crie um programa que:</p> <ol> <li>Imprima <code>\"A\\n\"</code>.</li> <li>Use <code>j</code> para pular diretamente para o r\u00f3tulo <code>C</code>.</li> <li>No meio do c\u00f3digo, coloque uma impress\u00e3o <code>\"B\\n\"</code> que n\u00e3o deve ser executada.</li> <li>No r\u00f3tulo <code>C</code>, imprima <code>\"C\\n\"</code>.</li> <li>Encerre o programa com a syscall <code>exit2</code> (c\u00f3digo 93 em <code>a7</code>).</li> </ol> <p>Dica de estrutura:</p> <pre><code>.data\nmsgA: .asciz \"A\\n\"\nmsgB: .asciz \"B\\n\"\nmsgC: .asciz \"C\\n\"\n\n.text\n.globl main\n\nmain:\n    # imprime A\n    # j C\n    # imprime B (n\u00e3o deve rodar)\nC:\n    # imprime C\n    # exit\n</code></pre>"},{"location":"modulos/modulo%204/mod4.5_saltos/#exercicio-2-funcao-quadradon-com-jal-e-ret","title":"Exerc\u00edcio 2 \u2014 Fun\u00e7\u00e3o <code>quadrado(n)</code> com <code>jal</code> e <code>ret</code>","text":"<p>Implemente uma fun\u00e7\u00e3o <code>quadrado</code> em RISC-V que:</p> <ul> <li>recebe um inteiro <code>n</code> em <code>a0</code>,</li> <li>devolve <code>n * n</code> em <code>a0</code>.</li> </ul> <p>Regras:</p> <ol> <li>Em <code>main</code>, carregue um valor em <code>a0</code> (por exemplo, 7).</li> <li>Chame a fun\u00e7\u00e3o com <code>jal ra, quadrado</code>.</li> <li>Ao retornar, imprima o resultado com <code>print_int</code> (syscall 1).</li> <li>Use <code>ret</code> dentro da fun\u00e7\u00e3o para voltar.</li> </ol> <p>Sugest\u00e3o de l\u00f3gica da fun\u00e7\u00e3o:</p> <pre><code>quadrado:\n    # pode usar algum registrador tempor\u00e1rio t0\n    # a0 = a0 * a0  (pode ser soma repetida ou multiplica\u00e7\u00e3o se voc\u00ea j\u00e1 tiver)\n    ret\n</code></pre> <p>(Se ainda n\u00e3o viu multiplica\u00e7\u00e3o, pode usar somas sucessivas s\u00f3 pra fins did\u00e1ticos.)</p>"},{"location":"modulos/modulo%204/mod4.5_saltos/#exercicio-3-chamada-indireta-com-jalr","title":"Exerc\u00edcio 3 \u2014 Chamada indireta com <code>jalr</code>","text":"<p>Fa\u00e7a um programa que:</p> <ol> <li>Carregue em <code>t0</code> o endere\u00e7o de uma fun\u00e7\u00e3o <code>f1</code> usando <code>la</code>.</li> <li>Use <code>jalr ra, 0(t0)</code> para pular at\u00e9 <code>f1</code>.</li> <li>Dentro de <code>f1</code>, imprima uma mensagem, por exemplo <code>\"Chamado por jalr!\\n\"</code>.</li> <li>Retorne com <code>ret</code>.</li> <li>Ao voltar em <code>main</code>, encerre o programa com <code>exit2</code>.</li> </ol> <p>Extens\u00e3o (opcional): crie duas fun\u00e7\u00f5es, <code>f1</code> e <code>f2</code>, e use uma vari\u00e1vel em <code>.data</code> para decidir, em tempo de execu\u00e7\u00e3o, para qual delas pular com <code>jalr</code>.</p>"},{"location":"modulos/modulo%204/mod4.5_saltos/#exercicio-4-loop-reescrito-apenas-com-j","title":"Exerc\u00edcio 4 \u2014 Loop reescrito apenas com <code>j</code>","text":"<p>Pegue um loop que use <code>blt</code> ou <code>bne</code> e reescreva para usar apenas saltos incondicionais e compara\u00e7\u00f5es manuais.</p> <p>Exemplo em C:</p> <pre><code>for (i = 0; i &lt; 5; i++) {\n    // corpo\n}\n</code></pre> <p>Sugerido em assembly:</p> <ol> <li>Iniciar <code>i = 0</code> em <code>t0</code>.</li> <li>No in\u00edcio do loop, comparar <code>i</code> com 5.</li> <li>Se <code>i &gt;= 5</code>, saltar para o fim usando <code>j</code>.</li> <li>Caso contr\u00e1rio, executar o corpo.</li> <li>Incrementar <code>i</code> e usar <code>j</code> para voltar ao teste.</li> </ol> <p>Tente evitar <code>blt</code> e reproduzir a l\u00f3gica usando:</p> <ul> <li><code>bge</code> (se j\u00e1 tiver visto) ou</li> <li>compara\u00e7\u00f5es equivalentes e saltos com <code>j</code>.</li> </ul>"},{"location":"modulos/modulo%205/mod5/","title":"M\u00f3dulo 5 \u2014 Pilha (Stack) e organiza\u00e7\u00e3o da mem\u00f3ria","text":"<p>Neste m\u00f3dulo voc\u00ea vai aprender:</p> <ul> <li>o que \u00e9 a pilha (stack)</li> <li>em que dire\u00e7\u00e3o ela cresce na mem\u00f3ria</li> <li>como reservar espa\u00e7o na pilha</li> <li>como restaurar valores da pilha</li> <li>qual \u00e9 a conven\u00e7\u00e3o de stack frame no RISC-V</li> <li>um exemplo pr\u00e1tico de salvar e recuperar um n\u00famero na pilha</li> </ul> <p>Vou assumir que voc\u00ea j\u00e1 viu fun\u00e7\u00f5es com <code>jal</code> (jump and link) e <code>ret</code> (return), mas tudo que aparecer pela primeira vez aqui (sigla ou instru\u00e7\u00e3o) vai ser explicado.</p>"},{"location":"modulos/modulo%205/mod5/#1-visao-geral-onde-entra-a-pilha-na-memoria","title":"1. Vis\u00e3o geral: onde entra a pilha na mem\u00f3ria?","text":"<p>Quando um programa est\u00e1 rodando, a mem\u00f3ria do processo costuma ser organizada em regi\u00f5es l\u00f3gicas, entre elas:</p> <ul> <li>c\u00f3digo (<code>.text</code>) \u2014 onde ficam as instru\u00e7\u00f5es que o processador executa</li> <li>dados est\u00e1ticos (<code>.data</code>, <code>.bss</code>) \u2014 vari\u00e1veis globais, constantes, strings</li> <li>heap \u2014 \u00e1rea para aloca\u00e7\u00e3o din\u00e2mica (malloc, new etc., em linguagens de alto n\u00edvel)</li> <li>pilha (stack) \u2014 \u00e1rea usada para chamadas de fun\u00e7\u00e3o, vari\u00e1veis locais e salvamento de registradores</li> </ul> <p>Neste m\u00f3dulo vamos focar na pilha.</p>"},{"location":"modulos/modulo%205/mod5/#2-o-que-e-a-pilha-stack","title":"2. O que \u00e9 a pilha (stack)?","text":"<p>A pilha (stack) \u00e9 uma regi\u00e3o da mem\u00f3ria usada como uma estrutura LIFO (LIFO = Last In, First Out, \u201c\u00faltimo a entrar, primeiro a sair\u201d).</p> <p>Voc\u00ea pode imaginar uma pilha de pratos:</p> <ul> <li>o \u00faltimo prato que voc\u00ea coloca em cima \u00e9 o primeiro que voc\u00ea pega de volta</li> <li>na mem\u00f3ria, fazemos o mesmo com valores: empilhar e desempilhar</li> </ul> <p>Na pilha guardamos, principalmente:</p> <ul> <li>endere\u00e7os de retorno (<code>ra</code> \u2014 return address, registrador de retorno)</li> <li>registradores salvos (<code>s0\u2013s11</code> \u2014 saved registers, registradores preservados)</li> <li>vari\u00e1veis locais de uma fun\u00e7\u00e3o</li> <li>par\u00e2metros extras (quando n\u00e3o cabem em <code>a0\u2013a7</code> \u2014 argument registers)</li> </ul>"},{"location":"modulos/modulo%205/mod5/#3-direcao-de-crescimento-da-pilha-no-risc-v","title":"3. Dire\u00e7\u00e3o de crescimento da pilha no RISC-V","text":"<p>No RISC-V (e em muitas arquiteturas), a pilha cresce para endere\u00e7os menores.</p> <ul> <li><code>sp</code> (stack pointer) \u00e9 o registrador que aponta para o topo da pilha.</li> </ul> <p>Regra pr\u00e1tica:</p> <ul> <li>para reservar espa\u00e7o na pilha \u2192 diminu\u00edmos <code>sp</code></li> <li>para liberar espa\u00e7o na pilha \u2192 aumentamos <code>sp</code></li> </ul> <p>Exemplo conceitual:</p> <pre><code>endere\u00e7os altos\n      \u2191\n      \u2502  (mem\u00f3ria)\n      \u2502\n      \u2502      [   ]  \n      \u2502      [   ]  \u2190 valores mais antigos\n      \u2502      [   ]  \n      \u2502      [sp]  \u2190 topo atual da pilha\n      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nendere\u00e7os baixos\n</code></pre> <p>Quando fazemos:</p> <pre><code>addi sp, sp, -4    # addi (add immediate): sp = sp - 4\n</code></pre> <p>estamos \u201cempurrando\u201d o topo da pilha 4 bytes para baixo na mem\u00f3ria e abrindo espa\u00e7o para guardar algo.</p>"},{"location":"modulos/modulo%205/mod5/#4-como-reservar-espaco-na-pilha","title":"4. Como reservar espa\u00e7o na pilha","text":"<ul> <li><code>addi rd, rs1, imediato</code> \u2014 instru\u00e7\u00e3o real <code>addi</code> (add immediate), soma um valor constante (imediato) ao registrador <code>rs1</code> e guarda o resultado em <code>rd</code>.</li> </ul> <p>Sintaxe:</p> <pre><code>addi rd, rs1, imm   # rd = rs1 + imm\n</code></pre> <p>No contexto da pilha, usamos:</p> <pre><code>addi sp, sp, -N     # reserva N bytes na pilha\n</code></pre> <p>Exemplo: reservar 8 bytes para guardar dois valores de 4 bytes (duas words de 32 bits):</p> <pre><code>addi sp, sp, -8    # reserva 8 bytes na pilha\n</code></pre> <p>Agora os 8 bytes \u201cabaixo\u201d do novo <code>sp</code> pertencem \u00e0 fun\u00e7\u00e3o atual.</p>"},{"location":"modulos/modulo%205/mod5/#5-como-guardar-e-restaurar-valores-na-pilha","title":"5. Como guardar e restaurar valores na pilha","text":"<p>Para realmente guardar algo na pilha, combinamos:</p> <ul> <li>ajuste de <code>sp</code> com <code>addi</code></li> <li>instru\u00e7\u00f5es de acesso \u00e0 mem\u00f3ria: <code>sw</code> e <code>lw</code></li> </ul> <p>Primeiras ocorr\u00eancias:</p> <ul> <li><code>sw rs2, offset(rs1)</code> \u2014 <code>sw</code> (store word), grava uma word (32 bits = 4 bytes) da CPU para a mem\u00f3ria.   Significa: \u201cguardar o conte\u00fado de <code>rs2</code> na mem\u00f3ria no endere\u00e7o <code>rs1 + offset</code>\u201d.</li> <li><code>lw rd, offset(rs1)</code> \u2014 <code>lw</code> (load word), l\u00ea uma word da mem\u00f3ria para a CPU.   Significa: \u201ccarregar em <code>rd</code> os 4 bytes armazenados em <code>rs1 + offset</code>\u201d.</li> </ul>"},{"location":"modulos/modulo%205/mod5/#51-guardando-um-valor","title":"5.1 Guardando um valor","text":"<p>Padr\u00e3o:</p> <pre><code>addi sp, sp, -4     # reserva 4 bytes na pilha\nsw   t0, 0(sp)      # sw (store word): guarda o valor de t0 no topo da pilha\n</code></pre>"},{"location":"modulos/modulo%205/mod5/#52-restaurando-esse-valor","title":"5.2 Restaurando esse valor","text":"<p>Mais tarde:</p> <pre><code>lw   t0, 0(sp)      # lw (load word): l\u00ea o valor de volta para t0\naddi sp, sp, 4      # libera os 4 bytes usados na pilha\n</code></pre> <p>Regra de ouro:</p> <p>A quantidade que voc\u00ea subtraiu de <code>sp</code> para reservar deve ser somada de volta para liberar.</p>"},{"location":"modulos/modulo%205/mod5/#6-stack-frame-e-convencao-de-salvamento","title":"6. Stack frame e conven\u00e7\u00e3o de salvamento","text":"<ul> <li> <p>Stack frame \u00e9 o \u201cpacote\u201d de mem\u00f3ria que cada fun\u00e7\u00e3o reserva na pilha para armazenar:</p> </li> <li> <p>registradores salvos (<code>s0\u2013s11</code>)</p> </li> <li>registrador de retorno (<code>ra</code>)</li> <li>vari\u00e1veis locais</li> <li>espa\u00e7o para argumentos extras (se preciso)</li> </ul> <p>Na ABI (Application Binary Interface) do RISC-V, a regra \u00e9:</p> <ul> <li>registradores salvos (<code>s0\u2013s11</code>) devem ser restaurados pela fun\u00e7\u00e3o que os usa</li> <li>se a fun\u00e7\u00e3o chamar outra fun\u00e7\u00e3o com <code>jal</code> (jump and link), ela geralmente precisa salvar <code>ra</code> na pilha</li> <li><code>sp</code> deve apontar para o topo do stack frame atual</li> </ul>"},{"location":"modulos/modulo%205/mod5/#61-exemplo-de-stack-frame-simples","title":"6.1 Exemplo de stack frame simples","text":"<p>Vamos salvar <code>ra</code> e <code>s0</code> na pilha:</p> <pre><code>minha_funcao:\n    addi sp, sp, -8     # reserva 8 bytes na pilha\n    sw   ra, 4(sp)      # guarda ra na pilha (offset 4)\n    sw   s0, 0(sp)      # guarda s0 na pilha (offset 0)\n\n    # --- corpo da fun\u00e7\u00e3o ---\n    # usa s0 como vari\u00e1vel local, etc.\n\n    lw   s0, 0(sp)      # restaura s0\n    lw   ra, 4(sp)      # restaura ra\n    addi sp, sp, 8      # libera 8 bytes\n    ret                 # ret (return): montado como jalr x0, 0(ra)\n</code></pre> <ul> <li><code>ret</code> \u00e9 uma pseudo-instru\u00e7\u00e3o de retorno de fun\u00e7\u00e3o.   O montador converte para <code>jalr x0, 0(ra)</code> \u2192 salto indireto usando o endere\u00e7o em <code>ra</code>.</li> </ul>"},{"location":"modulos/modulo%205/mod5/#7-exemplo-pratico-salvar-um-numero-na-pilha","title":"7. Exemplo pr\u00e1tico: salvar um n\u00famero na pilha","text":"<p>Vamos fazer um programa simples que:</p> <ol> <li>coloca o valor <code>42</code> em um registrador</li> <li>salva esse valor na pilha</li> <li>zera o registrador para \u201cprovar\u201d que o valor foi perdido</li> <li>recupera o valor da pilha para outro registrador</li> <li>imprime o valor recuperado</li> <li>encerra o programa</li> </ol> <p>Tamb\u00e9m vamos usar syscalls do RARS (RISC-V Assembler and Runtime Simulator):</p> <p>Primeiras ocorr\u00eancias aqui:</p> <ul> <li>Syscall (system call) \u2014 servi\u00e7o fornecido pelo ambiente do simulador, como imprimir ou ler.</li> <li><code>a7</code> \u2014 registrador que escolhe qual syscall ser\u00e1 executada.</li> <li><code>a0</code> \u2014 registrador usado para argumento e retorno das syscalls.</li> <li><code>ecall</code> \u2014 instru\u00e7\u00e3o environment call, dispara a syscall escolhida em <code>a7</code>.</li> </ul> <p>Tabela usada:</p> <ul> <li><code>a7 = 1</code> \u2192 print_int (imprimir inteiro em <code>a0</code>)</li> <li><code>a7 = 11</code> \u2192 print_char (imprimir caractere em <code>a0</code>)</li> <li><code>a7 = 93</code> \u2192 exit2 (encerrar programa)</li> </ul>"},{"location":"modulos/modulo%205/mod5/#71-codigo-completo-e-comentado","title":"7.1 C\u00f3digo completo e comentado","text":"<pre><code>.text                      # .text: in\u00edcio da sess\u00e3o de c\u00f3digo (instru\u00e7\u00f5es)\n.globl main                # .globl (global): torna 'main' vis\u00edvel como ponto de entrada\n\nmain:\n    li   t0, 42            # li (load immediate): coloca o valor 42 no registrador t0\n\n    # --- salvar t0 na pilha ---\n    addi sp, sp, -4        # addi (add immediate): sp = sp - 4, reserva 4 bytes na pilha\n    sw   t0, 0(sp)         # sw (store word): guarda o valor de t0 nesses 4 bytes\n\n    # \"perder\" o valor original de t0\n    li   t0, 0             # li: agora t0 = 0, valor 42 n\u00e3o est\u00e1 mais no registrador\n\n    # --- recuperar o valor salvo ---\n    lw   t1, 0(sp)         # lw (load word): carrega da pilha para t1 o valor que estava salvo (42)\n    addi sp, sp, 4         # addi: sp = sp + 4, libera os 4 bytes usados na pilha\n\n    # --- imprimir o valor recuperado ---\n    mv   a0, t1            # mv (move): copia o valor de t1 para a0 (argumento da syscall)\n    li   a7, 1             # li: a7 = 1 \u2192 syscall print_int (imprimir inteiro)\n    ecall                  # ecall (environment call): executa a syscall, imprime 42\n\n    # opcional: imprimir quebra de linha\n    li   a0, 10            # li: a0 = 10, c\u00f3digo ASCII de '\\n'\n    li   a7, 11            # li: a7 = 11 \u2192 syscall print_char (imprimir caractere)\n    ecall                  # ecall: imprime '\\n'\n\n    # --- encerrar programa ---\n    li   a7, 93            # li: a7 = 93 \u2192 syscall exit2 (encerrar execu\u00e7\u00e3o)\n    ecall                  # ecall: encerra o programa\n</code></pre> <p>Resumo do que acontece:</p> <ul> <li>o valor 42 \u00e9 salvo na mem\u00f3ria (pilha), mesmo depois de <code>t0</code> ser alterado</li> <li>ao restaurar com <code>lw</code>, recuperamos esse valor em <code>t1</code></li> <li>provamos que a pilha \u00e9 um lugar seguro para guardar valores tempor\u00e1rios</li> </ul>"},{"location":"modulos/modulo%205/mod5/#8-recapitulando","title":"8. Recapitulando","text":"<p>Neste m\u00f3dulo voc\u00ea viu:</p> <ul> <li>o que \u00e9 a pilha (stack) e que ela funciona no modelo LIFO (Last In, First Out)</li> <li>que o registrador <code>sp</code> (stack pointer) aponta para o topo da pilha</li> <li>que no RISC-V a pilha cresce para endere\u00e7os menores</li> <li>como reservar espa\u00e7o com <code>addi sp, sp, -N</code></li> <li>como salvar valores com <code>sw</code> e depois restaurar com <code>lw</code></li> <li>a ideia de stack frame: espa\u00e7o na pilha reservado por cada fun\u00e7\u00e3o</li> <li>como salvar e restaurar <code>ra</code> e registradores salvos (<code>s0\u2013s11</code>) seguindo a ABI (Application Binary Interface)</li> <li>um exemplo completo que empilha um valor, zera o registrador e recupera o valor da pilha</li> </ul>"},{"location":"modulos/modulo%205/mod5/#9-exercicios-para-fixacao","title":"9. Exerc\u00edcios para fixa\u00e7\u00e3o","text":"<p>Tente fazer no RARS. Se quiser, voc\u00ea pode me mandar suas solu\u00e7\u00f5es para corre\u00e7\u00e3o detalhada.</p>"},{"location":"modulos/modulo%205/mod5/#exercicio-1-salvar-e-restaurar-dois-registradores","title":"Exerc\u00edcio 1 \u2014 Salvar e restaurar dois registradores","text":"<p>Implemente um programa que:</p> <ol> <li>Carregue o valor <code>10</code> em <code>t0</code> e o valor <code>20</code> em <code>t1</code>.</li> <li>Salve ambos na pilha (use <code>addi sp, sp, -8</code>, <code>sw</code> com offsets diferentes).</li> <li>Zere <code>t0</code> e <code>t1</code> com <code>li</code> para simular \u201cperda\u201d dos valores.</li> <li>Restaure <code>t0</code> e <code>t1</code> a partir da pilha usando <code>lw</code>.</li> <li>Some <code>t0 + t1</code> em <code>t2</code> e imprima o resultado com a syscall <code>print_int</code> (c\u00f3digo 1).</li> </ol>"},{"location":"modulos/modulo%205/mod5/#exercicio-2-funcao-que-usa-stack-frame-simples","title":"Exerc\u00edcio 2 \u2014 Fun\u00e7\u00e3o que usa stack frame simples","text":"<p>Crie:</p> <ul> <li> <p>uma fun\u00e7\u00e3o <code>add5</code> que:</p> </li> <li> <p>recebe um n\u00famero em <code>a0</code>;</p> </li> <li>salva <code>ra</code> e <code>s0</code> na pilha;</li> <li>copia <code>a0</code> para <code>s0</code> (vari\u00e1vel local);</li> <li>calcula <code>a0 = s0 + 5</code>;</li> <li>restaura <code>s0</code> e <code>ra</code> da pilha;</li> <li> <p>faz <code>ret</code>.</p> </li> <li> <p>na <code>main</code>:</p> </li> <li> <p>coloque <code>20</code> em <code>a0</code>;</p> </li> <li>chame <code>add5</code> com <code>jal ra, add5</code>;</li> <li>ao voltar, imprima o valor em <code>a0</code> com <code>print_int</code>.</li> </ul>"},{"location":"modulos/modulo%205/mod5/#exercicio-3-salvar-um-valor-temporario-durante-uma-conta","title":"Exerc\u00edcio 3 \u2014 Salvar um valor tempor\u00e1rio durante uma conta","text":"<p>Fa\u00e7a um programa que:</p> <ol> <li>Calcule <code>t0 = 7</code> e <code>t1 = 9</code> usando <code>li</code>.</li> <li>Some <code>t0 + t1</code> e salve o resultado na pilha.</li> <li>Em seguida, calcule um novo valor em <code>t0</code> (por exemplo, <code>t0 = 100</code>) e em <code>t1</code> (<code>t1 = 200</code>).</li> <li>Restaure da pilha o valor antigo da soma para <code>t2</code>.</li> <li>Some <code>t2 + t0 + t1</code> e imprima o resultado final.</li> </ol> <p>Use sempre a sequ\u00eancia correta:</p> <ul> <li>ajustar <code>sp</code> com <code>addi</code> antes de <code>sw</code></li> <li>usar <code>lw</code> antes de devolver <code>sp</code> ao valor original.</li> </ul>"},{"location":"modulos/modulo%206/mod6/","title":"M\u00f3dulo 6 \u2014 Multiplication &amp; Division","text":"<p>Este m\u00f3dulo apresenta a extens\u00e3o M do RISC-V (M de Multiply/Divide), que adiciona instru\u00e7\u00f5es de:</p> <ul> <li>multiplica\u00e7\u00e3o inteira</li> <li>divis\u00e3o inteira</li> <li>resto de divis\u00e3o inteira</li> <li>acesso \u00e0 parte alta do produto</li> </ul> <p>Sem a extens\u00e3o M (ou seja, usando apenas RV32I \u2014 RISC-V 32-bit Integer), voc\u00ea teria que implementar multiplica\u00e7\u00e3o e divis\u00e3o manualmente, com la\u00e7os de somas e subtra\u00e7\u00f5es. Com RV32IM, o hardware j\u00e1 faz isso para voc\u00ea.</p>"},{"location":"modulos/modulo%206/mod6/#1-o-que-e-a-extensao-m-no-risc-v","title":"1. O que \u00e9 a extens\u00e3o M no RISC-V?","text":"<p>O RISC-V \u00e9 definido em \u201cm\u00f3dulos\u201d de instru\u00e7\u00f5es. O n\u00facleo b\u00e1sico \u00e9 o I (Integer), e extens\u00f5es acrescentam funcionalidades.</p> <p>Alguns conjuntos comuns:</p> <ul> <li>RV32I \u2013 apenas instru\u00e7\u00f5es inteiras b\u00e1sicas</li> <li>RV32IM \u2013 I + M (multiplica\u00e7\u00e3o e divis\u00e3o inteiras)</li> <li>RV32IMF \u2013 adiciona tamb\u00e9m ponto flutuante, etc.</li> </ul> <p>A extens\u00e3o M adiciona estas instru\u00e7\u00f5es inteiras:</p> <ul> <li><code>mul</code> \u2014 multiplica\u00e7\u00e3o inteira (parte baixa)</li> <li><code>mulh</code>, <code>mulhu</code>, <code>mulhsu</code> \u2014 multiplica\u00e7\u00e3o retornando a parte alta do resultado</li> <li><code>div</code>, <code>divu</code> \u2014 divis\u00e3o inteira (quociente)</li> <li><code>rem</code>, <code>remu</code> \u2014 resto da divis\u00e3o inteira</li> </ul> <p>No RARS (RISC-V Assembler and Runtime Simulator), voc\u00ea normalmente j\u00e1 est\u00e1 usando um modo que suporta RV32IM.</p>"},{"location":"modulos/modulo%206/mod6/#2-conceitos-importantes-32-bits-produto-de-64-bits","title":"2. Conceitos importantes: 32 bits, produto de 64 bits","text":"<p>No RV32, cada registrador tem 32 bits. Quando voc\u00ea multiplica dois inteiros de 32 bits, o resultado completo tem at\u00e9 64 bits.</p> <p>Exemplo conceitual:</p> <pre><code>(a: 32 bits) \u00d7 (b: 32 bits) \u2192 resultado: 64 bits\n\nparte alta  = bits [63:32]\nparte baixa = bits [31:0]\n</code></pre> <p>As instru\u00e7\u00f5es se dividem assim:</p> <ul> <li><code>mul</code>   \u2192 devolve a parte baixa (bits [31:0])</li> <li><code>mulh</code>  \u2192 devolve a parte alta considerando operandos com sinal</li> <li><code>mulhu</code> \u2192 devolve a parte alta considerando operandos sem sinal (unsigned)</li> <li><code>mulhsu</code>\u2192 devolve a parte alta considerando o primeiro operando com sinal e o segundo sem sinal</li> </ul> <p>Para divis\u00e3o:</p> <ul> <li><code>div</code> / <code>rem</code>   \u2192 trabalham com n\u00fameros com sinal (inteiros 2\u2019s complement)</li> <li><code>divu</code> / <code>remu</code> \u2192 trabalham com n\u00fameros sem sinal (unsigned)</li> </ul>"},{"location":"modulos/modulo%206/mod6/#3-multiplicacao-inteira-simples-mul","title":"3. Multiplica\u00e7\u00e3o inteira simples: <code>mul</code>","text":"<p>A instru\u00e7\u00e3o <code>mul</code> faz:</p> <pre><code>rd = (rs1 * rs2) mod 2^32\n</code></pre> <p>Ou seja, guarda apenas a parte baixa do produto (32 bits). Se houver overflow, os bits \u201cque sobraram\u201d s\u00e3o descartados.</p> <p>Sintaxe:</p> <pre><code>mul rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd</code> recebe o resultado da multiplica\u00e7\u00e3o de <code>rs1</code> por <code>rs2</code>.</p> <p>Exemplo simples:</p> <pre><code>.text\n.globl main\n\nmain:\n    li t0, 6              # li (load immediate): t0 = 6\n    li t1, 7              # t1 = 7\n\n    mul t2, t0, t1        # mul: t2 = t0 * t1 = 42\n\n    # imprimir resultado no RARS\n    mv a0, t2             # mv (move): a0 = t2\n    li a7, 1              # 1 = print_int\n    ecall\n\n    li a7, 93             # 93 = exit2\n    ecall\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#4-multiplicacao-com-parte-alta-mulh-mulhu-mulhsu","title":"4. Multiplica\u00e7\u00e3o com parte alta: <code>mulh</code>, <code>mulhu</code>, <code>mulhsu</code>","text":"<p>Quando voc\u00ea realmente precisa do resultado completo de 64 bits (ou quer detectar overflow), entra a fam\u00edlia <code>mulh</code>.</p>"},{"location":"modulos/modulo%206/mod6/#41-mulh-rd-rs1-rs2","title":"4.1 <code>mulh rd, rs1, rs2</code>","text":"<p>Multiplica\u00e7\u00e3o com sinal em ambos os operandos.</p> <pre><code>rs1 e rs2 tratados como inteiros com sinal (signed 32 bits)\nproduto completo: 64 bits\nrd = parte alta do produto (bits [63:32])\n</code></pre> <p>Sintaxe:</p> <pre><code>mulh rd, rs1, rs2\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#42-mulhu-rd-rs1-rs2","title":"4.2 <code>mulhu rd, rs1, rs2</code>","text":"<p>Multiplica\u00e7\u00e3o sem sinal em ambos os operandos.</p> <pre><code>rs1 e rs2 tratados como unsigned\nrd = parte alta do produto\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#43-mulhsu-rd-rs1-rs2","title":"4.3 <code>mulhsu rd, rs1, rs2</code>","text":"<p>Multiplica\u00e7\u00e3o mista:</p> <ul> <li><code>rs1</code> tratado como signed</li> <li><code>rs2</code> tratado como unsigned</li> </ul> <p>Isso \u00e9 \u00fatil em algumas rotinas de aritm\u00e9tica de precis\u00e3o ou otimiza\u00e7\u00f5es espec\u00edficas (por exemplo, divis\u00e3o por constantes usando multiplica\u00e7\u00e3o por fator pr\u00e9-calculado).</p>"},{"location":"modulos/modulo%206/mod6/#44-combinando-mul-mulh-para-obter-64-bits","title":"4.4 Combinando <code>mul</code> + <code>mulh</code> para obter 64 bits","text":"<p>Suponha que voc\u00ea queira o produto completo de 64 bits de <code>a * b</code>:</p> <pre><code># a em t0, b em t1\nmul  t2, t0, t1     # parte baixa  (low  32 bits)\nmulh t3, t0, t1     # parte alta   (high 32 bits)\n# Agora t3:t2 representa um inteiro de 64 bits\n</code></pre> <p>Em nota\u00e7\u00e3o \u201cconcatenada\u201d: <code>resultado_64 = (t3 &lt;&lt; 32) | t2</code>.</p>"},{"location":"modulos/modulo%206/mod6/#5-divisao-inteira-div-e-divu","title":"5. Divis\u00e3o inteira: <code>div</code> e <code>divu</code>","text":""},{"location":"modulos/modulo%206/mod6/#51-div-rd-rs1-rs2-divisao-com-sinal","title":"5.1 <code>div rd, rs1, rs2</code> \u2014 divis\u00e3o com sinal","text":"<p>Calcula o quociente da divis\u00e3o inteira de <code>rs1</code> por <code>rs2</code>, tratando os operandos como inteiros com sinal (signed).</p> <p>Sintaxe:</p> <pre><code>div rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd = rs1 / rs2</code> (divis\u00e3o inteira com sinal, truncando em dire\u00e7\u00e3o a zero).</p> <p>Exemplo:</p> <pre><code>li t0,  7\nli t1,  2\ndiv t2, t0, t1      # t2 = 3   (7 / 2 = 3)\n\nli t0, -7\nli t1,  2\ndiv t3, t0, t1      # t3 = -3  (-7 / 2 = -3, truncado em dire\u00e7\u00e3o a 0)\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#52-divu-rd-rs1-rs2-divisao-sem-sinal","title":"5.2 <code>divu rd, rs1, rs2</code> \u2014 divis\u00e3o sem sinal","text":"<p>Mesma ideia, mas os operandos s\u00e3o interpretados como unsigned (sem sinal).</p> <p>Sintaxe:</p> <pre><code>divu rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd = (unsigned)rs1 / (unsigned)rs2</code></p> <p>Isso faz diferen\u00e7a quando os operandos t\u00eam o bit mais significativo (bit 31) igual a 1.</p>"},{"location":"modulos/modulo%206/mod6/#6-resto-da-divisao-rem-e-remu","title":"6. Resto da divis\u00e3o: <code>rem</code> e <code>remu</code>","text":"<p>A fam\u00edlia <code>rem</code> devolve o resto da divis\u00e3o inteira:</p> <pre><code>rs1 = divisor\nrs2 = divisor\nquociente  = rs1 / rs2\nresto      = rs1 - (quociente * rs2)\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#61-rem-rd-rs1-rs2-resto-com-sinal","title":"6.1 <code>rem rd, rs1, rs2</code> \u2014 resto com sinal","text":"<p>Trata os operandos como inteiros com sinal.</p> <p>Sintaxe:</p> <pre><code>rem rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd = resto da divis\u00e3o inteira de rs1 por rs2 (signed)</code></p> <p>Em geral, o sinal do resto segue o sinal do dividendo (<code>rs1</code>).</p> <p>Exemplo:</p> <pre><code>li t0,  7\nli t1,  2\nrem t2, t0, t1      # t2 = 1  (7 = 3*2 + 1)\n\nli t0, -7\nli t1,  2\nrem t3, t0, t1      # t3 = -1  (-7 = -3*2 + (-1))\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#62-remu-rd-rs1-rs2-resto-sem-sinal","title":"6.2 <code>remu rd, rs1, rs2</code> \u2014 resto sem sinal","text":"<p>Mesma l\u00f3gica, mas com operandos unsigned:</p> <pre><code>remu rd, rs1, rs2\n</code></pre> <p>Significa:</p> <p><code>rd = resto da divis\u00e3o (unsigned)</code></p> <p>Importante em algoritmos que tratam os valores como conjuntos de bits, n\u00e3o como n\u00fameros positivos/negativos.</p>"},{"location":"modulos/modulo%206/mod6/#7-comportamento-especial-divisao-por-zero","title":"7. Comportamento especial: divis\u00e3o por zero","text":"<p>A especifica\u00e7\u00e3o do RISC-V define um comportamento espec\u00edfico quando o divisor (<code>rs2</code>) \u00e9 zero:</p> <ul> <li> <p>em <code>div</code> / <code>divu</code>:</p> </li> <li> <p>o quociente \u00e9 definido como -1 (tudo em 1, para signed) ou 0xFFFF_FFFF (para unsigned)</p> </li> <li> <p>em <code>rem</code> / <code>remu</code>:</p> </li> <li> <p>o resto \u00e9 simplesmente o valor do dividendo (<code>rs1</code>)</p> </li> </ul> <p>Na pr\u00e1tica:</p> <ul> <li><code>div t0, x, zero</code>  \u2192 t0 recebe um valor especial (normalmente -1)</li> <li><code>rem t1, x, zero</code>  \u2192 t1 recebe <code>x</code></li> </ul> <p>Mesmo assim, \u00e9 boa pr\u00e1tica evitar dividir por zero e tratar isso com testes usando <code>beq</code>/<code>bne</code>.</p>"},{"location":"modulos/modulo%206/mod6/#8-exemplos-completos","title":"8. Exemplos completos","text":""},{"location":"modulos/modulo%206/mod6/#81-multiplicacao-e-divisao-basicas","title":"8.1 Multiplica\u00e7\u00e3o e divis\u00e3o b\u00e1sicas","text":"<p>Programa que faz:</p> <ol> <li><code>a = 20</code>, <code>b = 6</code></li> <li>calcula <code>produto = a * b</code></li> <li>calcula <code>quociente = a / b</code></li> <li>calcula <code>resto = a % b</code></li> <li>imprime os tr\u00eas resultados no RARS</li> </ol> <pre><code>.data\nmsgProd: .asciz \"Produto: \"\nmsgQuoc: .asciz \"Quociente: \"\nmsgResto:.asciz \"Resto: \"\nmsgNL:   .asciz \"\\n\"\n\n.text\n.globl main\n\nmain:\n    li t0, 20              # a = 20\n    li t1, 6               # b = 6\n\n    # produto\n    mul t2, t0, t1         # t2 = 20 * 6 = 120\n\n    # quociente\n    div t3, t0, t1         # t3 = 20 / 6 = 3 (inteiro)\n\n    # resto\n    rem t4, t0, t1         # t4 = 20 % 6 = 2\n\n    # imprimir produto\n    la a0, msgProd         # endere\u00e7o da string \"Produto: \"\n    li a7, 4               # 4 = print_string\n    ecall\n\n    mv a0, t2              # valor do produto\n    li a7, 1               # 1 = print_int\n    ecall\n\n    la a0, msgNL\n    li a7, 4\n    ecall\n\n    # imprimir quociente\n    la a0, msgQuoc\n    li a7, 4\n    ecall\n\n    mv a0, t3\n    li a7, 1\n    ecall\n\n    la a0, msgNL\n    li a7, 4\n    ecall\n\n    # imprimir resto\n    la a0, msgResto\n    li a7, 4\n    ecall\n\n    mv a0, t4\n    li a7, 1\n    ecall\n\n    la a0, msgNL\n    li a7, 4\n    ecall\n\n    # sair\n    li a7, 93              # exit2\n    ecall\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#82-usando-mulh-para-detectar-overflow","title":"8.2 Usando <code>mulh</code> para detectar overflow","text":"<p>Suponha que voc\u00ea quer multiplicar dois inteiros e verificar se houve overflow (produto n\u00e3o coube em 32 bits).</p> <p>Se a parte alta do produto for diferente de zero (ou de -1 em caso de sinais espec\u00edficos), significa que o resultado ultrapassou o intervalo que cabe num registrador de 32 bits.</p> <p>Exemplo simples: marcar overflow se a parte alta n\u00e3o \u00e9 zero:</p> <pre><code>.text\n.globl main\n\nmain:\n    li t0, 100000          # operando 1\n    li t1, 100000          # operando 2\n\n    mul  t2, t0, t1        # parte baixa\n    mulh t3, t0, t1        # parte alta\n\n    # se t3 != 0, houve overflow\n    bne t3, x0, tem_overflow\n\n    # aqui: sem overflow\n    # (t2 cont\u00e9m o resultado completo)\n    j fim\n\ntem_overflow:\n    # aqui voc\u00ea pode tratar o caso de overflow\n    # (ex.: imprimir mensagem de erro)\nfim:\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#83-comparando-div-e-divu","title":"8.3 Comparando <code>div</code> e <code>divu</code>","text":"<p>C\u00f3digo para ajudar a visualizar a diferen\u00e7a entre divis\u00e3o com sinal e sem sinal:</p> <pre><code>.text\n.globl main\n\nmain:\n    li t0, -8              # valor negativo em t0\n    li t1,  3\n\n    div  t2, t0, t1        # divis\u00e3o com sinal   \u2192 t2 esperado: -2\n    divu t3, t0, t1        # divis\u00e3o sem sinal   \u2192 t3: interpretando t0 como unsigned\n\n    # aqui voc\u00ea pode imprimir t2 e t3 para comparar\n    # (exerc\u00edcio sugerido abaixo)\n\n    li a7, 93\n    ecall\n</code></pre>"},{"location":"modulos/modulo%206/mod6/#9-por-que-a-extensao-m-e-importante","title":"9. Por que a extens\u00e3o M \u00e9 importante?","text":"<p>Sem a extens\u00e3o M:</p> <ul> <li><code>mul</code> teria que ser simulada com um la\u00e7o de somas sucessivas</li> <li><code>div</code> e <code>rem</code> teriam que ser implementadas com la\u00e7os de subtra\u00e7\u00e3o repetida ou algoritmos mais complexos (como divis\u00e3o bin\u00e1ria)</li> </ul> <p>Isso \u00e9 \u00f3timo para aprender aritm\u00e9tica em baixo n\u00edvel, mas:</p> <ul> <li>\u00e9 muito mais lento</li> <li>o c\u00f3digo fica grande e complicado</li> </ul> <p>Na pr\u00e1tica, quase todos os processadores RISC-V \u201cde verdade\u201d incluem a extens\u00e3o M, e os simuladores (como RARS) tamb\u00e9m.</p>"},{"location":"modulos/modulo%206/mod6/#10-exercicios-para-fixacao","title":"10. Exerc\u00edcios para fixa\u00e7\u00e3o","text":"<p>Use o RARS para montar e rodar seus c\u00f3digos, e observe os registradores no painel de execu\u00e7\u00e3o.</p>"},{"location":"modulos/modulo%206/mod6/#exercicio-1-produto-e-quociente","title":"Exerc\u00edcio 1 \u2014 Produto e quociente","text":"<p>Escreva um programa que:</p> <ol> <li>Coloque dois inteiros em registradores (por exemplo, <code>a</code> em <code>t0</code>, <code>b</code> em <code>t1</code>).</li> <li>Use <code>mul</code> para calcular o produto em <code>t2</code>.</li> <li>Use <code>div</code> para calcular o quociente em <code>t3</code>.</li> <li>Use <code>rem</code> para calcular o resto em <code>t4</code>.</li> <li> <p>Imprima, com <code>print_int</code> (syscall 1):</p> </li> <li> <p>o produto</p> </li> <li>o quociente</li> <li>o resto</li> </ol> <p>em linhas separadas.</p>"},{"location":"modulos/modulo%206/mod6/#exercicio-2-produto-de-64-bits-com-mul-mulh","title":"Exerc\u00edcio 2 \u2014 Produto de 64 bits com <code>mul</code> + <code>mulh</code>","text":"<p>Implemente:</p> <ol> <li> <p>Leia dois inteiros do usu\u00e1rio (2 vezes <code>read_int</code>, syscall 5).</p> </li> <li> <p>Calcule o produto completo de 64 bits:</p> </li> <li> <p>parte baixa em um registrador</p> </li> <li> <p>parte alta em outro registrador</p> </li> <li> <p>Imprima os dois valores:</p> </li> <li> <p>primeiro a parte alta</p> </li> <li>depois a parte baixa</li> </ol> <p>Dica: use a combina\u00e7\u00e3o <code>mul</code> + <code>mulh</code>.</p>"},{"location":"modulos/modulo%206/mod6/#exercicio-3-testando-div-vs-divu","title":"Exerc\u00edcio 3 \u2014 Testando <code>div</code> vs <code>divu</code>","text":"<p>Escreva um programa que:</p> <ol> <li> <p>Coloque em <code>t0</code> um valor negativo (por exemplo, <code>-8</code>).</p> </li> <li> <p>Coloque em <code>t1</code> o valor <code>3</code>.</p> </li> <li> <p>Calcule:</p> </li> <li> <p><code>div t2, t0, t1</code></p> </li> <li> <p><code>divu t3, t0, t1</code></p> </li> <li> <p>Imprima ambos os resultados (<code>t2</code> e <code>t3</code>) usando <code>print_int</code>, com mensagens indicando qual \u00e9 qual.</p> </li> <li> <p>Observe no RARS:</p> </li> <li> <p>o que acontece com a divis\u00e3o com sinal</p> </li> <li>o que acontece com a divis\u00e3o sem sinal</li> </ol> <p>Voc\u00ea pode alterar os valores e repetir o teste para outros casos.</p>"},{"location":"prova/p2/","title":"P2","text":"<p>RV32IMFDN</p>"},{"location":"prova/p2/#questao-1-ao-estudarmos-o-caminho-de-dados-modulos-digitais-basicos-foram-integrados-para-criar-o-nucleo-de-um-sistema-computacional-nucleo-capaz-de-executar-instrucoes-lidas-a-partir-da-memoria-sobre-o-caminho-de-dados-responda","title":"Quest\u00e3o 1 \u2013 Ao estudarmos o Caminho de Dados, m\u00f3dulos digitais b\u00e1sicos foram integrados para criar o n\u00facleo de um sistema computacional, n\u00facleo capaz de executar instru\u00e7\u00f5es lidas a partir da mem\u00f3ria. Sobre o Caminho de Dados, responda:","text":""},{"location":"prova/p2/#a-descreva-o-modelo-uniciclo","title":"a) Descreva o modelo uniciclo.","text":"<p>No modelo uniciclo, cada instru\u00e7\u00e3o percorre todas as fases (buscar, decodificar, executar, acessar mem\u00f3ria e escrever resultado) em um \u00fanico ciclo de clock, o que simplifica o hardware, mas obriga o clock a ser t\u00e3o lento quanto a instru\u00e7\u00e3o mais demorada.</p>"},{"location":"prova/p2/#b-descreva-o-modelo-multiciclo-deixando-claro-em-sua-resposta-as-etapas-utilizadas-para-garantir-a-execucao-de-uma-instrucao","title":"b) Descreva o modelo multiciclo, deixando claro em sua resposta as etapas utilizadas para garantir a execu\u00e7\u00e3o de uma instru\u00e7\u00e3o.","text":"<p>No modelo multiciclo, cada instru\u00e7\u00e3o \u00e9 dividida em v\u00e1rios ciclos de clock, reutilizando o mesmo hardware em etapas diferentes. As cinco etapas s\u00e3o: busca da instru\u00e7\u00e3o na mem\u00f3ria (Fetch), decodifica\u00e7\u00e3o e leitura de registradores (Decode), execu\u00e7\u00e3o ou c\u00e1lculo de endere\u00e7o (Execute), acesso \u00e0 mem\u00f3ria (Memory) e escrita do resultado no registrador de destino (Writeback).</p>"},{"location":"prova/p2/#c-o-pipeline-e-uma-evolucao-aplicada-ao-modelo-multiciclo-como-esse-arranjo-melhora-o-desempenho-computacional-da-arquitetura-multiciclo","title":"c) O Pipeline \u00e9 uma evolu\u00e7\u00e3o aplicada ao modelo multiciclo. Como esse arranjo melhora o desempenho computacional da arquitetura multiciclo?","text":"<p>No pipeline, essas mesmas cinco etapas s\u00e3o organizadas em est\u00e1gios que funcionam em paralelo, permitindo que v\u00e1rias instru\u00e7\u00f5es sejam processadas ao mesmo tempo (uma em Fetch, outra em Decode, outra em Execute, etc.). Depois de cheio, o pipeline se aproxima de completar uma instru\u00e7\u00e3o por ciclo, reduzindo o CPI em rela\u00e7\u00e3o aos modelos uniciclo e multiciclo sem pipeline.</p>"},{"location":"prova/p2/#d-no-modelo-multiciclo-qual-e-a-quantidade-de-ciclos-maxima-teorica-necessaria-para-executar-uma-instrucao-por-que-na-pratica-as-instrucoes-executam-gastando-uma-quantidade-diferente-de-ciclos-do-que-aquela-que-foi-prevista-no-modelo-teorico-cite-exemplos-de-instrucoes-em-que-a-quantidade-teorica-e-diferente-da-observada-na-pratica-indicando-os-motivos-pelos-quais-isso-acontece","title":"d) No modelo multiciclo, qual \u00e9 a quantidade de ciclos m\u00e1xima (te\u00f3rica) necess\u00e1ria para executar uma instru\u00e7\u00e3o? Por que, na pr\u00e1tica, as instru\u00e7\u00f5es executam gastando uma quantidade diferente de ciclos do que aquela que foi prevista no modelo te\u00f3rico? Cite exemplos de instru\u00e7\u00f5es em que a quantidade te\u00f3rica \u00e9 diferente da observada na pr\u00e1tica, indicando os motivos pelos quais isso acontece.","text":"<p>No modelo multiciclo, o m\u00e1ximo te\u00f3rico \u00e9 5 ciclos por instru\u00e7\u00e3o. Na pr\u00e1tica, as instru\u00e7\u00f5es gastam quantidades diferentes de ciclos porque nem todas precisam passar por todas as etapas. Por exemplo, <code>lw</code> usa 5 ciclos (IF, ID, EX, MEM, WB), <code>sw</code> n\u00e3o faz Writeback e usa 4 ciclos, <code>beq</code> n\u00e3o acessa mem\u00f3ria nem escreve registrador e usa cerca de 3 ciclos, e instru\u00e7\u00f5es do tipo R, como <code>add</code>, usam menos etapas do que <code>lw</code>, consumindo menos ciclos.</p>"},{"location":"prova/p2/#questao-2-considerando-sistemas-computacionais-responda","title":"Quest\u00e3o 2 \u2013 Considerando sistemas computacionais, responda:","text":""},{"location":"prova/p2/#a-o-que-e-um-barramento-na-sua-resposta-indique-tambem-os-conjuntos-de-linhas-tipicamente-encontrados-em-um-barramento","title":"a) O que \u00e9 um barramento? Na sua resposta, indique tamb\u00e9m os conjuntos de linhas tipicamente encontrados em um barramento.","text":"<p>Um barramento \u00e9 um conjunto de linhas condutoras compartilhadas que interliga CPU, mem\u00f3ria e dispositivos de E/S, permitindo a troca de informa\u00e7\u00f5es. Ele \u00e9 formado, tipicamente, por linhas de endere\u00e7o (indicam onde ler ou escrever), linhas de dados (transportam os valores), linhas de controle (definem o tipo de opera\u00e7\u00e3o e o dispositivo ativo) e linhas de pot\u00eancia (alimenta\u00e7\u00e3o). Barramentos paralelos transmitem v\u00e1rios bits ao mesmo tempo em muitas linhas, enquanto barramentos seriais transmitem os bits em poucas linhas, um por vez, compensando com frequ\u00eancias maiores e t\u00e9cnicas de codifica\u00e7\u00e3o e corre\u00e7\u00e3o de erros.</p>"},{"location":"prova/p2/#b-o-que-e-uma-excecao-no-contexto-de-um-sistema-computacional-como-um-processador-digital-lidatrata-uma-excecao-na-sua-resposta-cite-exemplos-de-excecoes","title":"b) O que \u00e9 uma exce\u00e7\u00e3o no contexto de um sistema computacional? Como um processador digital lida/trata uma exce\u00e7\u00e3o? Na sua resposta, cite exemplos de exce\u00e7\u00f5es.","text":"<p>Uma exce\u00e7\u00e3o \u00e9 um desvio anormal do fluxo normal de execu\u00e7\u00e3o causado por um evento interno, como instru\u00e7\u00e3o ilegal, endere\u00e7o desalinhado ou falha de acesso \u00e0 mem\u00f3ria. Ao detectar a exce\u00e7\u00e3o, o processador interrompe o programa, salva o contexto essencial (por exemplo, o endere\u00e7o da instru\u00e7\u00e3o que causou o problema), desvia para uma rotina de tratamento (exception handler), executa a a\u00e7\u00e3o apropriada (corrigir, abortar, sinalizar erro) e depois pode retornar ao programa.</p>"},{"location":"prova/p2/#c-por-que-uma-quantidade-pequena-de-memoria-de-elevada-velocidade-sram-e-capaz-de-prover-um-desempenho-computacional-elevado-para-um-sistema-que-explora-hierarquia-de-memorias","title":"c) Por que uma quantidade pequena de mem\u00f3ria de elevada velocidade (SRAM) \u00e9 capaz de prover um desempenho computacional elevado para um sistema que explora hierarquia de mem\u00f3rias?","text":"<p>Uma pequena quantidade de SRAM r\u00e1pida, usada como cache, melhora o desempenho porque os programas tendem a reutilizar, muitas vezes, um conjunto pequeno de instru\u00e7\u00f5es e dados, e a acessar posi\u00e7\u00f5es vizinhas na mem\u00f3ria. Esses dados mais usados ficam na SRAM e s\u00e3o acessados em poucos ciclos, enquanto apenas uma parte menor dos acessos vai para a DRAM mais lenta. Como o desempenho efetivo depende do tempo m\u00e9dio de acesso (AMAT) \u2014 que combina tempo de acerto + taxa de faltas \u00d7 penalidade da falta \u2014 ter uma cache SRAM pequena, por\u00e9m com alta taxa de acertos, faz o tempo m\u00e9dio ficar pr\u00f3ximo ao da SRAM, mesmo que o restante da hierarquia (DRAM, SSD, HDD) seja muito maior e mais lenta.</p>"},{"location":"prova/p2/#questao-4-considerando-que-as-variaveis-i-j-e-k-sao-respectivamente-manipuladas-atraves-dos-registradores-t0-tl-e-t2-implemente-os-seguintes-fragmentos-de-codigos-de-linguagem-c-na-linguagem-de-montagem-da-arquitetura-riscv","title":"Quest\u00e3o 4: Considerando que as vari\u00e1veis i, j e k s\u00e3o, respectivamente, manipuladas atrav\u00e9s dos registradores t0, tl e t2, implemente os seguintes fragmentos de c\u00f3digos de linguagem C na linguagem de montagem da arquitetura RISCV","text":"<p>Assuma: - <code>i</code> est\u00e1 em <code>t0</code> - <code>j</code> est\u00e1 em <code>t1</code> - <code>k</code> est\u00e1 em <code>t2</code></p>"},{"location":"prova/p2/#a-if-i-87-j-j-33-else-j-j-k","title":"a) <code>if (i &lt; 87) j = j + 33; else j = j - k;</code>","text":"<p>Aqui o r\u00f3tulo <code>fim_if</code> termina o programa com syscall 10.</p> <pre><code>    # i em t0, j em t1, k em t2\n\n    li      t3, 87          # t3 = 87 (constante para compara\u00e7\u00e3o)\n\n    bge     t0, t3, else_if # se i &gt;= 87, desvia para o else\n\n    # if (i &lt; 87) j = j + 33;\n    addi    t1, t1, 33      # j = j + 33\n    j       fim_if          # pula o bloco do else\n\nelse_if:\n    # else j = j - k;\n    sub     t1, t1, t2      # j = j - k\n\nfim_if:\n    # encerra o programa\n    li      a7, 10          # c\u00f3digo de servi\u00e7o 10 = exit\n    ecall\n````\n\n---\n\n### b)\n\n```c\ndo {\n    i = k + 29;\n    k = 2 * k;\n    j++;\n} while (j &lt;= 100);\n</code></pre> <pre><code>    # i em t0, j em t1, k em t2\n\nloop_do_while:\n    # i = k + 29;\n    addi    t0, t2, 29      # t0 = t2 + 29  (i = k + 29)\n\n    # k = 2 * k;\n    slli    t2, t2, 1       # k = k &lt;&lt; 1  =&gt; 2 * k\n\n    # j++;\n    addi    t1, t1, 1       # j = j + 1\n\n    # while (j &lt;= 100);\n    li      t3, 100         # t3 = 100\n    ble     t1, t3, loop_do_while\n                            # se j &lt;= 100, repete o la\u00e7o\n\nfim_loop:\n    # encerra o programa\n    li      a7, 10          # c\u00f3digo de servi\u00e7o 10 = exit\n    ecall\n</code></pre>"},{"location":"prova/p2/#questao-6-conversor-de-fahrenheit-para-celsius-em-risc-v-rv32imfdn","title":"Quest\u00e3o 6 \u2013 Conversor de Fahrenheit para Celsius em RISC-V RV32IMFDN","text":"<p>Converter uma temperatura em Fahrenheit (F) para Celsius (C), usando a f\u00f3rmula:</p> <p>[ C = (F - 32) \\times \\frac{5}{9} ]</p> <p>A seguir um programa em RISC-V (para o RARS) que:</p> <ol> <li>L\u00ea um n\u00famero em Fahrenheit (como <code>float</code>);</li> <li>Converte para Celsius usando ponto flutuante (RV32F);</li> <li>Imprime o resultado em Celsius;</li> <li>Encerra com syscall <code>10</code>.</li> </ol> <pre><code>    .data\nmsg_f:      .string \"Digite a temperatura em Fahrenheit: \"\nmsg_c:      .string \"\\nTemperatura em Celsius: \"\ncte_32:     .float 32.0        # constante 32.0\ncte_5:      .float 5.0         # constante 5.0\ncte_9:      .float 9.0         # constante 9.0\n\n    .text\n    .globl main\n\nmain:\n    ########################################\n    # Imprimir mensagem para ler Fahrenheit\n    ########################################\n    la   a0, msg_f         # a0 = endere\u00e7o da string\n    li   a7, 4             # servi\u00e7o 4 = print string\n    ecall\n\n    ########################################\n    # Ler valor em Fahrenheit (float)\n    ########################################\n    li   a7, 6             # servi\u00e7o 6 = read float\n    ecall                  # valor lido vai para fa0 (Fahrenheit)\n\n    ########################################\n    # C\u00e1lculo: C = (F - 32.0) * 5.0 / 9.0\n    ########################################\n\n    # Carrega 32.0 em ft0\n    la   t0, cte_32\n    flw  ft0, 0(t0)        # ft0 = 32.0\n\n    # (F - 32.0) =&gt; fa1 = fa0 - ft0\n    fsub.s fa1, fa0, ft0   # fa1 = F - 32.0\n\n    # Carrega 5.0 em ft1\n    la   t0, cte_5\n    flw  ft1, 0(t0)        # ft1 = 5.0\n\n    # (F - 32.0) * 5.0 =&gt; fa1 = fa1 * ft1\n    fmul.s fa1, fa1, ft1   # fa1 = (F - 32.0) * 5.0\n\n    # Carrega 9.0 em ft2\n    la   t0, cte_9\n    flw  ft2, 0(t0)        # ft2 = 9.0\n\n    # ((F - 32.0) * 5.0) / 9.0 =&gt; fa0 = fa1 / ft2\n    fdiv.s fa0, fa1, ft2   # fa0 = (F - 32.0) * 5.0 / 9.0  (Celsius)\n\n    ########################################\n    # Imprimir resultado em Celsius\n    ########################################\n    la   a0, msg_c         # imprime mensagem \"Temperatura em Celsius: \"\n    li   a7, 4             # print string\n    ecall\n\n    # imprimir valor em fa0 (float)\n    li   a7, 2             # servi\u00e7o 2 = print float\n    ecall\n\n\n    # Encerrar programa (exit com syscall 10)\n\n    li   a7, 10            # servi\u00e7o 10 = exit\n    ecall\n</code></pre>"},{"location":"prova/p2/#questao-7-uma-progressao-aritmetica-abreviadamente-pa-e-uma-sequencia-numerica-em-que-cada-termo-a-partir-do-segundo-e-igual-a-soma-do-termo-anterior-com-uma-constante-r-o-numero-r-e-chamado-de-razao-ou-diferenca-comum-da-progressao-aritmetica-de-outra-forma-anan1rn11-denominemos-o-primeiro-termo-da-pa-de-ao-implemente-um-procedimento-em-assembly-riscv-rv32imf-que-calcule-a-soma-dos-n-primeiros-termos-de-uma-pa-com-primeiro-termo-igual-a0-e-razao-r-assuma-que-do-e-r-sejam-valores-inteiros","title":"Quest\u00e3o 7: Uma progress\u00e3o aritm\u00e9tica (abreviadamente, PA) \u00e9 uma sequ\u00eancia num\u00e9rica em que cada termo, a partir do segundo, \u00e9 igual \u00e0 soma do termo anterior com uma constante r. O n\u00famero r \u00e9 chamado de raz\u00e3o ou diferen\u00e7a comum da progress\u00e3o aritm\u00e9tica. De outra forma, an\u200b=an\u22121\u200b+r,n&gt;11. Denominemos o primeiro termo da PA de ao- Implemente um procedimento em assembly riscv rv32imf que calcule a soma dos n primeiros termos de uma PA com primeiro termo igual a\u2080, e raz\u00e3o r. Assuma que do e r sejam valores inteiros.","text":"<pre><code># soma_pa\n# Calcula a soma dos n primeiros termos de uma PA:\n#   S_n = n * (2*a0 + (n-1)*r) / 2\n#\n# Entradas:\n#   a0 = a0  (primeiro termo)\n#   a1 = r   (razao)\n#   a2 = n   (numero de termos)\n# Sa\u00edda:\n#   a0 = S_n (soma)\n\nsoma_pa:\n    # t0 = a0, t1 = r, t2 = n\n    mv   t0, a0          # copia a0 para t0\n    mv   t1, a1          # copia r para t1\n    mv   t2, a2          # copia n para t2\n\n    # t3 = 2 * a0\n    slli t3, t0, 1       # t3 = a0 &lt;&lt; 1  (2 * a0)\n\n    # t4 = (n - 1) * r\n    addi t4, t2, -1      # t4 = n - 1\n    mul  t4, t4, t1      # t4 = (n - 1) * r\n\n    # t3 = 2*a0 + (n-1)*r\n    add  t3, t3, t4      # t3 = t3 + t4\n\n    # t3 = n * [2*a0 + (n-1)*r]\n    mul  t3, t3, t2      # t3 = t3 * n\n\n    # divide por 2: S_n = t3 / 2\n    li   t5, 2\n    div  t3, t3, t5      # t3 = t3 / 2\n\n    # resultado na sa\u00edda\n    mv   a0, t3\n    ret\n</code></pre>"},{"location":"prova/p2/#questao-8-analise-o-seguinte-fragmento-de-codigo-e-calcule-o-valor-em-t2-ao-alcancar-o-label-fim-atenda-ao-comentario-indicado-no-comeco-da-secao-de-dados-para-sua-analise","title":"Quest\u00e3o 8: Analise o seguinte fragmento de c\u00f3digo e calcule o valor em t2 ao alcan\u00e7ar o label Fim. Atenda ao coment\u00e1rio indicado no come\u00e7o da se\u00e7\u00e3o de dados para sua an\u00e1lise:","text":"<pre><code>\n    .data                       # Se\u00e7\u00e3o de dados: vari\u00e1veis armazenadas na mem\u00f3ria\n\nsup:    .word 42                # inteiro de 32 bits chamado 'sup' com valor 42\ndigs:   .word 58                # inteiro de 32 bits chamado 'digs' com valor 58\nstring: .string \" \\n\"           # string com espa\u00e7o e quebra de linha para sa\u00edda\n\n    .text                       # Se\u00e7\u00e3o de c\u00f3digo (instru\u00e7\u00f5es)\n\nmain:                           # Label de entrada do programa\n\n    lw t1, digs                 # t1 = conte\u00fado de 'digs' (58)\n    lw a1, sup                  # a1 = conte\u00fado de 'sup'  (42)\n\n    ori a0, t1, 0x01            # a0 = t1 OR 0x01 \u2192 for\u00e7a o bit menos significativo para 1 (58 vira 59)\n    add a0, a0, a1              # a0 = a0 + a1 \u2192 59 + 42 = 101\n\n    jal func                    # chama a fun\u00e7\u00e3o 'func'; ra recebe o endere\u00e7o de retorno\n\n    add t2, zero, a0            # t2 = a0 \u2192 copia o valor retornado por 'func' para t2\n\nFim:                            # Label Fim: ponto onde ser\u00e1 feita a impress\u00e3o\n\n    li a7, 1                    # a7 = 1 \u2192 syscall 1 (imprimir inteiro em a0)\n    add a0, t2, zero            # a0 = t2 \u2192 coloca o valor de t2 em a0 para impress\u00e3o\n    ecall                       # chamada de sistema: imprime o inteiro em a0\n\n    li a7, 4                    # a7 = 4 \u2192 syscall 4 (imprimir string cujo endere\u00e7o est\u00e1 em a0)\n    la a0, string               # a0 = endere\u00e7o da string \" \\n\"\n    ecall                       # chamada de sistema: imprime a string\n\n    li a7, 10                   # a7 = 10 \u2192 syscall 10 (encerrar programa)\n    ecall                       # encerra a execu\u00e7\u00e3o\n\n# ------------------ Fun\u00e7\u00e3o func ------------------\n\nfunc:                           # In\u00edcio da fun\u00e7\u00e3o 'func'\n\n    add t3, zero, zero          # t3 = 0 \u2192 flag de resultado (0 ou 1)\n    add t1, zero, zero          # t1 = 0 \u2192 ser\u00e1 usado como registrador auxiliar em slt\n\n    li t0, 3                    # t0 = 3 \u2192 primeiro divisor \u00edmpar a ser testado (3)\n\nfunc_loop:                      # In\u00edcio do la\u00e7o de teste de divisores\n\n    rem t2, a0, t0              # t2 = a0 % t0 \u2192 resto da divis\u00e3o de a0 por t0\n    beq t2, zero, func_exit     # se t2 == 0, achou divisor exato \u2192 vai para func_exit\n\n    addi t0, t0, 2              # t0 = t0 + 2 \u2192 pr\u00f3ximo n\u00famero \u00edmpar (3, 5, 7, 9, ...)\n    slt t1, a1, t0              # t1 = 1 se a1 &lt; t0, sen\u00e3o t1 = 0\n    beq t1, zero, func_loop     # se a1 &gt;= t0, continua o la\u00e7o; se a1 &lt; t0, sai do la\u00e7o\n\n    addi t3, zero, 1            # se chegou aqui, n\u00e3o achou divisor at\u00e9 ultrapassar 'a1' \u2192 t3 = 1\n\nfunc_exit:                      # Sa\u00edda da fun\u00e7\u00e3o 'func'\n\n    add a0, t3, zero            # a0 = t3 \u2192 valor retornado para o chamador (0 ou 1)\n    jr ra                       # jr ra \u2192 salta de volta para o endere\u00e7o salvo em ra (retorna para main)\n\n</code></pre> <p>digs 58</p> sup sa\u00edda 1 1 2 1 3 1 4 0 5 1 6 0 7 0 8 1 9 1 10 0 11 0 12 1 13 0 14 1 15 1 16 0 17 1 18 0 19 1 20 0 21 0 22 0 23 1 24 0 25 0 26 1 27 0 28 0 29 1 30 0 31 0 32 0 33 0 34 1 35 1 36 0 37 1 38 1 39 0 40 1 41 0 42 1 43 0 44 0 45 0 46 0 47 1 48 0 49 1 50 0 51 0 52 1 53 0 54 0 55 0 56 0 57 1 58 0 59 0 60 0 61 1 62 0 63 0 64 1 65 0 66 0 67 1 68 0 69 0 70 1 71 0 72 0 73 1 74 0 75 0 76 1 77 1 78 0 79 1 80 1 81 0 82 0 83 0 84 0 85 0 86 0 87 0 88 0 89 0 90 1 91 0 92 1 93 0 94 0 95 0 96 0 97 0 98 1 99 0 sup digs sa\u00edda 1 8 1 2 8 1 3 8 0 4 8 1 5 8 1 6 8 0 7 8 1 8 8 1 9 8 0 10 8 1 11 8 0 12 8 0 13 8 0 14 8 1 15 8 0 16 8 0 17 8 1 18 8 0 19 8 1 20 8 0 21 8 0 22 8 0 23 8 0 24 8 0 25 8 1 26 8 0 27 8 0 28 8 0 29 8 1 30 8 0 31 8 0 32 8 1 33 8 0 34 8 1 35 8 0 36 8 0 37 8 1 38 8 1 39 8 0 40 8 0 41 8 0 42 8 0 43 8 1 44 8 0 45 8 0 46 8 1 47 8 0 48 8 1 49 8 0 50 8 0 51 8 0 52 8 0 53 8 1 54 8 0 55 8 1 56 8 0 57 8 0 58 8 0 59 8 0 60 8 0 61 8 1 62 8 0 63 8 0 64 8 0 65 8 0 66 8 0 67 8 1 68 8 0 69 8 0 70 8 1 71 8 0 72 8 0 73 8 0 74 8 1 75 8 0 76 8 0 77 8 0 78 8 0 79 8 1 80 8 0 81 8 0 82 8 0 83 8 0 84 8 0 85 8 0 86 8 0 87 8 0 88 8 1 89 8 0 90 8 0 91 8 0 92 8 1 93 8 0 94 8 1 95 8 0 96 8 0 97 8 0 98 8 1 99 8 0"}]}