RV32IMFDN

### Questão 1 – Ao estudarmos o Caminho de Dados, módulos digitais básicos foram integrados para criar o núcleo de um sistema computacional, núcleo capaz de executar instruções lidas a partir da memória. Sobre o Caminho de Dados, responda:


### a) Descreva o modelo uniciclo.

No modelo uniciclo, cada instrução percorre todas as fases (buscar, decodificar, executar, acessar memória e escrever resultado) em um único ciclo de clock, o que simplifica o hardware, mas obriga o clock a ser tão lento quanto a instrução mais demorada.

### b) Descreva o modelo multiciclo, deixando claro em sua resposta as etapas utilizadas para garantir a execução de uma instrução.

No modelo multiciclo, cada instrução é dividida em vários ciclos de clock, reutilizando o mesmo hardware em etapas diferentes. As cinco etapas são: busca da instrução na memória (Fetch), decodificação e leitura de registradores (Decode), execução ou cálculo de endereço (Execute), acesso à memória (Memory) e escrita do resultado no registrador de destino (Writeback).

### c) O Pipeline é uma evolução aplicada ao modelo multiciclo. Como esse arranjo melhora o desempenho computacional da arquitetura multiciclo?

No pipeline, essas mesmas cinco etapas são organizadas em estágios que funcionam em paralelo, permitindo que várias instruções sejam processadas ao mesmo tempo (uma em Fetch, outra em Decode, outra em Execute, etc.). Depois de cheio, o pipeline se aproxima de completar uma instrução por ciclo, reduzindo o CPI em relação aos modelos uniciclo e multiciclo sem pipeline.

### d) No modelo multiciclo, qual é a quantidade de ciclos máxima (teórica) necessária para executar uma instrução? Por que, na prática, as instruções executam gastando uma quantidade diferente de ciclos do que aquela que foi prevista no modelo teórico? Cite exemplos de instruções em que a quantidade teórica é diferente da observada na prática, indicando os motivos pelos quais isso acontece.

No modelo multiciclo, o máximo teórico é 5 ciclos por instrução. Na prática, as instruções gastam quantidades diferentes de ciclos porque nem todas precisam passar por todas as etapas. Por exemplo, `lw` usa 5 ciclos (IF, ID, EX, MEM, WB), `sw` não faz Writeback e usa 4 ciclos, `beq` não acessa memória nem escreve registrador e usa cerca de 3 ciclos, e instruções do tipo R, como `add`, usam menos etapas do que `lw`, consumindo menos ciclos.

---

### Questão 2 – Considerando sistemas computacionais, responda:

### a) O que é um barramento? Na sua resposta, indique também os conjuntos de linhas tipicamente encontrados em um barramento.

Um barramento é um conjunto de linhas condutoras compartilhadas que interliga CPU, memória e dispositivos de E/S, permitindo a troca de informações. Ele é formado, tipicamente, por linhas de endereço (indicam onde ler ou escrever), linhas de dados (transportam os valores), linhas de controle (definem o tipo de operação e o dispositivo ativo) e linhas de potência (alimentação). Barramentos paralelos transmitem vários bits ao mesmo tempo em muitas linhas, enquanto barramentos seriais transmitem os bits em poucas linhas, um por vez, compensando com frequências maiores e técnicas de codificação e correção de erros.

### b) O que é uma exceção no contexto de um sistema computacional? Como um processador digital lida/trata uma exceção? Na sua resposta, cite exemplos de exceções.

Uma exceção é um desvio anormal do fluxo normal de execução causado por um evento interno, como instrução ilegal, endereço desalinhado ou falha de acesso à memória. Ao detectar a exceção, o processador interrompe o programa, salva o contexto essencial (por exemplo, o endereço da instrução que causou o problema), desvia para uma rotina de tratamento (exception handler), executa a ação apropriada (corrigir, abortar, sinalizar erro) e depois pode retornar ao programa.

### c) Por que uma quantidade pequena de memória de elevada velocidade (SRAM) é capaz de prover um desempenho computacional elevado para um sistema que explora hierarquia de memórias?

Uma pequena quantidade de SRAM rápida, usada como cache, melhora o desempenho porque os programas tendem a reutilizar, muitas vezes, um conjunto pequeno de instruções e dados, e a acessar posições vizinhas na memória. Esses dados mais usados ficam na SRAM e são acessados em poucos ciclos, enquanto apenas uma parte menor dos acessos vai para a DRAM mais lenta. Como o desempenho efetivo depende do tempo médio de acesso (AMAT) — que combina tempo de acerto + taxa de faltas × penalidade da falta — ter uma cache SRAM pequena, porém com alta taxa de acertos, faz o tempo médio ficar próximo ao da SRAM, mesmo que o restante da hierarquia (DRAM, SSD, HDD) seja muito maior e mais lenta.

### Questão 4: Considerando que as variáveis i, j e k são, respectivamente, manipuladas através dos registradores t0, tl e t2, implemente os seguintes fragmentos de códigos de linguagem C na linguagem de montagem da arquitetura RISCV

Assuma:
- `i` está em `t0`
- `j` está em `t1`
- `k` está em `t2`

---

### a) `if (i < 87) j = j + 33; else j = j - k;`

Aqui o rótulo `fim_if` termina o programa com syscall 10.

```asm
    # i em t0, j em t1, k em t2

    li      t3, 87          # t3 = 87 (constante para comparação)

    bge     t0, t3, else_if # se i >= 87, desvia para o else

    # if (i < 87) j = j + 33;
    addi    t1, t1, 33      # j = j + 33
    j       fim_if          # pula o bloco do else

else_if:
    # else j = j - k;
    sub     t1, t1, t2      # j = j - k

fim_if:
    # encerra o programa
    li      a7, 10          # código de serviço 10 = exit
    ecall
````

---

### b)

```c
do {
    i = k + 29;
    k = 2 * k;
    j++;
} while (j <= 100);
```

```asm
    # i em t0, j em t1, k em t2

loop_do_while:
    # i = k + 29;
    addi    t0, t2, 29      # t0 = t2 + 29  (i = k + 29)

    # k = 2 * k;
    slli    t2, t2, 1       # k = k << 1  => 2 * k

    # j++;
    addi    t1, t1, 1       # j = j + 1

    # while (j <= 100);
    li      t3, 100         # t3 = 100
    ble     t1, t3, loop_do_while
                            # se j <= 100, repete o laço

fim_loop:
    # encerra o programa
    li      a7, 10          # código de serviço 10 = exit
    ecall
```

## Questão 6 – Conversor de Fahrenheit para Celsius em RISC-V RV32IMFDN

Converter uma temperatura em Fahrenheit (F) para Celsius (C), usando a fórmula:

\[
C = (F - 32) \times \frac{5}{9}
\]

A seguir um programa em RISC-V (para o RARS) que:

1. Lê um número em **Fahrenheit** (como `float`);
2. Converte para **Celsius** usando ponto flutuante (RV32F);
3. Imprime o resultado em Celsius;
4. Encerra com syscall `10`.

```asm
    .data
msg_f:      .string "Digite a temperatura em Fahrenheit: "
msg_c:      .string "\nTemperatura em Celsius: "
cte_32:     .float 32.0        # constante 32.0
cte_5:      .float 5.0         # constante 5.0
cte_9:      .float 9.0         # constante 9.0

    .text
    .globl main

main:
    ########################################
    # Imprimir mensagem para ler Fahrenheit
    ########################################
    la   a0, msg_f         # a0 = endereço da string
    li   a7, 4             # serviço 4 = print string
    ecall

    ########################################
    # Ler valor em Fahrenheit (float)
    ########################################
    li   a7, 6             # serviço 6 = read float
    ecall                  # valor lido vai para fa0 (Fahrenheit)

    ########################################
    # Cálculo: C = (F - 32.0) * 5.0 / 9.0
    ########################################

    # Carrega 32.0 em ft0
    la   t0, cte_32
    flw  ft0, 0(t0)        # ft0 = 32.0

    # (F - 32.0) => fa1 = fa0 - ft0
    fsub.s fa1, fa0, ft0   # fa1 = F - 32.0

    # Carrega 5.0 em ft1
    la   t0, cte_5
    flw  ft1, 0(t0)        # ft1 = 5.0

    # (F - 32.0) * 5.0 => fa1 = fa1 * ft1
    fmul.s fa1, fa1, ft1   # fa1 = (F - 32.0) * 5.0

    # Carrega 9.0 em ft2
    la   t0, cte_9
    flw  ft2, 0(t0)        # ft2 = 9.0

    # ((F - 32.0) * 5.0) / 9.0 => fa0 = fa1 / ft2
    fdiv.s fa0, fa1, ft2   # fa0 = (F - 32.0) * 5.0 / 9.0  (Celsius)

    ########################################
    # Imprimir resultado em Celsius
    ########################################
    la   a0, msg_c         # imprime mensagem "Temperatura em Celsius: "
    li   a7, 4             # print string
    ecall

    # imprimir valor em fa0 (float)
    li   a7, 2             # serviço 2 = print float
    ecall


    # Encerrar programa (exit com syscall 10)

    li   a7, 10            # serviço 10 = exit
    ecall
```

### Questão 7: Analise o seguinte fragmento de código e calcule o valor em t2 ao alcançar o label Fim. Atenda ao comentário indicado no começo da seção de dados para sua análise: 

```asm

    .data                       # Seção de dados: variáveis armazenadas na memória

sup:    .word 42                # inteiro de 32 bits chamado 'sup' com valor 42
digs:   .word 58                # inteiro de 32 bits chamado 'digs' com valor 58
string: .string " \n"           # string com espaço e quebra de linha para saída

    .text                       # Seção de código (instruções)

main:                           # Label de entrada do programa

    lw t1, digs                 # t1 = conteúdo de 'digs' (58)
    lw a1, sup                  # a1 = conteúdo de 'sup'  (42)
    
    ori a0, t1, 0x01            # a0 = t1 OR 0x01 → força o bit menos significativo para 1 (58 vira 59)
    add a0, a0, a1              # a0 = a0 + a1 → 59 + 42 = 101
    
    jal func                    # chama a função 'func'; ra recebe o endereço de retorno
    
    add t2, zero, a0            # t2 = a0 → copia o valor retornado por 'func' para t2
    
Fim:                            # Label Fim: ponto onde será feita a impressão

    li a7, 1                    # a7 = 1 → syscall 1 (imprimir inteiro em a0)
    add a0, t2, zero            # a0 = t2 → coloca o valor de t2 em a0 para impressão
    ecall                       # chamada de sistema: imprime o inteiro em a0
    
    li a7, 4                    # a7 = 4 → syscall 4 (imprimir string cujo endereço está em a0)
    la a0, string               # a0 = endereço da string " \n"
    ecall                       # chamada de sistema: imprime a string
    
    li a7, 10                   # a7 = 10 → syscall 10 (encerrar programa)
    ecall                       # encerra a execução

# ------------------ Função func ------------------

func:                           # Início da função 'func'

    add t3, zero, zero          # t3 = 0 → flag de resultado (0 ou 1)
    add t1, zero, zero          # t1 = 0 → será usado como registrador auxiliar em slt
    
    li t0, 3                    # t0 = 3 → primeiro divisor ímpar a ser testado (3)

func_loop:                      # Início do laço de teste de divisores

    rem t2, a0, t0              # t2 = a0 % t0 → resto da divisão de a0 por t0
    beq t2, zero, func_exit     # se t2 == 0, achou divisor exato → vai para func_exit
    
    addi t0, t0, 2              # t0 = t0 + 2 → próximo número ímpar (3, 5, 7, 9, ...)
    slt t1, a1, t0              # t1 = 1 se a1 < t0, senão t1 = 0
    beq t1, zero, func_loop     # se a1 >= t0, continua o laço; se a1 < t0, sai do laço
    
    addi t3, zero, 1            # se chegou aqui, não achou divisor até ultrapassar 'a1' → t3 = 1

func_exit:                      # Saída da função 'func'

    add a0, t3, zero            # a0 = t3 → valor retornado para o chamador (0 ou 1)
    jr ra                       # jr ra → salta de volta para o endereço salvo em ra (retorna para main)

```


digs 58

| sup | saída |
| ---: | ---: |
| 1   | 1     |
| 2   | 1     |
| 3   | 1     |
| 4   | 0     |
| 5   | 1     |
| 6   | 0     |
| 7   | 0     |
| 8   | 1     |
| 9   | 1     |
| 10  | 0     |
| 11  | 0     |
| 12  | 1     |
| 13  | 0     |
| 14  | 1     |
| 15  | 1     |
| 16  | 0     |
| 17  | 1     |
| 18  | 0     |
| 19  | 1     |
| 20  | 0     |
| 21  | 0     |
| 22  | 0     |
| 23  | 1     |
| 24  | 0     |
| 25  | 0     |
| 26  | 1     |
| 27  | 0     |
| 28  | 0     |
| 29  | 1     |
| 30  | 0     |
| 31  | 0     |
| 32  | 0     |
| 33  | 0     |
| 34  | 1     |
| 35  | 1     |
| 36  | 0     |
| 37  | 1     |
| 38  | 1     |
| 39  | 0     |
| 40  | 1     |
| 41  | 0     |
| 42  | 1     |
| 43  | 0     |
| 44  | 0     |
| 45  | 0     |
| 46  | 0     |
| 47  | 1     |
| 48  | 0     |
| 49  | 1     |
| 50  | 0     |
| 51  | 0     |
| 52  | 1     |
| 53  | 0     |
| 54  | 0     |
| 55  | 0     |
| 56  | 0     |
| 57  | 1     |
| 58  | 0     |
| 59  | 0     |
| 60  | 0     |
| 61  | 1     |
| 62  | 0     |
| 63  | 0     |
| 64  | 1     |
| 65  | 0     |
| 66  | 0     |
| 67  | 1     |
| 68  | 0     |
| 69  | 0     |
| 70  | 1     |
| 71  | 0     |
| 72  | 0     |
| 73  | 1     |
| 74  | 0     |
| 75  | 0     |
| 76  | 1     |
| 77  | 1     |
| 78  | 0     |
| 79  | 1     |
| 80  | 1     |
| 81  | 0     |
| 82  | 0     |
| 83  | 0     |
| 84  | 0     |
| 85  | 0     |
| 86  | 0     |
| 87  | 0     |
| 88  | 0     |
| 89  | 0     |
| 90  | 1     |
| 91  | 0     |
| 92  | 1     |
| 93  | 0     |
| 94  | 0     |
| 95  | 0     |
| 96  | 0     |
| 97  | 0     |
| 98  | 1     |
| 99  | 0     |

| sup | digs | saída |
| --: | ---: | ----: |
|   1 |    8 |     1 |
|   2 |    8 |     1 |
|   3 |    8 |     0 |
|   4 |    8 |     1 |
|   5 |    8 |     1 |
|   6 |    8 |     0 |
|   7 |    8 |     1 |
|   8 |    8 |     1 |
|   9 |    8 |     0 |
|  10 |    8 |     1 |
|  11 |    8 |     0 |
|  12 |    8 |     0 |
|  13 |    8 |     0 |
|  14 |    8 |     1 |
|  15 |    8 |     0 |
|  16 |    8 |     0 |
|  17 |    8 |     1 |
|  18 |    8 |     0 |
|  19 |    8 |     1 |
|  20 |    8 |     0 |
|  21 |    8 |     0 |
|  22 |    8 |     0 |
|  23 |    8 |     0 |
|  24 |    8 |     0 |
|  25 |    8 |     1 |
|  26 |    8 |     0 |
|  27 |    8 |     0 |
|  28 |    8 |     0 |
|  29 |    8 |     1 |
|  30 |    8 |     0 |
|  31 |    8 |     0 |
|  32 |    8 |     1 |
|  33 |    8 |     0 |
|  34 |    8 |     1 |
|  35 |    8 |     0 |
|  36 |    8 |     0 |
|  37 |    8 |     1 |
|  38 |    8 |     1 |
|  39 |    8 |     0 |
|  40 |    8 |     0 |
|  41 |    8 |     0 |
|  42 |    8 |     0 |
|  43 |    8 |     1 |
|  44 |    8 |     0 |
|  45 |    8 |     0 |
|  46 |    8 |     1 |
|  47 |    8 |     0 |
|  48 |    8 |     1 |
|  49 |    8 |     0 |
|  50 |    8 |     0 |
|  51 |    8 |     0 |
|  52 |    8 |     0 |
|  53 |    8 |     1 |
|  54 |    8 |     0 |
|  55 |    8 |     1 |
|  56 |    8 |     0 |
|  57 |    8 |     0 |
|  58 |    8 |     0 |
|  59 |    8 |     0 |
|  60 |    8 |     0 |
|  61 |    8 |     1 |
|  62 |    8 |     0 |
|  63 |    8 |     0 |
|  64 |    8 |     0 |
|  65 |    8 |     0 |
|  66 |    8 |     0 |
|  67 |    8 |     1 |
|  68 |    8 |     0 |
|  69 |    8 |     0 |
|  70 |    8 |     1 |
|  71 |    8 |     0 |
|  72 |    8 |     0 |
|  73 |    8 |     0 |
|  74 |    8 |     1 |
|  75 |    8 |     0 |
|  76 |    8 |     0 |
|  77 |    8 |     0 |
|  78 |    8 |     0 |
|  79 |    8 |     1 |
|  80 |    8 |     0 |
|  81 |    8 |     0 |
|  82 |    8 |     0 |
|  83 |    8 |     0 |
|  84 |    8 |     0 |
|  85 |    8 |     0 |
|  86 |    8 |     0 |
|  87 |    8 |     0 |
|  88 |    8 |     1 |
|  89 |    8 |     0 |
|  90 |    8 |     0 |
|  91 |    8 |     0 |
|  92 |    8 |     1 |
|  93 |    8 |     0 |
|  94 |    8 |     1 |
|  95 |    8 |     0 |
|  96 |    8 |     0 |
|  97 |    8 |     0 |
|  98 |    8 |     1 |
|  99 |    8 |     0 |



